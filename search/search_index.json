{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Remember These docs are not completed. Please do not panic if something is missing or inaccurate. We hope this documentation is helpful for you, but don't just Ctrl + C and Ctrl + V . \"What is this?\" \u00b6 This is Dis-Snek , an API wrapper for Discord, written in Python. This wrapper is designed to be easy to use, and easily modified to suit your needs. Features: \u00b6 100% coverage of the application commands API Modern and Pythonic API Asynchronous operation Proper rate limit handling Dynamic cache with TTL support \"Is this just another discord.py fork\" ? \u00b6 While this library shares some features and stylistic choice with discord.py , its completely separate from them. We think discord.py is a fantastic library, but we disagree with the direction and design decisions made by it. Compared to discord.py ; Snek starts faster, responds faster, and is simpler to use. Especially compared to Views . \"I don't like how you've done x feature\" \u00b6 Make an issue on our GitHub Repo and we can have a discussion on it. Or if you want faster responses, join our Discord Server \"I don't understand something\"\" \u00b6 If you need help with something, don\u2019t hesitate to ask for help in the Discord Server ! \"Can I contribute to this project? \"` \u00b6 Of course, you can contribute to this project by submitting a pull-request to the GitHub Repo . We also have a Trello Board where you can see what we are working towards, feel free to do anything there.","title":"Home"},{"location":"FAQ/","text":"Notice This page is a placeholder, and will be populated at a later date.","title":"FAQ"},{"location":"API%20Reference/client/","text":"Snake ( ChannelEvents , GuildEvents , MemberEvents , MessageEvents , ReactionEvents , RoleEvents , StageEvents , ThreadEvents , UserEvents ) \u00b6 The bot client. Note By default, all non-privileged intents will be enabled Attributes: Name Type Description intents Union[int, Intents] The intents to use loop asyncio.AbstractEventLoop An event loop to use, normally leave this blank default_prefix str The default_prefix to use for message commands, defaults to your bot being mentioned get_prefix Callable[..., Coroutine] A coroutine that returns a string to determine prefixes sync_interactions bool Should application commands be synced with discord? delete_unused_application_cmds bool Delete any commands from discord that arent implemented in this client asyncio_debug bool Enable asyncio debug features status Status The status the bot should login with (IE ONLINE, DND, IDLE) activity Activity The activity the bot should login \"playing\" Optionally, you can configure the caches here, by specifying the name of the cache, followed by a dict-style object to use. It is recommended to use smart_cache.create_cache to configure the cache here. as an example, this is a recommended attribute message_cache=create_cache(250, 50) , Note Setting a message cache hard limit to None is not recommended, as it could result in extremely high memory usage, we suggest a sane limit. Source code in dis_snek/client.py class Snake ( ChannelEvents , GuildEvents , MemberEvents , MessageEvents , ReactionEvents , RoleEvents , StageEvents , ThreadEvents , UserEvents , ): \"\"\" The bot client. note: By default, all non-privileged intents will be enabled Attributes: intents Union[int, Intents]: The intents to use loop: An event loop to use, normally leave this blank default_prefix str: The default_prefix to use for message commands, defaults to your bot being mentioned get_prefix Callable[..., Coroutine]: A coroutine that returns a string to determine prefixes sync_interactions bool: Should application commands be synced with discord? delete_unused_application_cmds bool: Delete any commands from discord that arent implemented in this client asyncio_debug bool: Enable asyncio debug features status Status: The status the bot should login with (IE ONLINE, DND, IDLE) activity Activity: The activity the bot should login \"playing\" Optionally, you can configure the caches here, by specifying the name of the cache, followed by a dict-style object to use. It is recommended to use `smart_cache.create_cache` to configure the cache here. as an example, this is a recommended attribute `message_cache=create_cache(250, 50)`, !!! note Setting a message cache hard limit to None is not recommended, as it could result in extremely high memory usage, we suggest a sane limit. \"\"\" def __init__ ( self , intents : Union [ int , Intents ] = Intents . DEFAULT , loop : Optional [ asyncio . AbstractEventLoop ] = None , default_prefix : str = MENTION_PREFIX , get_prefix : Callable [ ... , Coroutine ] = MISSING , sync_interactions : bool = False , delete_unused_application_cmds : bool = False , debug_scope : \"Snowflake_Type\" = MISSING , asyncio_debug : bool = False , status : Status = Status . ONLINE , activity : Union [ Activity , str ] = None , ** kwargs , ): self . loop : asyncio . AbstractEventLoop = asyncio . get_event_loop () if loop is None else loop # Configuration if asyncio_debug : log . warning ( \"Asyncio Debug is enabled, Your log will contain additional errors and warnings\" ) import tracemalloc tracemalloc . start () self . loop . set_debug ( True ) self . intents = intents \"\"\"The intents in use\"\"\" self . sync_interactions = sync_interactions \"\"\"Should application commands be synced\"\"\" self . del_unused_app_cmd : bool = delete_unused_application_cmds \"\"\"Should unused application commands be deleted?\"\"\" self . debug_scope = to_optional_snowflake ( debug_scope ) \"\"\"Sync global commands as guild for quicker command updates during debug\"\"\" self . default_prefix = default_prefix \"\"\"The default prefix to be used for message commands\"\"\" self . get_prefix = get_prefix if get_prefix is not MISSING else self . get_prefix \"\"\"A coroutine that returns a prefix, for dynamic prefixes\"\"\" # resources self . http : HTTPClient = HTTPClient ( loop = self . loop ) \"\"\"The HTTP client to use when interacting with discord endpoints\"\"\" self . ws : WebsocketClient = MISSING \"\"\"The websocket collection for the Discord Gateway.\"\"\" # flags self . _ready = False self . _closed = False self . _guild_event = asyncio . Event () self . guild_event_timeout = 3 \"\"\"How long to wait for guilds to be cached\"\"\" self . start_time = MISSING \"\"\"The DateTime the bot started at\"\"\" self . _mention_reg = MISSING # caches self . cache : GlobalCache = GlobalCache ( self , ** { k : v for k , v in kwargs . items () if hasattr ( GlobalCache , k )}) # these store the last sent presence data for change_presence self . _status : Status = status if isinstance ( activity , str ): self . _activity = Activity . create ( name = str ( activity )) else : self . _activity : Activity = activity self . _user : SnakeBotUser = MISSING self . _app : Application = MISSING # collections self . commands : Dict [ str , MessageCommand ] = {} \"\"\"A dictionary of registered commands: `{name: command}`\"\"\" self . interactions : Dict [ \"Snowflake_Type\" , Dict [ str , InteractionCommand ]] = {} \"\"\"A dictionary of registered application commands: `{cmd_id: command}`\"\"\" self . _component_callbacks : Dict [ str , Callable [ ... , Coroutine ]] = {} self . _interaction_scopes : Dict [ \"Snowflake_Type\" , \"Snowflake_Type\" ] = {} self . __extensions = {} self . scales = {} \"\"\"A dictionary of mounted Scales\"\"\" self . listeners : Dict [ str , List ] = {} self . waits : Dict [ str , List ] = {} @property def is_closed ( self ) -> bool : \"\"\"Is the bot closed?\"\"\" return self . _closed @property def is_ready ( self ): return self . _ready @property def latency ( self ) -> float : \"\"\"Returns the latency of the websocket connection\"\"\" return self . ws . latency @property def user ( self ) -> SnakeBotUser : \"\"\"Returns the bot's user\"\"\" return self . _user @property def app ( self ) -> Application : \"\"\"Returns the bots application\"\"\" return self . _app @property def owner ( self ) -> Optional [ \"User\" ]: \"\"\"Returns the bot's owner'\"\"\" try : return self . app . owner except TypeError : return MISSING @property def guilds ( self ) -> List [ \"Guild\" ]: return self . user . guilds @property def status ( self ) -> Status : \"\"\"Get the status of the bot. IE online, afk, dnd\"\"\" return self . _status @property def activity ( self ) -> Activity : \"\"\"Get the activity of the bot\"\"\" return self . _activity @property def application_commands ( self ): \"\"\"a list of all application commands registered within the bot\"\"\" commands = [] for scope in self . interactions . keys (): for cmd in self . interactions [ scope ] . values (): if cmd not in commands : commands . append ( cmd ) return commands async def get_prefix ( self , message : Message ) -> str : \"\"\"A method to get the bot's default_prefix, can be overridden to add dynamic prefixes. !!! note To easily override this method, simply use the `get_prefix` parameter when instantiating the client Args: message: A message to determine the prefix from. Returns: A string to use as a prefix, by default will return `client.default_prefix` \"\"\" return self . default_prefix async def login ( self , token ): \"\"\" Login to discord Args: token str: Your bot's token \"\"\" # i needed somewhere to put this call, # login will always run after initialisation # so im gathering commands here self . _gather_commands () log . debug ( f \"Attempting to login\" ) me = await self . http . login ( token . strip ()) self . _user = SnakeBotUser . from_dict ( me , self ) self . cache . place_user_data ( me ) self . _app = Application . from_dict ( await self . http . get_current_bot_information (), self ) self . _mention_reg = re . compile ( fr \"^(<@!? { self . user . id } *>\\s)\" ) self . start_time = datetime . datetime . now () self . dispatch ( events . Login ()) await self . _ws_connect () async def _ws_connect ( self ): params = { \"http\" : self . http , \"dispatch\" : self . dispatch , \"intents\" : self . intents , \"resume\" : False , \"session_id\" : None , \"sequence\" : None , \"presence\" : { \"status\" : self . _status , \"activities\" : [ self . _activity . to_dict ()] if self . _activity else []}, } while not self . is_closed : log . info ( f \"Attempting to { 're' if params [ 'resume' ] else '' } connect to gateway...\" ) try : self . ws = await WebsocketClient . connect ( ** params ) await self . ws . run () except WebSocketRestart as ex : # internally requested restart self . dispatch ( events . Disconnect ()) if ex . resume : params . update ( resume = True , session_id = self . ws . session_id , sequence = self . ws . sequence ) continue params . update ( resume = False , session_id = None , sequence = None ) except ( OSError , GatewayNotFound , aiohttp . ClientError , asyncio . TimeoutError , WebSocketClosed ) as ex : log . debug ( \"\" . join ( traceback . format_exception ( type ( ex ), ex , ex . __traceback__ ))) self . dispatch ( events . Disconnect ()) if isinstance ( ex , WebSocketClosed ): if ex . code == 1000 : if self . _ready : # the bot disconnected, attempt to reconnect to gateway params . update ( resume = True , session_id = self . ws . session_id , sequence = self . ws . sequence ) continue else : return elif ex . code == 4011 : raise SnakeException ( \"Your bot is too large, you must use shards\" ) from None elif ex . code == 4013 : raise SnakeException ( \"Invalid Intents have been passed\" ) from None elif ex . code == 4014 : raise SnakeException ( \"You have requested privileged intents that have not been enabled or approved. Check the developer dashboard\" ) from None raise if isinstance ( ex , OSError ) and ex . errno in ( 54 , 10054 ): print ( \"should reconnect\" ) params . update ( resume = True , session_id = self . ws . session_id , sequence = self . ws . sequence ) continue params . update ( resume = False , session_id = None , sequence = None ) except Exception as e : self . dispatch ( events . Disconnect ()) log . error ( \"\" . join ( traceback . format_exception ( type ( e ), e , e . __traceback__ ))) params . update ( resume = False , session_id = None , sequence = None ) await asyncio . sleep ( 5 ) def _queue_task ( self , coro , event , * args , ** kwargs ): async def _async_wrap ( _coro , _event , * _args , ** _kwargs ): try : if len ( _event . __attrs_attrs__ ) == 1 : await _coro () else : await _coro ( _event , * _args , ** _kwargs ) except asyncio . CancelledError : pass except Exception as e : await self . on_error ( event , e ) wrapped = _async_wrap ( coro , event , * args , ** kwargs ) return asyncio . create_task ( wrapped , name = f \"snake:: { event . resolved_name } \" ) async def on_error ( self , source : str , error : Exception , * args , ** kwargs ) -> None : \"\"\" Catches all errors dispatched by the library. By default it will format and print them to console Override this to change error handling behaviour \"\"\" print ( f \"Ignoring exception in { source } : \\n { traceback . format_exc () } \" , file = sys . stderr ) async def on_command_error ( self , source : str , error : Exception , * args , ** kwargs ) -> None : \"\"\" Catches all errors dispatched by commands By default it will call `Snake.on_error` Override this to change error handling behavior \"\"\" return await self . on_error ( source , error , * args , ** kwargs ) async def on_command ( self , ctx : Context ) -> None : \"\"\" Called *after* any command is ran By default, it will simply log the command, override this to change that behaviour Args: ctx: The context of the command that was called \"\"\" if isinstance ( ctx , MessageContext ): symbol = \"@\" elif isinstance ( ctx , ComponentContext ): symbol = \"\u00a2\" elif isinstance ( ctx , InteractionContext ): symbol = \"/\" else : symbol = \"?\" # likely custom context log . info ( f \"Command Called: { symbol }{ ctx . invoked_name } with { ctx . args = } | { ctx . kwargs = } \" ) @listen () async def _on_websocket_ready ( self , event : events . RawGatewayEvent ) -> None : \"\"\" Catches websocket ready and determines when to dispatch the client `READY` signal. Args: event: The websocket ready packet \"\"\" data = event . data expected_guilds = set ( to_snowflake ( guild [ \"id\" ]) for guild in data [ \"guilds\" ]) self . _user . _add_guilds ( expected_guilds ) while True : try : # wait to let guilds cache await asyncio . wait_for ( self . _guild_event . wait (), self . guild_event_timeout ) except asyncio . TimeoutError : log . warning ( \"Timeout waiting for guilds cache: Not all guilds will be in cache\" ) break self . _guild_event . clear () if len ( self . cache . guild_cache ) == len ( expected_guilds ): # all guilds cached break # cache slash commands await self . _init_interactions () self . _ready = True self . dispatch ( events . Ready ()) def start ( self , token ): \"\"\" Start the bot. info: This is the recommended method to start the bot Args: token str: Your bot's token \"\"\" try : self . loop . run_until_complete ( self . login ( token )) except KeyboardInterrupt : self . loop . run_until_complete ( self . stop ()) async def stop ( self ): log . debug ( \"Stopping the bot.\" ) self . _ready = False await self . ws . close ( 1001 ) def dispatch ( self , event : events . BaseEvent , * args , ** kwargs ): \"\"\" Dispatch an event. Args: event: The event to be dispatched. \"\"\" log . debug ( f \"Dispatching Event: { event . resolved_name } \" ) listeners = self . listeners . get ( event . resolved_name , []) for _listen in listeners : try : self . _queue_task ( _listen , event , * args , ** kwargs ) except Exception as e : raise BotException ( f \"An error occurred attempting during { event . resolved_name } event processing\" ) _waits = self . waits . get ( event . resolved_name , []) index_to_remove = [] for i , _wait in enumerate ( _waits ): result = _wait ( event ) if result : index_to_remove . append ( i ) for idx in index_to_remove : _waits . pop ( idx ) def wait_for ( self , event : str , checks : Optional [ Callable [ ... , bool ]] = MISSING , timeout : Optional [ float ] = None ): \"\"\" Waits for a WebSocket event to be dispatched. Args: event: The name of event to wait. checks: A predicate to check what to wait for. timeout: The number of seconds to wait before timing out. Returns: The event object. \"\"\" if event not in self . waits : self . waits [ event ] = [] future = self . loop . create_future () self . waits [ event ] . append ( Wait ( event , checks , future )) return asyncio . wait_for ( future , timeout ) async def wait_for_component ( self , messages : Union [ Message , int , list ] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , check = None , timeout = None , ) -> Awaitable [ \"Future\" ]: \"\"\" Waits for a message to be sent to the bot. Args: messages: The message object to check for. components: The components to wait for. check: A predicate to check what to wait for. timeout: The number of seconds to wait before timing out. Returns: `Component` that was invoked, or `None` if timed out. Use `.context` to get the `ComponentContext`. \"\"\" if not ( messages or components ): raise ValueError ( \"You must specify messages or components (or both)\" ) message_ids = ( to_snowflake_list ( messages ) if isinstance ( messages , list ) else to_snowflake ( messages ) if messages else None ) custom_ids = list ( get_components_ids ( components )) if components else None # automatically convert improper custom_ids if custom_ids and not all ( isinstance ( x , str ) for x in custom_ids ): custom_ids = [ str ( i ) for i in custom_ids ] def _check ( event : Component ): ctx : ComponentContext = event . context # if custom_ids is empty or there is a match wanted_message = not message_ids or ctx . message . id in ( [ message_ids ] if isinstance ( message_ids , int ) else message_ids ) wanted_component = not custom_ids or ctx . custom_id in custom_ids if wanted_message and wanted_component : if check is None or check ( event ): return True return False return False return await self . wait_for ( \"component\" , checks = _check , timeout = timeout ) def add_listener ( self , listener : Listener ): \"\"\" Add a listener for an event, if no event is passed, one is determined Args: coro Listener: The listener to add to the client \"\"\" if listener . event not in self . listeners : self . listeners [ listener . event ] = [] self . listeners [ listener . event ] . append ( listener ) def add_interaction ( self , command : InteractionCommand ): \"\"\" Add a slash command to the client. Args: command InteractionCommand: The command to add \"\"\" if self . debug_scope : command . scopes = [ self . debug_scope ] for scope in command . scopes : if scope not in self . interactions : self . interactions [ scope ] = {} elif command . resolved_name in self . interactions [ scope ]: old_cmd = self . interactions [ scope ][ command . resolved_name ] raise ValueError ( f \"Duplicate Command! { scope } :: { old_cmd . resolved_name } \" ) self . interactions [ scope ][ command . resolved_name ] = command def add_message_command ( self , command : MessageCommand ): \"\"\" Add a message command to the client. Args: command InteractionCommand: The command to add \"\"\" if command . name not in self . commands : self . commands [ command . name ] = command return raise ValueError ( f \"Duplicate Command! Multiple commands share the name ` { command . name } `\" ) def add_component_callback ( self , command : ComponentCommand ): \"\"\"Add a component callback to the client Args: command: The command to add \"\"\" for listener in command . listeners : # I know this isn't an ideal solution, but it means we can lookup callbacks with O(1) if listener not in self . _component_callbacks . keys (): self . _component_callbacks [ listener ] = command continue else : raise ValueError ( f \"Duplicate Component! Multiple component callbacks for ` { listener } `\" ) def _gather_commands ( self ): \"\"\"Gathers commands from __main__ and self\"\"\" def process ( _cmds ): for func in _cmds : if isinstance ( func , ComponentCommand ): self . add_component_callback ( func ) elif isinstance ( func , InteractionCommand ): self . add_interaction ( func ) elif isinstance ( func , MessageCommand ): self . add_message_command ( func ) elif isinstance ( func , Listener ): self . add_listener ( func ) log . debug ( f \" { len ( _cmds ) } commands have been loaded from `__main__` and `client`\" ) process ( [ obj for _ , obj in inspect . getmembers ( sys . modules [ \"__main__\" ]) if isinstance ( obj , ( BaseCommand , Listener ))] ) process ( [ wrap_partial ( obj , self ) for _ , obj in inspect . getmembers ( self ) if isinstance ( obj , ( BaseCommand , Listener ))] ) async def _init_interactions ( self ) -> None : \"\"\" Initialise slash commands. If `sync_interactions` this will submit all registered slash commands to discord. Otherwise, it will get the list of interactions and cache their scopes. \"\"\" # allow for cogs and main to share the same decorator try : if self . sync_interactions : await self . synchronise_interactions () else : await self . _cache_interactions ( warn_missing = True ) except Exception as e : await self . on_error ( \"Interaction Syncing\" , e ) async def _cache_interactions ( self , warn_missing : bool = False ): \"\"\"Get all interactions used by this bot and cache them.\"\"\" bot_scopes = set ( g . id for g in self . cache . guild_cache . values ()) bot_scopes . add ( GLOBAL_SCOPE ) # Match all interaction is registered with discord's data. for scope in self . interactions : bot_scopes . discard ( scope ) try : remote_cmds = await self . http . get_interaction_element ( self . user . id , scope ) except Forbidden as e : raise InteractionMissingAccess ( scope ) from None remote_cmds = { cmd_data [ \"name\" ]: cmd_data for cmd_data in remote_cmds } found = set () # this is a temporary hack to fix subcommand detection for cmd in self . interactions [ scope ] . values (): cmd_data = remote_cmds . get ( cmd . name , MISSING ) if cmd_data is MISSING : if cmd . name not in found : if warn_missing : log . error ( f 'Detected yet to sync slash command \"/ { cmd . name } \" for scope ' f \" { 'global' if scope == GLOBAL_SCOPE else scope } \" ) continue else : found . add ( cmd . name ) self . _interaction_scopes [ str ( cmd_data [ \"id\" ])] = scope cmd . cmd_id = str ( cmd_data [ \"id\" ]) if warn_missing : for cmd_data in remote_cmds . values (): log . error ( f \"Detected unimplemented slash command \\\" / { cmd_data [ 'name' ] } \\\" for scope \" f \" { 'global' if scope == GLOBAL_SCOPE else scope } \" ) # Remaining guilds that bot is in but, no interaction is registered for scope in bot_scopes : try : remote_cmds = await self . http . get_interaction_element ( self . user . id , scope ) except Forbidden : # We will just assume they don't want application commands in this guild. log . debug ( f \"Bot was not invited to guild { scope } with `application.commands` scope\" ) continue for cmd_data in remote_cmds : self . _interaction_scopes [ str ( cmd_data [ \"id\" ])] = scope if warn_missing : log . error ( f \"Detected unimplemented slash command \\\" / { cmd_data [ 'name' ] } \\\" for scope \" f \" { 'global' if scope == GLOBAL_SCOPE else scope } \" ) async def synchronise_interactions ( self ) -> None : \"\"\"Synchronise registered interactions with discord One flaw of this is it cant determine if context menus need updating, as discord isn't returning that data on get req, so they are unnecessarily updated\"\"\" # first we need to make sure our local copy of cmd_ids is up-to-date await self . _cache_interactions () cmd_scopes = [ to_snowflake ( g_id ) for g_id in self . _user . _guild_ids ] + [ GLOBAL_SCOPE ] guild_perms = {} cmds_json = application_commands_to_dict ( self . interactions ) for cmd_scope in cmd_scopes : try : cmds_resp_data = await self . http . get_interaction_element ( self . user . id , cmd_scope ) need_to_sync = False cmds_to_sync = [] found = [] for local_cmd in self . interactions . get ( cmd_scope , {}) . values (): # try and find remote equiv of this command remote_cmd = next (( v for v in cmds_resp_data if v [ \"id\" ] == local_cmd . cmd_id ), None ) local_cmd = next (( c for c in cmds_json [ cmd_scope ] if c [ \"name\" ] == local_cmd . name )) if local_cmd not in cmds_to_sync : cmds_to_sync . append ( local_cmd ) if remote_cmd not in found : found . append ( remote_cmd ) # todo: prevent un-needed syncs for subcommands if sync_needed ( local_cmd , remote_cmd ): # if command local data doesnt match remote, a change has been made, sync it need_to_sync = True if need_to_sync : log . info ( f \"Updating { len ( cmds_to_sync ) } commands in { cmd_scope } \" ) cmd_sync_resp = await self . http . post_interaction_element ( self . user . id , cmds_to_sync , guild_id = cmd_scope ) # cache cmd_ids and their scopes for cmd_data in cmd_sync_resp : self . _interaction_scopes [ cmd_data [ \"id\" ]] = cmd_scope if cmd_data [ \"name\" ] in self . interactions [ cmd_scope ]: self . interactions [ cmd_scope ][ cmd_data [ \"name\" ]] . cmd_id = str ( cmd_data [ \"id\" ]) else : # sub_cmd for sc in cmd_data [ \"options\" ]: if sc [ \"type\" ] == OptionTypes . SUB_COMMAND : if f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } \" in self . interactions [ cmd_scope ]: self . interactions [ cmd_scope ][ f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } \" ] . cmd_id = str ( cmd_data [ \"id\" ] ) elif sc [ \"type\" ] == OptionTypes . SUB_COMMAND_GROUP : for _sc in sc [ \"options\" ]: if ( f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } { _sc [ 'name' ] } \" in self . interactions [ cmd_scope ] ): self . interactions [ cmd_scope ][ f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } { _sc [ 'name' ] } \" ] . cmd_id = str ( cmd_data [ \"id\" ]) else : log . debug ( f \" { cmd_scope } is already up-to-date with { len ( cmds_resp_data ) } commands.\" ) for local_cmd in self . interactions . get ( cmd_scope , {}) . values (): if not local_cmd . permissions : continue for perm_scope , perms in local_cmd . permissions . items (): if perm_scope not in guild_perms : guild_perms [ perm_scope ] = [] guild_perms [ perm_scope ] . append ( { \"id\" : local_cmd . cmd_id , \"permissions\" : [ perm . to_dict () for perm in perms ]} ) for perm_scope in guild_perms : log . debug ( f \"Updating { len ( guild_perms [ perm_scope ]) } command permissions in { perm_scope } \" ) await self . http . batch_edit_application_command_permissions ( application_id = self . user . id , scope = perm_scope , data = guild_perms [ perm_scope ] ) if self . del_unused_app_cmd : for cmd in [ c for c in cmds_resp_data if c not in found ]: scope = cmd . get ( \"guild_id\" , GLOBAL_SCOPE ) log . warning ( f \"Deleting unimplemented slash command \\\" / { cmd [ 'name' ] } \\\" from scope \" f \" { 'global' if scope == GLOBAL_SCOPE else scope } \" ) await self . http . delete_interaction_element ( self . user . id , cmd . get ( \"guild_id\" , GLOBAL_SCOPE ), cmd [ \"id\" ] ) except Forbidden as e : raise InteractionMissingAccess ( cmd_scope ) from None async def get_context ( self , data : Union [ dict , Message ], interaction : bool = False ) -> Union [ MessageContext , InteractionContext , ComponentContext , AutocompleteContext ]: \"\"\" Return a context object based on data passed note: If you want to use custom context objects, this is the method to override. Your replacement must take the same arguments as this, and return a Context-like object. Args: data: The data of the event interaction: Is this an interaction or not? returns: Context object \"\"\" # this line shuts up IDE warnings cls : Union [ MessageContext , ComponentContext , InteractionContext , AutocompleteContext ] if interaction : # todo: change to match if data [ \"type\" ] == InteractionTypes . MESSAGE_COMPONENT : return ComponentContext . from_dict ( data , self ) elif data [ \"type\" ] == InteractionTypes . AUTOCOMPLETE : cls = AutocompleteContext . from_dict ( data , self ) else : cls = InteractionContext . from_dict ( data , self ) invoked_name : str = data [ \"data\" ][ \"name\" ] kwargs = {} if options := data [ \"data\" ] . get ( \"options\" ): o_type = options [ 0 ][ \"type\" ] if o_type in ( OptionTypes . SUB_COMMAND , OptionTypes . SUB_COMMAND_GROUP ): # this is a subcommand, process accordingly if o_type == OptionTypes . SUB_COMMAND : invoked_name = f \" { invoked_name } { options [ 0 ][ 'name' ] } \" options = options [ 0 ] . get ( \"options\" , []) else : invoked_name = ( f \" { invoked_name } { options [ 0 ][ 'name' ] } \" f \" { next ( x for x in options [ 0 ][ 'options' ] if x [ 'type' ] == OptionTypes . SUB_COMMAND )[ 'name' ] } \" ) options = options [ 0 ][ \"options\" ][ 0 ] . get ( \"options\" , []) for option in options : value = option . get ( \"value\" ) # todo change to match statement # this block here resolves the options using the cache if option [ \"type\" ] == OptionTypes . USER : value = ( self . cache . member_cache . get (( to_snowflake ( data . get ( \"guild_id\" , 0 )), to_snowflake ( value ))) or self . cache . user_cache . get ( to_snowflake ( value )) ) or value elif option [ \"type\" ] == OptionTypes . CHANNEL : value = self . cache . channel_cache . get ( to_snowflake ( value )) or value elif option [ \"type\" ] == OptionTypes . ROLE : value = self . cache . role_cache . get ( to_snowflake ( value )) or value elif option [ \"type\" ] == OptionTypes . MENTIONABLE : snow = to_snowflake ( value ) if user := self . cache . member_cache . get ( snow ) or self . cache . user_cache . get ( snow ): value = user elif role := self . cache . role_cache . get ( snow ): value = role if option . get ( \"focused\" , False ): cls . focussed_option = option . get ( \"name\" ) kwargs [ option [ \"name\" ] . lower ()] = value cls . invoked_name = invoked_name cls . kwargs = kwargs cls . args = [ v for v in kwargs . values ()] return cls else : return MessageContext . from_message ( self , data ) @listen ( \"raw_interaction_create\" ) async def _dispatch_interaction ( self , event : RawGatewayEvent ) -> None : \"\"\" Identify and dispatch interaction of slash commands or components. Args: raw interaction event \"\"\" interaction_data = event . data if interaction_data [ \"type\" ] in ( InteractionTypes . PING , InteractionTypes . APPLICATION_COMMAND , InteractionTypes . AUTOCOMPLETE , ): interaction_id = interaction_data [ \"data\" ][ \"id\" ] name = interaction_data [ \"data\" ][ \"name\" ] scope = self . _interaction_scopes . get ( str ( interaction_id )) if scope in self . interactions : ctx = await self . get_context ( interaction_data , True ) command : SlashCommand = self . interactions [ scope ][ ctx . invoked_name ] # type: ignore log . debug ( f \" { scope } :: { command . name } should be called\" ) if auto_opt := getattr ( ctx , \"focussed_option\" , None ): await command . autocomplete_callbacks [ auto_opt ]( ctx , ** ctx . kwargs ) else : try : await command ( ctx , ** ctx . kwargs ) except Exception as e : await self . on_command_error ( f \"cmd /` { name } `\" , e ) finally : await self . on_command ( ctx ) else : log . error ( f \"Unknown cmd_id received:: { interaction_id } ( { name } )\" ) elif interaction_data [ \"type\" ] == InteractionTypes . MESSAGE_COMPONENT : # Buttons, Selects, ContextMenu::Message ctx = await self . get_context ( interaction_data , True ) component_type = interaction_data [ \"data\" ][ \"component_type\" ] self . dispatch ( events . Component ( ctx )) if callback := self . _component_callbacks . get ( ctx . custom_id ): try : await callback ( ctx ) except Exception as e : await self . on_command_error ( f \"Component Callback for { ctx . custom_id } \" , e ) finally : await self . on_command ( ctx ) if component_type == ComponentTypes . BUTTON : self . dispatch ( events . Button ( ctx )) if component_type == ComponentTypes . SELECT : self . dispatch ( events . Select ( ctx )) else : raise NotImplementedError ( f \"Unknown Interaction Received: { interaction_data [ 'type' ] } \" ) @listen ( \"message_create\" ) async def _dispatch_msg_commands ( self , event : MessageCreate ): \"\"\"Determine if a command is being triggered, and dispatch it.\"\"\" message = event . message if not message . author . bot : prefix = await self . get_prefix ( message ) if prefix == MENTION_PREFIX : mention = self . _mention_reg . search ( message . content ) if mention : prefix = mention . group () else : return if message . content . startswith ( prefix ): invoked_name = get_first_word ( message . content . removeprefix ( prefix )) command = self . commands . get ( invoked_name ) if command and command . enabled : context = await self . get_context ( message ) context . invoked_name = invoked_name context . prefix = prefix context . args = get_args ( context . content_parameters ) try : await command ( context ) except Exception as e : await self . on_command_error ( f \"cmd ` { invoked_name } `\" , e ) finally : await self . on_command ( context ) def get_scale ( self , name ) -> Optional [ Scale ]: \"\"\" Get a scale Args: name: The name of the scale, or the name of it's extension Returns: Scale or None if no scale is found \"\"\" if name not in self . scales . keys (): for scale in self . scales . values (): if scale . extension_name == name : return scale return self . scales . get ( name , None ) def grow_scale ( self , file_name : str , package : str = None ) -> None : \"\"\" A helper method to load a scale Args: file_name: The name of the file to load the scale from. package: The package this scale is in. \"\"\" self . load_extension ( file_name , package ) def shed_scale ( self , scale_name : str ) -> None : \"\"\" Helper method to unload a scale Args: scale_name: The name of the scale to unload. \"\"\" if scale := self . get_scale ( scale_name ): return self . unload_extension ( inspect . getmodule ( scale ) . __name__ ) raise ScaleLoadException ( f \"Unable to shed scale: No scale exists with name: ` { scale_name } `\" ) def regrow_scale ( self , scale_name : str ) -> None : \"\"\" Helper method to reload a scale. Args: scale_name: The name of the scale to reload \"\"\" self . shed_scale ( scale_name ) self . grow_scale ( scale_name ) def load_extension ( self , name : str , package : str = None ): \"\"\" Load an extension. Args: name: The name of the extension. package: The package the extension is in \"\"\" name = importlib . util . resolve_name ( name , package ) if name in self . __extensions : raise Exception ( f \" { name } already loaded\" ) module = importlib . import_module ( name , package ) try : setup = getattr ( module , \"setup\" ) setup ( self ) except Exception as e : del sys . modules [ name ] raise ExtensionLoadException ( f \"Error loading { name } \" ) from e else : log . debug ( f \"Loaded Extension: { name } \" ) self . __extensions [ name ] = module return def unload_extension ( self , name , package = None ): \"\"\" unload an extension. Args: name: The name of the extension. package: The package the extension is in \"\"\" name = importlib . util . resolve_name ( name , package ) module = self . __extensions . get ( name ) if module is None : raise ExtensionNotFound ( f \"No extension called { name } is loaded\" ) try : teardown = getattr ( module , \"teardown\" ) teardown () except AttributeError : pass if scale := self . get_scale ( name ): scale . shed () del sys . modules [ name ] del self . __extensions [ name ] def reload_extension ( self , name , package = None ): \"\"\" Helper method to reload an extension. Simply unloads, then loads the extension. Args: name: The name of the extension. package: The package the extension is in \"\"\" name = importlib . util . resolve_name ( name , package ) module = self . __extensions . get ( name ) if module is None : log . warning ( \"Attempted to reload extension thats not loaded. Loading extension instead\" ) return self . load_extension ( name , package ) self . unload_extension ( name , package ) self . load_extension ( name , package ) # todo: maybe add an ability to revert to the previous version if unable to load the new one async def get_guild ( self , guild_id : \"Snowflake_Type\" ) -> Guild : \"\"\" Get a guild Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: guild_id: The ID of the guild to get Returns: Guild Object \"\"\" return await self . cache . get_guild ( guild_id ) async def get_channel ( self , channel_id : \"Snowflake_Type\" ) -> \"TYPE_ALL_CHANNEL\" : \"\"\" Get a channel Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: channel_id: The ID of the channel to get Returns: Channel Object \"\"\" return await self . cache . get_channel ( channel_id ) async def get_user ( self , user_id : \"Snowflake_Type\" ) -> User : \"\"\" Get a user Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: user_id: The ID of the user to get Returns: User Object \"\"\" return await self . cache . get_user ( user_id ) async def get_member ( self , user_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" ) -> Member : \"\"\" Get a member from a guild Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: user_id: The ID of the member guild_id: The ID of the guild to get the member from Returns: Member object \"\"\" return await self . cache . get_member ( guild_id , user_id ) async def get_sticker ( self , sticker_id : \"Snowflake_Type\" ): sticker_data = await self . http . get_sticker ( sticker_id ) return Sticker . from_dict ( sticker_data , self ) async def get_nitro_packs ( self ) -> List [ \"StickerPack\" ]: packs_data = await self . http . list_nitro_sticker_packs () packs = [] for pack_data in packs_data : packs . append ( StickerPack . from_dict ( pack_data , self )) return packs async def change_presence ( self , status : Optional [ Union [ str , Status ]] = Status . ONLINE , activity : Optional [ Union [ Activity , str ]] = None ): \"\"\" Change the bots presence. Args: status: The status for the bot to be. i.e. online, afk, etc. activity: The activity for the bot to be displayed as doing. note:: Bots may only be `playing` `streaming` or `listening`, other activity types are likely to fail. \"\"\" if activity : if not isinstance ( activity , Activity ): # squash whatever the user passed into an activity activity = Activity . create ( name = str ( activity )) if activity . type == ActivityType . STREAMING : if not activity . url : log . warning ( \"Streaming activity cannot be set without a valid URL attribute\" ) elif activity . type not in [ ActivityType . GAME , ActivityType . STREAMING , ActivityType . LISTENING ]: log . warning ( f \"Activity type ` { ActivityType ( activity . type ) . name } ` may not be enabled for bots\" ) else : activity = self . _activity if self . _activity else [] if status : if not isinstance ( status , Status ): try : status = Status [ status . upper ()] except KeyError : raise ValueError ( f \"` { status } ` is not a valid status type. Please use the Status enum\" ) from None else : # in case the user set status to None if self . _status : status = self . _status else : log . warning ( \"Status must be set to a valid status type, defaulting to online\" ) status = Status . ONLINE self . _status = status self . _activity = activity await self . ws . change_presence ( activity . to_dict () if activity else None , status ) property readonly is_closed : bool \u00b6 Is the bot closed? property readonly latency : float \u00b6 Returns the latency of the websocket connection property readonly user : SnakeBotUser \u00b6 Returns the bot's user property readonly app : Application \u00b6 Returns the bots application property readonly owner : Optional [ User ] \u00b6 Returns the bot's owner' property readonly status : Status \u00b6 Get the status of the bot. IE online, afk, dnd property readonly activity : Activity \u00b6 Get the activity of the bot property readonly application_commands \u00b6 a list of all application commands registered within the bot async get_prefix ( self , message ) \u00b6 A method to get the bot's default_prefix, can be overridden to add dynamic prefixes. Note To easily override this method, simply use the get_prefix parameter when instantiating the client Parameters: Name Type Description Default message Message A message to determine the prefix from. required Returns: Type Description str A string to use as a prefix, by default will return client.default_prefix Source code in dis_snek/client.py async def get_prefix ( self , message : Message ) -> str : \"\"\"A method to get the bot's default_prefix, can be overridden to add dynamic prefixes. !!! note To easily override this method, simply use the `get_prefix` parameter when instantiating the client Args: message: A message to determine the prefix from. Returns: A string to use as a prefix, by default will return `client.default_prefix` \"\"\" return self . default_prefix async login ( self , token ) \u00b6 Login to discord Parameters: Name Type Description Default token str Your bot's token required Source code in dis_snek/client.py async def login ( self , token ): \"\"\" Login to discord Args: token str: Your bot's token \"\"\" # i needed somewhere to put this call, # login will always run after initialisation # so im gathering commands here self . _gather_commands () log . debug ( f \"Attempting to login\" ) me = await self . http . login ( token . strip ()) self . _user = SnakeBotUser . from_dict ( me , self ) self . cache . place_user_data ( me ) self . _app = Application . from_dict ( await self . http . get_current_bot_information (), self ) self . _mention_reg = re . compile ( fr \"^(<@!? { self . user . id } *>\\s)\" ) self . start_time = datetime . datetime . now () self . dispatch ( events . Login ()) await self . _ws_connect () async on_error ( self , source , error , * args , ** kwargs ) \u00b6 Catches all errors dispatched by the library. By default it will format and print them to console Override this to change error handling behaviour Source code in dis_snek/client.py async def on_error ( self , source : str , error : Exception , * args , ** kwargs ) -> None : \"\"\" Catches all errors dispatched by the library. By default it will format and print them to console Override this to change error handling behaviour \"\"\" print ( f \"Ignoring exception in { source } : \\n { traceback . format_exc () } \" , file = sys . stderr ) async on_command_error ( self , source , error , * args , ** kwargs ) \u00b6 Catches all errors dispatched by commands By default it will call Snake.on_error Override this to change error handling behavior Source code in dis_snek/client.py async def on_command_error ( self , source : str , error : Exception , * args , ** kwargs ) -> None : \"\"\" Catches all errors dispatched by commands By default it will call `Snake.on_error` Override this to change error handling behavior \"\"\" return await self . on_error ( source , error , * args , ** kwargs ) async on_command ( self , ctx ) \u00b6 Called after any command is ran By default, it will simply log the command, override this to change that behaviour Parameters: Name Type Description Default ctx Context The context of the command that was called required Source code in dis_snek/client.py async def on_command ( self , ctx : Context ) -> None : \"\"\" Called *after* any command is ran By default, it will simply log the command, override this to change that behaviour Args: ctx: The context of the command that was called \"\"\" if isinstance ( ctx , MessageContext ): symbol = \"@\" elif isinstance ( ctx , ComponentContext ): symbol = \"\u00a2\" elif isinstance ( ctx , InteractionContext ): symbol = \"/\" else : symbol = \"?\" # likely custom context log . info ( f \"Command Called: { symbol }{ ctx . invoked_name } with { ctx . args = } | { ctx . kwargs = } \" ) start ( self , token ) \u00b6 Start the bot. Info This is the recommended method to start the bot Parameters: Name Type Description Default token str Your bot's token required Source code in dis_snek/client.py def start ( self , token ): \"\"\" Start the bot. info: This is the recommended method to start the bot Args: token str: Your bot's token \"\"\" try : self . loop . run_until_complete ( self . login ( token )) except KeyboardInterrupt : self . loop . run_until_complete ( self . stop ()) dispatch ( self , event , * args , ** kwargs ) \u00b6 Dispatch an event. Parameters: Name Type Description Default event BaseEvent The event to be dispatched. required Source code in dis_snek/client.py def dispatch ( self , event : events . BaseEvent , * args , ** kwargs ): \"\"\" Dispatch an event. Args: event: The event to be dispatched. \"\"\" log . debug ( f \"Dispatching Event: { event . resolved_name } \" ) listeners = self . listeners . get ( event . resolved_name , []) for _listen in listeners : try : self . _queue_task ( _listen , event , * args , ** kwargs ) except Exception as e : raise BotException ( f \"An error occurred attempting during { event . resolved_name } event processing\" ) _waits = self . waits . get ( event . resolved_name , []) index_to_remove = [] for i , _wait in enumerate ( _waits ): result = _wait ( event ) if result : index_to_remove . append ( i ) for idx in index_to_remove : _waits . pop ( idx ) wait_for ( self , event , checks = MISSING , timeout = None ) \u00b6 Waits for a WebSocket event to be dispatched. Parameters: Name Type Description Default event str The name of event to wait. required checks Optional[Callable[..., bool]] A predicate to check what to wait for. MISSING timeout Optional[float] The number of seconds to wait before timing out. None Returns: Type Description The event object. Source code in dis_snek/client.py def wait_for ( self , event : str , checks : Optional [ Callable [ ... , bool ]] = MISSING , timeout : Optional [ float ] = None ): \"\"\" Waits for a WebSocket event to be dispatched. Args: event: The name of event to wait. checks: A predicate to check what to wait for. timeout: The number of seconds to wait before timing out. Returns: The event object. \"\"\" if event not in self . waits : self . waits [ event ] = [] future = self . loop . create_future () self . waits [ event ] . append ( Wait ( event , checks , future )) return asyncio . wait_for ( future , timeout ) async wait_for_component ( self , messages = None , components = None , check = None , timeout = None ) \u00b6 Waits for a message to be sent to the bot. Parameters: Name Type Description Default messages Union[dis_snek.models.discord_objects.message.Message, int, list] The message object to check for. None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to wait for. None check A predicate to check what to wait for. None timeout The number of seconds to wait before timing out. None Returns: Type Description Awaitable[Future] Component that was invoked, or None if timed out. Use .context to get the ComponentContext . Source code in dis_snek/client.py async def wait_for_component ( self , messages : Union [ Message , int , list ] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , check = None , timeout = None , ) -> Awaitable [ \"Future\" ]: \"\"\" Waits for a message to be sent to the bot. Args: messages: The message object to check for. components: The components to wait for. check: A predicate to check what to wait for. timeout: The number of seconds to wait before timing out. Returns: `Component` that was invoked, or `None` if timed out. Use `.context` to get the `ComponentContext`. \"\"\" if not ( messages or components ): raise ValueError ( \"You must specify messages or components (or both)\" ) message_ids = ( to_snowflake_list ( messages ) if isinstance ( messages , list ) else to_snowflake ( messages ) if messages else None ) custom_ids = list ( get_components_ids ( components )) if components else None # automatically convert improper custom_ids if custom_ids and not all ( isinstance ( x , str ) for x in custom_ids ): custom_ids = [ str ( i ) for i in custom_ids ] def _check ( event : Component ): ctx : ComponentContext = event . context # if custom_ids is empty or there is a match wanted_message = not message_ids or ctx . message . id in ( [ message_ids ] if isinstance ( message_ids , int ) else message_ids ) wanted_component = not custom_ids or ctx . custom_id in custom_ids if wanted_message and wanted_component : if check is None or check ( event ): return True return False return False return await self . wait_for ( \"component\" , checks = _check , timeout = timeout ) add_listener ( self , listener ) \u00b6 Add a listener for an event, if no event is passed, one is determined Parameters: Name Type Description Default coro Listener The listener to add to the client required Source code in dis_snek/client.py def add_listener ( self , listener : Listener ): \"\"\" Add a listener for an event, if no event is passed, one is determined Args: coro Listener: The listener to add to the client \"\"\" if listener . event not in self . listeners : self . listeners [ listener . event ] = [] self . listeners [ listener . event ] . append ( listener ) add_interaction ( self , command ) \u00b6 Add a slash command to the client. Parameters: Name Type Description Default command InteractionCommand The command to add required Source code in dis_snek/client.py def add_interaction ( self , command : InteractionCommand ): \"\"\" Add a slash command to the client. Args: command InteractionCommand: The command to add \"\"\" if self . debug_scope : command . scopes = [ self . debug_scope ] for scope in command . scopes : if scope not in self . interactions : self . interactions [ scope ] = {} elif command . resolved_name in self . interactions [ scope ]: old_cmd = self . interactions [ scope ][ command . resolved_name ] raise ValueError ( f \"Duplicate Command! { scope } :: { old_cmd . resolved_name } \" ) self . interactions [ scope ][ command . resolved_name ] = command add_message_command ( self , command ) \u00b6 Add a message command to the client. Parameters: Name Type Description Default command InteractionCommand The command to add required Source code in dis_snek/client.py def add_message_command ( self , command : MessageCommand ): \"\"\" Add a message command to the client. Args: command InteractionCommand: The command to add \"\"\" if command . name not in self . commands : self . commands [ command . name ] = command return raise ValueError ( f \"Duplicate Command! Multiple commands share the name ` { command . name } `\" ) add_component_callback ( self , command ) \u00b6 Add a component callback to the client Parameters: Name Type Description Default command ComponentCommand The command to add required Source code in dis_snek/client.py def add_component_callback ( self , command : ComponentCommand ): \"\"\"Add a component callback to the client Args: command: The command to add \"\"\" for listener in command . listeners : # I know this isn't an ideal solution, but it means we can lookup callbacks with O(1) if listener not in self . _component_callbacks . keys (): self . _component_callbacks [ listener ] = command continue else : raise ValueError ( f \"Duplicate Component! Multiple component callbacks for ` { listener } `\" ) async synchronise_interactions ( self ) \u00b6 Synchronise registered interactions with discord One flaw of this is it cant determine if context menus need updating, as discord isn't returning that data on get req, so they are unnecessarily updated Source code in dis_snek/client.py async def synchronise_interactions ( self ) -> None : \"\"\"Synchronise registered interactions with discord One flaw of this is it cant determine if context menus need updating, as discord isn't returning that data on get req, so they are unnecessarily updated\"\"\" # first we need to make sure our local copy of cmd_ids is up-to-date await self . _cache_interactions () cmd_scopes = [ to_snowflake ( g_id ) for g_id in self . _user . _guild_ids ] + [ GLOBAL_SCOPE ] guild_perms = {} cmds_json = application_commands_to_dict ( self . interactions ) for cmd_scope in cmd_scopes : try : cmds_resp_data = await self . http . get_interaction_element ( self . user . id , cmd_scope ) need_to_sync = False cmds_to_sync = [] found = [] for local_cmd in self . interactions . get ( cmd_scope , {}) . values (): # try and find remote equiv of this command remote_cmd = next (( v for v in cmds_resp_data if v [ \"id\" ] == local_cmd . cmd_id ), None ) local_cmd = next (( c for c in cmds_json [ cmd_scope ] if c [ \"name\" ] == local_cmd . name )) if local_cmd not in cmds_to_sync : cmds_to_sync . append ( local_cmd ) if remote_cmd not in found : found . append ( remote_cmd ) # todo: prevent un-needed syncs for subcommands if sync_needed ( local_cmd , remote_cmd ): # if command local data doesnt match remote, a change has been made, sync it need_to_sync = True if need_to_sync : log . info ( f \"Updating { len ( cmds_to_sync ) } commands in { cmd_scope } \" ) cmd_sync_resp = await self . http . post_interaction_element ( self . user . id , cmds_to_sync , guild_id = cmd_scope ) # cache cmd_ids and their scopes for cmd_data in cmd_sync_resp : self . _interaction_scopes [ cmd_data [ \"id\" ]] = cmd_scope if cmd_data [ \"name\" ] in self . interactions [ cmd_scope ]: self . interactions [ cmd_scope ][ cmd_data [ \"name\" ]] . cmd_id = str ( cmd_data [ \"id\" ]) else : # sub_cmd for sc in cmd_data [ \"options\" ]: if sc [ \"type\" ] == OptionTypes . SUB_COMMAND : if f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } \" in self . interactions [ cmd_scope ]: self . interactions [ cmd_scope ][ f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } \" ] . cmd_id = str ( cmd_data [ \"id\" ] ) elif sc [ \"type\" ] == OptionTypes . SUB_COMMAND_GROUP : for _sc in sc [ \"options\" ]: if ( f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } { _sc [ 'name' ] } \" in self . interactions [ cmd_scope ] ): self . interactions [ cmd_scope ][ f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } { _sc [ 'name' ] } \" ] . cmd_id = str ( cmd_data [ \"id\" ]) else : log . debug ( f \" { cmd_scope } is already up-to-date with { len ( cmds_resp_data ) } commands.\" ) for local_cmd in self . interactions . get ( cmd_scope , {}) . values (): if not local_cmd . permissions : continue for perm_scope , perms in local_cmd . permissions . items (): if perm_scope not in guild_perms : guild_perms [ perm_scope ] = [] guild_perms [ perm_scope ] . append ( { \"id\" : local_cmd . cmd_id , \"permissions\" : [ perm . to_dict () for perm in perms ]} ) for perm_scope in guild_perms : log . debug ( f \"Updating { len ( guild_perms [ perm_scope ]) } command permissions in { perm_scope } \" ) await self . http . batch_edit_application_command_permissions ( application_id = self . user . id , scope = perm_scope , data = guild_perms [ perm_scope ] ) if self . del_unused_app_cmd : for cmd in [ c for c in cmds_resp_data if c not in found ]: scope = cmd . get ( \"guild_id\" , GLOBAL_SCOPE ) log . warning ( f \"Deleting unimplemented slash command \\\" / { cmd [ 'name' ] } \\\" from scope \" f \" { 'global' if scope == GLOBAL_SCOPE else scope } \" ) await self . http . delete_interaction_element ( self . user . id , cmd . get ( \"guild_id\" , GLOBAL_SCOPE ), cmd [ \"id\" ] ) except Forbidden as e : raise InteractionMissingAccess ( cmd_scope ) from None async get_context ( self , data , interaction = False ) \u00b6 Return a context object based on data passed Note If you want to use custom context objects, this is the method to override. Your replacement must take the same arguments as this, and return a Context-like object. Parameters: Name Type Description Default data Union[dict, dis_snek.models.discord_objects.message.Message] The data of the event required interaction bool Is this an interaction or not? False Returns: Type Description Union[dis_snek.models.context.MessageContext, dis_snek.models.context.InteractionContext, dis_snek.models.context.ComponentContext, dis_snek.models.context.AutocompleteContext] Context object Source code in dis_snek/client.py async def get_context ( self , data : Union [ dict , Message ], interaction : bool = False ) -> Union [ MessageContext , InteractionContext , ComponentContext , AutocompleteContext ]: \"\"\" Return a context object based on data passed note: If you want to use custom context objects, this is the method to override. Your replacement must take the same arguments as this, and return a Context-like object. Args: data: The data of the event interaction: Is this an interaction or not? returns: Context object \"\"\" # this line shuts up IDE warnings cls : Union [ MessageContext , ComponentContext , InteractionContext , AutocompleteContext ] if interaction : # todo: change to match if data [ \"type\" ] == InteractionTypes . MESSAGE_COMPONENT : return ComponentContext . from_dict ( data , self ) elif data [ \"type\" ] == InteractionTypes . AUTOCOMPLETE : cls = AutocompleteContext . from_dict ( data , self ) else : cls = InteractionContext . from_dict ( data , self ) invoked_name : str = data [ \"data\" ][ \"name\" ] kwargs = {} if options := data [ \"data\" ] . get ( \"options\" ): o_type = options [ 0 ][ \"type\" ] if o_type in ( OptionTypes . SUB_COMMAND , OptionTypes . SUB_COMMAND_GROUP ): # this is a subcommand, process accordingly if o_type == OptionTypes . SUB_COMMAND : invoked_name = f \" { invoked_name } { options [ 0 ][ 'name' ] } \" options = options [ 0 ] . get ( \"options\" , []) else : invoked_name = ( f \" { invoked_name } { options [ 0 ][ 'name' ] } \" f \" { next ( x for x in options [ 0 ][ 'options' ] if x [ 'type' ] == OptionTypes . SUB_COMMAND )[ 'name' ] } \" ) options = options [ 0 ][ \"options\" ][ 0 ] . get ( \"options\" , []) for option in options : value = option . get ( \"value\" ) # todo change to match statement # this block here resolves the options using the cache if option [ \"type\" ] == OptionTypes . USER : value = ( self . cache . member_cache . get (( to_snowflake ( data . get ( \"guild_id\" , 0 )), to_snowflake ( value ))) or self . cache . user_cache . get ( to_snowflake ( value )) ) or value elif option [ \"type\" ] == OptionTypes . CHANNEL : value = self . cache . channel_cache . get ( to_snowflake ( value )) or value elif option [ \"type\" ] == OptionTypes . ROLE : value = self . cache . role_cache . get ( to_snowflake ( value )) or value elif option [ \"type\" ] == OptionTypes . MENTIONABLE : snow = to_snowflake ( value ) if user := self . cache . member_cache . get ( snow ) or self . cache . user_cache . get ( snow ): value = user elif role := self . cache . role_cache . get ( snow ): value = role if option . get ( \"focused\" , False ): cls . focussed_option = option . get ( \"name\" ) kwargs [ option [ \"name\" ] . lower ()] = value cls . invoked_name = invoked_name cls . kwargs = kwargs cls . args = [ v for v in kwargs . values ()] return cls else : return MessageContext . from_message ( self , data ) get_scale ( self , name ) \u00b6 Get a scale Parameters: Name Type Description Default name The name of the scale, or the name of it's extension required Returns: Type Description Optional[dis_snek.models.scale.Scale] Scale or None if no scale is found Source code in dis_snek/client.py def get_scale ( self , name ) -> Optional [ Scale ]: \"\"\" Get a scale Args: name: The name of the scale, or the name of it's extension Returns: Scale or None if no scale is found \"\"\" if name not in self . scales . keys (): for scale in self . scales . values (): if scale . extension_name == name : return scale return self . scales . get ( name , None ) grow_scale ( self , file_name , package = None ) \u00b6 A helper method to load a scale Parameters: Name Type Description Default file_name str The name of the file to load the scale from. required package str The package this scale is in. None Source code in dis_snek/client.py def grow_scale ( self , file_name : str , package : str = None ) -> None : \"\"\" A helper method to load a scale Args: file_name: The name of the file to load the scale from. package: The package this scale is in. \"\"\" self . load_extension ( file_name , package ) shed_scale ( self , scale_name ) \u00b6 Helper method to unload a scale Parameters: Name Type Description Default scale_name str The name of the scale to unload. required Source code in dis_snek/client.py def shed_scale ( self , scale_name : str ) -> None : \"\"\" Helper method to unload a scale Args: scale_name: The name of the scale to unload. \"\"\" if scale := self . get_scale ( scale_name ): return self . unload_extension ( inspect . getmodule ( scale ) . __name__ ) raise ScaleLoadException ( f \"Unable to shed scale: No scale exists with name: ` { scale_name } `\" ) regrow_scale ( self , scale_name ) \u00b6 Helper method to reload a scale. Parameters: Name Type Description Default scale_name str The name of the scale to reload required Source code in dis_snek/client.py def regrow_scale ( self , scale_name : str ) -> None : \"\"\" Helper method to reload a scale. Args: scale_name: The name of the scale to reload \"\"\" self . shed_scale ( scale_name ) self . grow_scale ( scale_name ) load_extension ( self , name , package = None ) \u00b6 Load an extension. Parameters: Name Type Description Default name str The name of the extension. required package str The package the extension is in None Source code in dis_snek/client.py def load_extension ( self , name : str , package : str = None ): \"\"\" Load an extension. Args: name: The name of the extension. package: The package the extension is in \"\"\" name = importlib . util . resolve_name ( name , package ) if name in self . __extensions : raise Exception ( f \" { name } already loaded\" ) module = importlib . import_module ( name , package ) try : setup = getattr ( module , \"setup\" ) setup ( self ) except Exception as e : del sys . modules [ name ] raise ExtensionLoadException ( f \"Error loading { name } \" ) from e else : log . debug ( f \"Loaded Extension: { name } \" ) self . __extensions [ name ] = module return unload_extension ( self , name , package = None ) \u00b6 unload an extension. Parameters: Name Type Description Default name The name of the extension. required package The package the extension is in None Source code in dis_snek/client.py def unload_extension ( self , name , package = None ): \"\"\" unload an extension. Args: name: The name of the extension. package: The package the extension is in \"\"\" name = importlib . util . resolve_name ( name , package ) module = self . __extensions . get ( name ) if module is None : raise ExtensionNotFound ( f \"No extension called { name } is loaded\" ) try : teardown = getattr ( module , \"teardown\" ) teardown () except AttributeError : pass if scale := self . get_scale ( name ): scale . shed () del sys . modules [ name ] del self . __extensions [ name ] reload_extension ( self , name , package = None ) \u00b6 Helper method to reload an extension. Simply unloads, then loads the extension. Parameters: Name Type Description Default name The name of the extension. required package The package the extension is in None Source code in dis_snek/client.py def reload_extension ( self , name , package = None ): \"\"\" Helper method to reload an extension. Simply unloads, then loads the extension. Args: name: The name of the extension. package: The package the extension is in \"\"\" name = importlib . util . resolve_name ( name , package ) module = self . __extensions . get ( name ) if module is None : log . warning ( \"Attempted to reload extension thats not loaded. Loading extension instead\" ) return self . load_extension ( name , package ) self . unload_extension ( name , package ) self . load_extension ( name , package ) # todo: maybe add an ability to revert to the previous version if unable to load the new one async get_guild ( self , guild_id ) \u00b6 Get a guild Note This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to get required Returns: Type Description Guild Guild Object Source code in dis_snek/client.py async def get_guild ( self , guild_id : \"Snowflake_Type\" ) -> Guild : \"\"\" Get a guild Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: guild_id: The ID of the guild to get Returns: Guild Object \"\"\" return await self . cache . get_guild ( guild_id ) async get_channel ( self , channel_id ) \u00b6 Get a channel Note This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to get required Returns: Type Description TYPE_ALL_CHANNEL Channel Object Source code in dis_snek/client.py async def get_channel ( self , channel_id : \"Snowflake_Type\" ) -> \"TYPE_ALL_CHANNEL\" : \"\"\" Get a channel Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: channel_id: The ID of the channel to get Returns: Channel Object \"\"\" return await self . cache . get_channel ( channel_id ) async get_user ( self , user_id ) \u00b6 Get a user Note This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Parameters: Name Type Description Default user_id Snowflake_Type The ID of the user to get required Returns: Type Description User User Object Source code in dis_snek/client.py async def get_user ( self , user_id : \"Snowflake_Type\" ) -> User : \"\"\" Get a user Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: user_id: The ID of the user to get Returns: User Object \"\"\" return await self . cache . get_user ( user_id ) async get_member ( self , user_id , guild_id ) \u00b6 Get a member from a guild Note This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Parameters: Name Type Description Default user_id Snowflake_Type The ID of the member required guild_id Snowflake_Type The ID of the guild to get the member from required Returns: Type Description Member Member object Source code in dis_snek/client.py async def get_member ( self , user_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" ) -> Member : \"\"\" Get a member from a guild Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: user_id: The ID of the member guild_id: The ID of the guild to get the member from Returns: Member object \"\"\" return await self . cache . get_member ( guild_id , user_id ) async change_presence ( self , status =< Status . ONLINE : 'online' > , activity = None ) \u00b6 Change the bots presence. Parameters: Name Type Description Default status Union[str, dis_snek.models.enums.Status] The status for the bot to be. i.e. online, afk, etc. <Status.ONLINE: 'online'> activity Union[dis_snek.models.discord_objects.activity.Activity, str] The activity for the bot to be displayed as doing. None note:: Bots may only be playing streaming or listening , other activity types are likely to fail. Source code in dis_snek/client.py async def change_presence ( self , status : Optional [ Union [ str , Status ]] = Status . ONLINE , activity : Optional [ Union [ Activity , str ]] = None ): \"\"\" Change the bots presence. Args: status: The status for the bot to be. i.e. online, afk, etc. activity: The activity for the bot to be displayed as doing. note:: Bots may only be `playing` `streaming` or `listening`, other activity types are likely to fail. \"\"\" if activity : if not isinstance ( activity , Activity ): # squash whatever the user passed into an activity activity = Activity . create ( name = str ( activity )) if activity . type == ActivityType . STREAMING : if not activity . url : log . warning ( \"Streaming activity cannot be set without a valid URL attribute\" ) elif activity . type not in [ ActivityType . GAME , ActivityType . STREAMING , ActivityType . LISTENING ]: log . warning ( f \"Activity type ` { ActivityType ( activity . type ) . name } ` may not be enabled for bots\" ) else : activity = self . _activity if self . _activity else [] if status : if not isinstance ( status , Status ): try : status = Status [ status . upper ()] except KeyError : raise ValueError ( f \"` { status } ` is not a valid status type. Please use the Status enum\" ) from None else : # in case the user set status to None if self . _status : status = self . _status else : log . warning ( \"Status must be set to a valid status type, defaulting to online\" ) status = Status . ONLINE self . _status = status self . _activity = activity await self . ws . change_presence ( activity . to_dict () if activity else None , status )","title":"Client"},{"location":"API%20Reference/client/#dis_snek.client.Snake","text":"The bot client. Note By default, all non-privileged intents will be enabled Attributes: Name Type Description intents Union[int, Intents] The intents to use loop asyncio.AbstractEventLoop An event loop to use, normally leave this blank default_prefix str The default_prefix to use for message commands, defaults to your bot being mentioned get_prefix Callable[..., Coroutine] A coroutine that returns a string to determine prefixes sync_interactions bool Should application commands be synced with discord? delete_unused_application_cmds bool Delete any commands from discord that arent implemented in this client asyncio_debug bool Enable asyncio debug features status Status The status the bot should login with (IE ONLINE, DND, IDLE) activity Activity The activity the bot should login \"playing\" Optionally, you can configure the caches here, by specifying the name of the cache, followed by a dict-style object to use. It is recommended to use smart_cache.create_cache to configure the cache here. as an example, this is a recommended attribute message_cache=create_cache(250, 50) , Note Setting a message cache hard limit to None is not recommended, as it could result in extremely high memory usage, we suggest a sane limit. Source code in dis_snek/client.py class Snake ( ChannelEvents , GuildEvents , MemberEvents , MessageEvents , ReactionEvents , RoleEvents , StageEvents , ThreadEvents , UserEvents , ): \"\"\" The bot client. note: By default, all non-privileged intents will be enabled Attributes: intents Union[int, Intents]: The intents to use loop: An event loop to use, normally leave this blank default_prefix str: The default_prefix to use for message commands, defaults to your bot being mentioned get_prefix Callable[..., Coroutine]: A coroutine that returns a string to determine prefixes sync_interactions bool: Should application commands be synced with discord? delete_unused_application_cmds bool: Delete any commands from discord that arent implemented in this client asyncio_debug bool: Enable asyncio debug features status Status: The status the bot should login with (IE ONLINE, DND, IDLE) activity Activity: The activity the bot should login \"playing\" Optionally, you can configure the caches here, by specifying the name of the cache, followed by a dict-style object to use. It is recommended to use `smart_cache.create_cache` to configure the cache here. as an example, this is a recommended attribute `message_cache=create_cache(250, 50)`, !!! note Setting a message cache hard limit to None is not recommended, as it could result in extremely high memory usage, we suggest a sane limit. \"\"\" def __init__ ( self , intents : Union [ int , Intents ] = Intents . DEFAULT , loop : Optional [ asyncio . AbstractEventLoop ] = None , default_prefix : str = MENTION_PREFIX , get_prefix : Callable [ ... , Coroutine ] = MISSING , sync_interactions : bool = False , delete_unused_application_cmds : bool = False , debug_scope : \"Snowflake_Type\" = MISSING , asyncio_debug : bool = False , status : Status = Status . ONLINE , activity : Union [ Activity , str ] = None , ** kwargs , ): self . loop : asyncio . AbstractEventLoop = asyncio . get_event_loop () if loop is None else loop # Configuration if asyncio_debug : log . warning ( \"Asyncio Debug is enabled, Your log will contain additional errors and warnings\" ) import tracemalloc tracemalloc . start () self . loop . set_debug ( True ) self . intents = intents \"\"\"The intents in use\"\"\" self . sync_interactions = sync_interactions \"\"\"Should application commands be synced\"\"\" self . del_unused_app_cmd : bool = delete_unused_application_cmds \"\"\"Should unused application commands be deleted?\"\"\" self . debug_scope = to_optional_snowflake ( debug_scope ) \"\"\"Sync global commands as guild for quicker command updates during debug\"\"\" self . default_prefix = default_prefix \"\"\"The default prefix to be used for message commands\"\"\" self . get_prefix = get_prefix if get_prefix is not MISSING else self . get_prefix \"\"\"A coroutine that returns a prefix, for dynamic prefixes\"\"\" # resources self . http : HTTPClient = HTTPClient ( loop = self . loop ) \"\"\"The HTTP client to use when interacting with discord endpoints\"\"\" self . ws : WebsocketClient = MISSING \"\"\"The websocket collection for the Discord Gateway.\"\"\" # flags self . _ready = False self . _closed = False self . _guild_event = asyncio . Event () self . guild_event_timeout = 3 \"\"\"How long to wait for guilds to be cached\"\"\" self . start_time = MISSING \"\"\"The DateTime the bot started at\"\"\" self . _mention_reg = MISSING # caches self . cache : GlobalCache = GlobalCache ( self , ** { k : v for k , v in kwargs . items () if hasattr ( GlobalCache , k )}) # these store the last sent presence data for change_presence self . _status : Status = status if isinstance ( activity , str ): self . _activity = Activity . create ( name = str ( activity )) else : self . _activity : Activity = activity self . _user : SnakeBotUser = MISSING self . _app : Application = MISSING # collections self . commands : Dict [ str , MessageCommand ] = {} \"\"\"A dictionary of registered commands: `{name: command}`\"\"\" self . interactions : Dict [ \"Snowflake_Type\" , Dict [ str , InteractionCommand ]] = {} \"\"\"A dictionary of registered application commands: `{cmd_id: command}`\"\"\" self . _component_callbacks : Dict [ str , Callable [ ... , Coroutine ]] = {} self . _interaction_scopes : Dict [ \"Snowflake_Type\" , \"Snowflake_Type\" ] = {} self . __extensions = {} self . scales = {} \"\"\"A dictionary of mounted Scales\"\"\" self . listeners : Dict [ str , List ] = {} self . waits : Dict [ str , List ] = {} @property def is_closed ( self ) -> bool : \"\"\"Is the bot closed?\"\"\" return self . _closed @property def is_ready ( self ): return self . _ready @property def latency ( self ) -> float : \"\"\"Returns the latency of the websocket connection\"\"\" return self . ws . latency @property def user ( self ) -> SnakeBotUser : \"\"\"Returns the bot's user\"\"\" return self . _user @property def app ( self ) -> Application : \"\"\"Returns the bots application\"\"\" return self . _app @property def owner ( self ) -> Optional [ \"User\" ]: \"\"\"Returns the bot's owner'\"\"\" try : return self . app . owner except TypeError : return MISSING @property def guilds ( self ) -> List [ \"Guild\" ]: return self . user . guilds @property def status ( self ) -> Status : \"\"\"Get the status of the bot. IE online, afk, dnd\"\"\" return self . _status @property def activity ( self ) -> Activity : \"\"\"Get the activity of the bot\"\"\" return self . _activity @property def application_commands ( self ): \"\"\"a list of all application commands registered within the bot\"\"\" commands = [] for scope in self . interactions . keys (): for cmd in self . interactions [ scope ] . values (): if cmd not in commands : commands . append ( cmd ) return commands async def get_prefix ( self , message : Message ) -> str : \"\"\"A method to get the bot's default_prefix, can be overridden to add dynamic prefixes. !!! note To easily override this method, simply use the `get_prefix` parameter when instantiating the client Args: message: A message to determine the prefix from. Returns: A string to use as a prefix, by default will return `client.default_prefix` \"\"\" return self . default_prefix async def login ( self , token ): \"\"\" Login to discord Args: token str: Your bot's token \"\"\" # i needed somewhere to put this call, # login will always run after initialisation # so im gathering commands here self . _gather_commands () log . debug ( f \"Attempting to login\" ) me = await self . http . login ( token . strip ()) self . _user = SnakeBotUser . from_dict ( me , self ) self . cache . place_user_data ( me ) self . _app = Application . from_dict ( await self . http . get_current_bot_information (), self ) self . _mention_reg = re . compile ( fr \"^(<@!? { self . user . id } *>\\s)\" ) self . start_time = datetime . datetime . now () self . dispatch ( events . Login ()) await self . _ws_connect () async def _ws_connect ( self ): params = { \"http\" : self . http , \"dispatch\" : self . dispatch , \"intents\" : self . intents , \"resume\" : False , \"session_id\" : None , \"sequence\" : None , \"presence\" : { \"status\" : self . _status , \"activities\" : [ self . _activity . to_dict ()] if self . _activity else []}, } while not self . is_closed : log . info ( f \"Attempting to { 're' if params [ 'resume' ] else '' } connect to gateway...\" ) try : self . ws = await WebsocketClient . connect ( ** params ) await self . ws . run () except WebSocketRestart as ex : # internally requested restart self . dispatch ( events . Disconnect ()) if ex . resume : params . update ( resume = True , session_id = self . ws . session_id , sequence = self . ws . sequence ) continue params . update ( resume = False , session_id = None , sequence = None ) except ( OSError , GatewayNotFound , aiohttp . ClientError , asyncio . TimeoutError , WebSocketClosed ) as ex : log . debug ( \"\" . join ( traceback . format_exception ( type ( ex ), ex , ex . __traceback__ ))) self . dispatch ( events . Disconnect ()) if isinstance ( ex , WebSocketClosed ): if ex . code == 1000 : if self . _ready : # the bot disconnected, attempt to reconnect to gateway params . update ( resume = True , session_id = self . ws . session_id , sequence = self . ws . sequence ) continue else : return elif ex . code == 4011 : raise SnakeException ( \"Your bot is too large, you must use shards\" ) from None elif ex . code == 4013 : raise SnakeException ( \"Invalid Intents have been passed\" ) from None elif ex . code == 4014 : raise SnakeException ( \"You have requested privileged intents that have not been enabled or approved. Check the developer dashboard\" ) from None raise if isinstance ( ex , OSError ) and ex . errno in ( 54 , 10054 ): print ( \"should reconnect\" ) params . update ( resume = True , session_id = self . ws . session_id , sequence = self . ws . sequence ) continue params . update ( resume = False , session_id = None , sequence = None ) except Exception as e : self . dispatch ( events . Disconnect ()) log . error ( \"\" . join ( traceback . format_exception ( type ( e ), e , e . __traceback__ ))) params . update ( resume = False , session_id = None , sequence = None ) await asyncio . sleep ( 5 ) def _queue_task ( self , coro , event , * args , ** kwargs ): async def _async_wrap ( _coro , _event , * _args , ** _kwargs ): try : if len ( _event . __attrs_attrs__ ) == 1 : await _coro () else : await _coro ( _event , * _args , ** _kwargs ) except asyncio . CancelledError : pass except Exception as e : await self . on_error ( event , e ) wrapped = _async_wrap ( coro , event , * args , ** kwargs ) return asyncio . create_task ( wrapped , name = f \"snake:: { event . resolved_name } \" ) async def on_error ( self , source : str , error : Exception , * args , ** kwargs ) -> None : \"\"\" Catches all errors dispatched by the library. By default it will format and print them to console Override this to change error handling behaviour \"\"\" print ( f \"Ignoring exception in { source } : \\n { traceback . format_exc () } \" , file = sys . stderr ) async def on_command_error ( self , source : str , error : Exception , * args , ** kwargs ) -> None : \"\"\" Catches all errors dispatched by commands By default it will call `Snake.on_error` Override this to change error handling behavior \"\"\" return await self . on_error ( source , error , * args , ** kwargs ) async def on_command ( self , ctx : Context ) -> None : \"\"\" Called *after* any command is ran By default, it will simply log the command, override this to change that behaviour Args: ctx: The context of the command that was called \"\"\" if isinstance ( ctx , MessageContext ): symbol = \"@\" elif isinstance ( ctx , ComponentContext ): symbol = \"\u00a2\" elif isinstance ( ctx , InteractionContext ): symbol = \"/\" else : symbol = \"?\" # likely custom context log . info ( f \"Command Called: { symbol }{ ctx . invoked_name } with { ctx . args = } | { ctx . kwargs = } \" ) @listen () async def _on_websocket_ready ( self , event : events . RawGatewayEvent ) -> None : \"\"\" Catches websocket ready and determines when to dispatch the client `READY` signal. Args: event: The websocket ready packet \"\"\" data = event . data expected_guilds = set ( to_snowflake ( guild [ \"id\" ]) for guild in data [ \"guilds\" ]) self . _user . _add_guilds ( expected_guilds ) while True : try : # wait to let guilds cache await asyncio . wait_for ( self . _guild_event . wait (), self . guild_event_timeout ) except asyncio . TimeoutError : log . warning ( \"Timeout waiting for guilds cache: Not all guilds will be in cache\" ) break self . _guild_event . clear () if len ( self . cache . guild_cache ) == len ( expected_guilds ): # all guilds cached break # cache slash commands await self . _init_interactions () self . _ready = True self . dispatch ( events . Ready ()) def start ( self , token ): \"\"\" Start the bot. info: This is the recommended method to start the bot Args: token str: Your bot's token \"\"\" try : self . loop . run_until_complete ( self . login ( token )) except KeyboardInterrupt : self . loop . run_until_complete ( self . stop ()) async def stop ( self ): log . debug ( \"Stopping the bot.\" ) self . _ready = False await self . ws . close ( 1001 ) def dispatch ( self , event : events . BaseEvent , * args , ** kwargs ): \"\"\" Dispatch an event. Args: event: The event to be dispatched. \"\"\" log . debug ( f \"Dispatching Event: { event . resolved_name } \" ) listeners = self . listeners . get ( event . resolved_name , []) for _listen in listeners : try : self . _queue_task ( _listen , event , * args , ** kwargs ) except Exception as e : raise BotException ( f \"An error occurred attempting during { event . resolved_name } event processing\" ) _waits = self . waits . get ( event . resolved_name , []) index_to_remove = [] for i , _wait in enumerate ( _waits ): result = _wait ( event ) if result : index_to_remove . append ( i ) for idx in index_to_remove : _waits . pop ( idx ) def wait_for ( self , event : str , checks : Optional [ Callable [ ... , bool ]] = MISSING , timeout : Optional [ float ] = None ): \"\"\" Waits for a WebSocket event to be dispatched. Args: event: The name of event to wait. checks: A predicate to check what to wait for. timeout: The number of seconds to wait before timing out. Returns: The event object. \"\"\" if event not in self . waits : self . waits [ event ] = [] future = self . loop . create_future () self . waits [ event ] . append ( Wait ( event , checks , future )) return asyncio . wait_for ( future , timeout ) async def wait_for_component ( self , messages : Union [ Message , int , list ] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , check = None , timeout = None , ) -> Awaitable [ \"Future\" ]: \"\"\" Waits for a message to be sent to the bot. Args: messages: The message object to check for. components: The components to wait for. check: A predicate to check what to wait for. timeout: The number of seconds to wait before timing out. Returns: `Component` that was invoked, or `None` if timed out. Use `.context` to get the `ComponentContext`. \"\"\" if not ( messages or components ): raise ValueError ( \"You must specify messages or components (or both)\" ) message_ids = ( to_snowflake_list ( messages ) if isinstance ( messages , list ) else to_snowflake ( messages ) if messages else None ) custom_ids = list ( get_components_ids ( components )) if components else None # automatically convert improper custom_ids if custom_ids and not all ( isinstance ( x , str ) for x in custom_ids ): custom_ids = [ str ( i ) for i in custom_ids ] def _check ( event : Component ): ctx : ComponentContext = event . context # if custom_ids is empty or there is a match wanted_message = not message_ids or ctx . message . id in ( [ message_ids ] if isinstance ( message_ids , int ) else message_ids ) wanted_component = not custom_ids or ctx . custom_id in custom_ids if wanted_message and wanted_component : if check is None or check ( event ): return True return False return False return await self . wait_for ( \"component\" , checks = _check , timeout = timeout ) def add_listener ( self , listener : Listener ): \"\"\" Add a listener for an event, if no event is passed, one is determined Args: coro Listener: The listener to add to the client \"\"\" if listener . event not in self . listeners : self . listeners [ listener . event ] = [] self . listeners [ listener . event ] . append ( listener ) def add_interaction ( self , command : InteractionCommand ): \"\"\" Add a slash command to the client. Args: command InteractionCommand: The command to add \"\"\" if self . debug_scope : command . scopes = [ self . debug_scope ] for scope in command . scopes : if scope not in self . interactions : self . interactions [ scope ] = {} elif command . resolved_name in self . interactions [ scope ]: old_cmd = self . interactions [ scope ][ command . resolved_name ] raise ValueError ( f \"Duplicate Command! { scope } :: { old_cmd . resolved_name } \" ) self . interactions [ scope ][ command . resolved_name ] = command def add_message_command ( self , command : MessageCommand ): \"\"\" Add a message command to the client. Args: command InteractionCommand: The command to add \"\"\" if command . name not in self . commands : self . commands [ command . name ] = command return raise ValueError ( f \"Duplicate Command! Multiple commands share the name ` { command . name } `\" ) def add_component_callback ( self , command : ComponentCommand ): \"\"\"Add a component callback to the client Args: command: The command to add \"\"\" for listener in command . listeners : # I know this isn't an ideal solution, but it means we can lookup callbacks with O(1) if listener not in self . _component_callbacks . keys (): self . _component_callbacks [ listener ] = command continue else : raise ValueError ( f \"Duplicate Component! Multiple component callbacks for ` { listener } `\" ) def _gather_commands ( self ): \"\"\"Gathers commands from __main__ and self\"\"\" def process ( _cmds ): for func in _cmds : if isinstance ( func , ComponentCommand ): self . add_component_callback ( func ) elif isinstance ( func , InteractionCommand ): self . add_interaction ( func ) elif isinstance ( func , MessageCommand ): self . add_message_command ( func ) elif isinstance ( func , Listener ): self . add_listener ( func ) log . debug ( f \" { len ( _cmds ) } commands have been loaded from `__main__` and `client`\" ) process ( [ obj for _ , obj in inspect . getmembers ( sys . modules [ \"__main__\" ]) if isinstance ( obj , ( BaseCommand , Listener ))] ) process ( [ wrap_partial ( obj , self ) for _ , obj in inspect . getmembers ( self ) if isinstance ( obj , ( BaseCommand , Listener ))] ) async def _init_interactions ( self ) -> None : \"\"\" Initialise slash commands. If `sync_interactions` this will submit all registered slash commands to discord. Otherwise, it will get the list of interactions and cache their scopes. \"\"\" # allow for cogs and main to share the same decorator try : if self . sync_interactions : await self . synchronise_interactions () else : await self . _cache_interactions ( warn_missing = True ) except Exception as e : await self . on_error ( \"Interaction Syncing\" , e ) async def _cache_interactions ( self , warn_missing : bool = False ): \"\"\"Get all interactions used by this bot and cache them.\"\"\" bot_scopes = set ( g . id for g in self . cache . guild_cache . values ()) bot_scopes . add ( GLOBAL_SCOPE ) # Match all interaction is registered with discord's data. for scope in self . interactions : bot_scopes . discard ( scope ) try : remote_cmds = await self . http . get_interaction_element ( self . user . id , scope ) except Forbidden as e : raise InteractionMissingAccess ( scope ) from None remote_cmds = { cmd_data [ \"name\" ]: cmd_data for cmd_data in remote_cmds } found = set () # this is a temporary hack to fix subcommand detection for cmd in self . interactions [ scope ] . values (): cmd_data = remote_cmds . get ( cmd . name , MISSING ) if cmd_data is MISSING : if cmd . name not in found : if warn_missing : log . error ( f 'Detected yet to sync slash command \"/ { cmd . name } \" for scope ' f \" { 'global' if scope == GLOBAL_SCOPE else scope } \" ) continue else : found . add ( cmd . name ) self . _interaction_scopes [ str ( cmd_data [ \"id\" ])] = scope cmd . cmd_id = str ( cmd_data [ \"id\" ]) if warn_missing : for cmd_data in remote_cmds . values (): log . error ( f \"Detected unimplemented slash command \\\" / { cmd_data [ 'name' ] } \\\" for scope \" f \" { 'global' if scope == GLOBAL_SCOPE else scope } \" ) # Remaining guilds that bot is in but, no interaction is registered for scope in bot_scopes : try : remote_cmds = await self . http . get_interaction_element ( self . user . id , scope ) except Forbidden : # We will just assume they don't want application commands in this guild. log . debug ( f \"Bot was not invited to guild { scope } with `application.commands` scope\" ) continue for cmd_data in remote_cmds : self . _interaction_scopes [ str ( cmd_data [ \"id\" ])] = scope if warn_missing : log . error ( f \"Detected unimplemented slash command \\\" / { cmd_data [ 'name' ] } \\\" for scope \" f \" { 'global' if scope == GLOBAL_SCOPE else scope } \" ) async def synchronise_interactions ( self ) -> None : \"\"\"Synchronise registered interactions with discord One flaw of this is it cant determine if context menus need updating, as discord isn't returning that data on get req, so they are unnecessarily updated\"\"\" # first we need to make sure our local copy of cmd_ids is up-to-date await self . _cache_interactions () cmd_scopes = [ to_snowflake ( g_id ) for g_id in self . _user . _guild_ids ] + [ GLOBAL_SCOPE ] guild_perms = {} cmds_json = application_commands_to_dict ( self . interactions ) for cmd_scope in cmd_scopes : try : cmds_resp_data = await self . http . get_interaction_element ( self . user . id , cmd_scope ) need_to_sync = False cmds_to_sync = [] found = [] for local_cmd in self . interactions . get ( cmd_scope , {}) . values (): # try and find remote equiv of this command remote_cmd = next (( v for v in cmds_resp_data if v [ \"id\" ] == local_cmd . cmd_id ), None ) local_cmd = next (( c for c in cmds_json [ cmd_scope ] if c [ \"name\" ] == local_cmd . name )) if local_cmd not in cmds_to_sync : cmds_to_sync . append ( local_cmd ) if remote_cmd not in found : found . append ( remote_cmd ) # todo: prevent un-needed syncs for subcommands if sync_needed ( local_cmd , remote_cmd ): # if command local data doesnt match remote, a change has been made, sync it need_to_sync = True if need_to_sync : log . info ( f \"Updating { len ( cmds_to_sync ) } commands in { cmd_scope } \" ) cmd_sync_resp = await self . http . post_interaction_element ( self . user . id , cmds_to_sync , guild_id = cmd_scope ) # cache cmd_ids and their scopes for cmd_data in cmd_sync_resp : self . _interaction_scopes [ cmd_data [ \"id\" ]] = cmd_scope if cmd_data [ \"name\" ] in self . interactions [ cmd_scope ]: self . interactions [ cmd_scope ][ cmd_data [ \"name\" ]] . cmd_id = str ( cmd_data [ \"id\" ]) else : # sub_cmd for sc in cmd_data [ \"options\" ]: if sc [ \"type\" ] == OptionTypes . SUB_COMMAND : if f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } \" in self . interactions [ cmd_scope ]: self . interactions [ cmd_scope ][ f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } \" ] . cmd_id = str ( cmd_data [ \"id\" ] ) elif sc [ \"type\" ] == OptionTypes . SUB_COMMAND_GROUP : for _sc in sc [ \"options\" ]: if ( f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } { _sc [ 'name' ] } \" in self . interactions [ cmd_scope ] ): self . interactions [ cmd_scope ][ f \" { cmd_data [ 'name' ] } { sc [ 'name' ] } { _sc [ 'name' ] } \" ] . cmd_id = str ( cmd_data [ \"id\" ]) else : log . debug ( f \" { cmd_scope } is already up-to-date with { len ( cmds_resp_data ) } commands.\" ) for local_cmd in self . interactions . get ( cmd_scope , {}) . values (): if not local_cmd . permissions : continue for perm_scope , perms in local_cmd . permissions . items (): if perm_scope not in guild_perms : guild_perms [ perm_scope ] = [] guild_perms [ perm_scope ] . append ( { \"id\" : local_cmd . cmd_id , \"permissions\" : [ perm . to_dict () for perm in perms ]} ) for perm_scope in guild_perms : log . debug ( f \"Updating { len ( guild_perms [ perm_scope ]) } command permissions in { perm_scope } \" ) await self . http . batch_edit_application_command_permissions ( application_id = self . user . id , scope = perm_scope , data = guild_perms [ perm_scope ] ) if self . del_unused_app_cmd : for cmd in [ c for c in cmds_resp_data if c not in found ]: scope = cmd . get ( \"guild_id\" , GLOBAL_SCOPE ) log . warning ( f \"Deleting unimplemented slash command \\\" / { cmd [ 'name' ] } \\\" from scope \" f \" { 'global' if scope == GLOBAL_SCOPE else scope } \" ) await self . http . delete_interaction_element ( self . user . id , cmd . get ( \"guild_id\" , GLOBAL_SCOPE ), cmd [ \"id\" ] ) except Forbidden as e : raise InteractionMissingAccess ( cmd_scope ) from None async def get_context ( self , data : Union [ dict , Message ], interaction : bool = False ) -> Union [ MessageContext , InteractionContext , ComponentContext , AutocompleteContext ]: \"\"\" Return a context object based on data passed note: If you want to use custom context objects, this is the method to override. Your replacement must take the same arguments as this, and return a Context-like object. Args: data: The data of the event interaction: Is this an interaction or not? returns: Context object \"\"\" # this line shuts up IDE warnings cls : Union [ MessageContext , ComponentContext , InteractionContext , AutocompleteContext ] if interaction : # todo: change to match if data [ \"type\" ] == InteractionTypes . MESSAGE_COMPONENT : return ComponentContext . from_dict ( data , self ) elif data [ \"type\" ] == InteractionTypes . AUTOCOMPLETE : cls = AutocompleteContext . from_dict ( data , self ) else : cls = InteractionContext . from_dict ( data , self ) invoked_name : str = data [ \"data\" ][ \"name\" ] kwargs = {} if options := data [ \"data\" ] . get ( \"options\" ): o_type = options [ 0 ][ \"type\" ] if o_type in ( OptionTypes . SUB_COMMAND , OptionTypes . SUB_COMMAND_GROUP ): # this is a subcommand, process accordingly if o_type == OptionTypes . SUB_COMMAND : invoked_name = f \" { invoked_name } { options [ 0 ][ 'name' ] } \" options = options [ 0 ] . get ( \"options\" , []) else : invoked_name = ( f \" { invoked_name } { options [ 0 ][ 'name' ] } \" f \" { next ( x for x in options [ 0 ][ 'options' ] if x [ 'type' ] == OptionTypes . SUB_COMMAND )[ 'name' ] } \" ) options = options [ 0 ][ \"options\" ][ 0 ] . get ( \"options\" , []) for option in options : value = option . get ( \"value\" ) # todo change to match statement # this block here resolves the options using the cache if option [ \"type\" ] == OptionTypes . USER : value = ( self . cache . member_cache . get (( to_snowflake ( data . get ( \"guild_id\" , 0 )), to_snowflake ( value ))) or self . cache . user_cache . get ( to_snowflake ( value )) ) or value elif option [ \"type\" ] == OptionTypes . CHANNEL : value = self . cache . channel_cache . get ( to_snowflake ( value )) or value elif option [ \"type\" ] == OptionTypes . ROLE : value = self . cache . role_cache . get ( to_snowflake ( value )) or value elif option [ \"type\" ] == OptionTypes . MENTIONABLE : snow = to_snowflake ( value ) if user := self . cache . member_cache . get ( snow ) or self . cache . user_cache . get ( snow ): value = user elif role := self . cache . role_cache . get ( snow ): value = role if option . get ( \"focused\" , False ): cls . focussed_option = option . get ( \"name\" ) kwargs [ option [ \"name\" ] . lower ()] = value cls . invoked_name = invoked_name cls . kwargs = kwargs cls . args = [ v for v in kwargs . values ()] return cls else : return MessageContext . from_message ( self , data ) @listen ( \"raw_interaction_create\" ) async def _dispatch_interaction ( self , event : RawGatewayEvent ) -> None : \"\"\" Identify and dispatch interaction of slash commands or components. Args: raw interaction event \"\"\" interaction_data = event . data if interaction_data [ \"type\" ] in ( InteractionTypes . PING , InteractionTypes . APPLICATION_COMMAND , InteractionTypes . AUTOCOMPLETE , ): interaction_id = interaction_data [ \"data\" ][ \"id\" ] name = interaction_data [ \"data\" ][ \"name\" ] scope = self . _interaction_scopes . get ( str ( interaction_id )) if scope in self . interactions : ctx = await self . get_context ( interaction_data , True ) command : SlashCommand = self . interactions [ scope ][ ctx . invoked_name ] # type: ignore log . debug ( f \" { scope } :: { command . name } should be called\" ) if auto_opt := getattr ( ctx , \"focussed_option\" , None ): await command . autocomplete_callbacks [ auto_opt ]( ctx , ** ctx . kwargs ) else : try : await command ( ctx , ** ctx . kwargs ) except Exception as e : await self . on_command_error ( f \"cmd /` { name } `\" , e ) finally : await self . on_command ( ctx ) else : log . error ( f \"Unknown cmd_id received:: { interaction_id } ( { name } )\" ) elif interaction_data [ \"type\" ] == InteractionTypes . MESSAGE_COMPONENT : # Buttons, Selects, ContextMenu::Message ctx = await self . get_context ( interaction_data , True ) component_type = interaction_data [ \"data\" ][ \"component_type\" ] self . dispatch ( events . Component ( ctx )) if callback := self . _component_callbacks . get ( ctx . custom_id ): try : await callback ( ctx ) except Exception as e : await self . on_command_error ( f \"Component Callback for { ctx . custom_id } \" , e ) finally : await self . on_command ( ctx ) if component_type == ComponentTypes . BUTTON : self . dispatch ( events . Button ( ctx )) if component_type == ComponentTypes . SELECT : self . dispatch ( events . Select ( ctx )) else : raise NotImplementedError ( f \"Unknown Interaction Received: { interaction_data [ 'type' ] } \" ) @listen ( \"message_create\" ) async def _dispatch_msg_commands ( self , event : MessageCreate ): \"\"\"Determine if a command is being triggered, and dispatch it.\"\"\" message = event . message if not message . author . bot : prefix = await self . get_prefix ( message ) if prefix == MENTION_PREFIX : mention = self . _mention_reg . search ( message . content ) if mention : prefix = mention . group () else : return if message . content . startswith ( prefix ): invoked_name = get_first_word ( message . content . removeprefix ( prefix )) command = self . commands . get ( invoked_name ) if command and command . enabled : context = await self . get_context ( message ) context . invoked_name = invoked_name context . prefix = prefix context . args = get_args ( context . content_parameters ) try : await command ( context ) except Exception as e : await self . on_command_error ( f \"cmd ` { invoked_name } `\" , e ) finally : await self . on_command ( context ) def get_scale ( self , name ) -> Optional [ Scale ]: \"\"\" Get a scale Args: name: The name of the scale, or the name of it's extension Returns: Scale or None if no scale is found \"\"\" if name not in self . scales . keys (): for scale in self . scales . values (): if scale . extension_name == name : return scale return self . scales . get ( name , None ) def grow_scale ( self , file_name : str , package : str = None ) -> None : \"\"\" A helper method to load a scale Args: file_name: The name of the file to load the scale from. package: The package this scale is in. \"\"\" self . load_extension ( file_name , package ) def shed_scale ( self , scale_name : str ) -> None : \"\"\" Helper method to unload a scale Args: scale_name: The name of the scale to unload. \"\"\" if scale := self . get_scale ( scale_name ): return self . unload_extension ( inspect . getmodule ( scale ) . __name__ ) raise ScaleLoadException ( f \"Unable to shed scale: No scale exists with name: ` { scale_name } `\" ) def regrow_scale ( self , scale_name : str ) -> None : \"\"\" Helper method to reload a scale. Args: scale_name: The name of the scale to reload \"\"\" self . shed_scale ( scale_name ) self . grow_scale ( scale_name ) def load_extension ( self , name : str , package : str = None ): \"\"\" Load an extension. Args: name: The name of the extension. package: The package the extension is in \"\"\" name = importlib . util . resolve_name ( name , package ) if name in self . __extensions : raise Exception ( f \" { name } already loaded\" ) module = importlib . import_module ( name , package ) try : setup = getattr ( module , \"setup\" ) setup ( self ) except Exception as e : del sys . modules [ name ] raise ExtensionLoadException ( f \"Error loading { name } \" ) from e else : log . debug ( f \"Loaded Extension: { name } \" ) self . __extensions [ name ] = module return def unload_extension ( self , name , package = None ): \"\"\" unload an extension. Args: name: The name of the extension. package: The package the extension is in \"\"\" name = importlib . util . resolve_name ( name , package ) module = self . __extensions . get ( name ) if module is None : raise ExtensionNotFound ( f \"No extension called { name } is loaded\" ) try : teardown = getattr ( module , \"teardown\" ) teardown () except AttributeError : pass if scale := self . get_scale ( name ): scale . shed () del sys . modules [ name ] del self . __extensions [ name ] def reload_extension ( self , name , package = None ): \"\"\" Helper method to reload an extension. Simply unloads, then loads the extension. Args: name: The name of the extension. package: The package the extension is in \"\"\" name = importlib . util . resolve_name ( name , package ) module = self . __extensions . get ( name ) if module is None : log . warning ( \"Attempted to reload extension thats not loaded. Loading extension instead\" ) return self . load_extension ( name , package ) self . unload_extension ( name , package ) self . load_extension ( name , package ) # todo: maybe add an ability to revert to the previous version if unable to load the new one async def get_guild ( self , guild_id : \"Snowflake_Type\" ) -> Guild : \"\"\" Get a guild Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: guild_id: The ID of the guild to get Returns: Guild Object \"\"\" return await self . cache . get_guild ( guild_id ) async def get_channel ( self , channel_id : \"Snowflake_Type\" ) -> \"TYPE_ALL_CHANNEL\" : \"\"\" Get a channel Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: channel_id: The ID of the channel to get Returns: Channel Object \"\"\" return await self . cache . get_channel ( channel_id ) async def get_user ( self , user_id : \"Snowflake_Type\" ) -> User : \"\"\" Get a user Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: user_id: The ID of the user to get Returns: User Object \"\"\" return await self . cache . get_user ( user_id ) async def get_member ( self , user_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" ) -> Member : \"\"\" Get a member from a guild Note: This method is an alias for the cache which will either return a cached object, or query discord for the object if its not already cached. Args: user_id: The ID of the member guild_id: The ID of the guild to get the member from Returns: Member object \"\"\" return await self . cache . get_member ( guild_id , user_id ) async def get_sticker ( self , sticker_id : \"Snowflake_Type\" ): sticker_data = await self . http . get_sticker ( sticker_id ) return Sticker . from_dict ( sticker_data , self ) async def get_nitro_packs ( self ) -> List [ \"StickerPack\" ]: packs_data = await self . http . list_nitro_sticker_packs () packs = [] for pack_data in packs_data : packs . append ( StickerPack . from_dict ( pack_data , self )) return packs async def change_presence ( self , status : Optional [ Union [ str , Status ]] = Status . ONLINE , activity : Optional [ Union [ Activity , str ]] = None ): \"\"\" Change the bots presence. Args: status: The status for the bot to be. i.e. online, afk, etc. activity: The activity for the bot to be displayed as doing. note:: Bots may only be `playing` `streaming` or `listening`, other activity types are likely to fail. \"\"\" if activity : if not isinstance ( activity , Activity ): # squash whatever the user passed into an activity activity = Activity . create ( name = str ( activity )) if activity . type == ActivityType . STREAMING : if not activity . url : log . warning ( \"Streaming activity cannot be set without a valid URL attribute\" ) elif activity . type not in [ ActivityType . GAME , ActivityType . STREAMING , ActivityType . LISTENING ]: log . warning ( f \"Activity type ` { ActivityType ( activity . type ) . name } ` may not be enabled for bots\" ) else : activity = self . _activity if self . _activity else [] if status : if not isinstance ( status , Status ): try : status = Status [ status . upper ()] except KeyError : raise ValueError ( f \"` { status } ` is not a valid status type. Please use the Status enum\" ) from None else : # in case the user set status to None if self . _status : status = self . _status else : log . warning ( \"Status must be set to a valid status type, defaulting to online\" ) status = Status . ONLINE self . _status = status self . _activity = activity await self . ws . change_presence ( activity . to_dict () if activity else None , status )","title":"Snake"},{"location":"API%20Reference/constants/","text":"Constants used throughout Snek. Attributes: Name Type Description __version__ str The version of the library. __repo_url__ str The URL of the repository. __py_version__ str The python version in use. logger_name str The logger name used by Snek. kwarg_spam bool Should unused kwargs be logged. ACTION_ROW_MAX_ITEMS int The maximum number of items in an action row. SELECTS_MAX_OPTIONS int The maximum number of options a select may have. SELECT_MAX_NAME_LENGTH int The max length of a select's name. CONTEXT_MENU_NAME_LENGTH int The max length of a context menu's name. SLASH_CMD_NAME_LENGTH int The max length of a slash command's name. SLASH_CMD_MAX_DESC_LENGTH int The maximum length of a slash command's description. SLASH_CMD_MAX_OPTIONS int The maximum number of options a slash command may have. SLASH_OPTION_NAME_LENGTH int The maximum length of a slash option's name. EMBED_MAX_NAME_LENGTH int The maximum length for an embed title EMBED_MAX_DESC_LENGTH int The maximum length for an embed description EMBED_MAX_FIELDS int The maximum number of fields for an embed EMBED_TOTAL_MAX int The total combined number of characters for an embed PREMIUM_GUILD_LIMITS dict Limits granted per premium level of a guild GLOBAL_SCOPE _sentinel A sentinel that represents a global scope for application commands. MENTION_PREFIX _sentinel A sentinel representing the bot will be mentioned for a prefix MISSING _sentinel A sentinel value that indicates something has not been set","title":"Constants"},{"location":"API%20Reference/enums/","text":"AntiFlag \u00b6 Source code in dis_snek/models/enums.py class AntiFlag : def __init__ ( self , anti = 0 ): self . anti = anti def __get__ ( self , instance , cls ): negative = ~ cls ( self . anti ) positive = cls ( reduce ( or_ , negative )) return positive DistinctFlag ( EnumMeta ) \u00b6 Source code in dis_snek/models/enums.py class DistinctFlag ( EnumMeta ): def __iter__ ( cls ): yield from _distinct ( super () . __iter__ ()) def __call__ ( cls , value , names = None , * , module = None , qualname = None , type = None , start = 1 ): # To automatically convert string values into ints (eg for permissions) return super () . __call__ ( int ( value ), names , module = module , qualname = qualname , type = type , start = start ) DiscordIntFlag ( IntFlag ) \u00b6 An enumeration. Source code in dis_snek/models/enums.py class DiscordIntFlag ( IntFlag , metaclass = DistinctFlag ): def __iter__ ( self ): yield from _decompose ( self . __class__ , self )[ 0 ] WebSocketOPCodes ( IntEnum ) \u00b6 Codes used by the Gateway to signify events Source code in dis_snek/models/enums.py class WebSocketOPCodes ( IntEnum ): \"\"\"Codes used by the Gateway to signify events\"\"\" DISPATCH = 0 \"\"\"An event was dispatched\"\"\" HEARTBEAT = 1 \"\"\"Fired periodically by the client to keep the connection alive\"\"\" IDENTIFY = 2 \"\"\"Starts a new session during the initial handshake.\"\"\" PRESENCE = 3 \"\"\"Update the client's presence.\"\"\" VOICE_STATE = 4 \"\"\"Used to join/leave or move between voice channels.\"\"\" VOICE_PING = 5 RESUME = 6 \"\"\"Resume a previous session that was disconnected.\"\"\" RECONNECT = 7 \"\"\"You should attempt to reconnect and resume immediately.\"\"\" REQUEST_MEMBERS = 8 \"\"\"Request information about offline guild members in a large guild.\"\"\" INVALIDATE_SESSION = 9 \"\"\"The session has been invalidated. You should reconnect and identify/resume accordingly.\"\"\" HELLO = 10 \"\"\"Sent immediately after connecting, contains the `heartbeat_interval` to use.\"\"\" HEARTBEAT_ACK = 11 \"\"\"Sent in response to receiving a heartbeat to acknowledge that it has been received.\"\"\" GUILD_SYNC = 12 DISPATCH \u00b6 An event was dispatched GUILD_SYNC \u00b6 HEARTBEAT \u00b6 Fired periodically by the client to keep the connection alive HEARTBEAT_ACK \u00b6 Sent in response to receiving a heartbeat to acknowledge that it has been received. HELLO \u00b6 Sent immediately after connecting, contains the heartbeat_interval to use. IDENTIFY \u00b6 Starts a new session during the initial handshake. INVALIDATE_SESSION \u00b6 The session has been invalidated. You should reconnect and identify/resume accordingly. PRESENCE \u00b6 Update the client's presence. RECONNECT \u00b6 You should attempt to reconnect and resume immediately. REQUEST_MEMBERS \u00b6 Request information about offline guild members in a large guild. RESUME \u00b6 Resume a previous session that was disconnected. VOICE_PING \u00b6 VOICE_STATE \u00b6 Used to join/leave or move between voice channels. Intents ( DiscordIntFlag ) \u00b6 When identifying to the gateway, you can specify an intents parameter which allows you to conditionally subscribe to pre-defined \"intents\", groups of events defined by Discord. Info For details about what intents do, or which intents you'll want, please read the Discord API Documentation Source code in dis_snek/models/enums.py class Intents ( DiscordIntFlag ): # type: ignore \"\"\"When identifying to the gateway, you can specify an intents parameter which allows you to conditionally subscribe to pre-defined \"intents\", groups of events defined by Discord. info: For details about what intents do, or which intents you'll want, please read the [Discord API Documentation](https://discord.com/developers/docs/topics/gateway#gateway-intents)\"\"\" GUILDS = 1 << 0 GUILD_MEMBERS = 1 << 1 GUILD_BANS = 1 << 2 GUILD_EMOJIS_AND_STICKERS = 1 << 3 GUILD_INTEGRATIONS = 1 << 4 GUILD_WEBHOOKS = 1 << 5 GUILD_INVITES = 1 << 6 GUILD_VOICE_STATES = 1 << 7 GUILD_PRESENCES = 1 << 8 GUILD_MESSAGES = 1 << 9 GUILD_MESSAGE_REACTIONS = 1 << 10 GUILD_MESSAGE_TYPING = 1 << 11 DIRECT_MESSAGES = 1 << 12 DIRECT_MESSAGE_REACTIONS = 1 << 13 DIRECT_MESSAGE_TYPING = 1 << 14 # Shortcuts/grouping/aliases MESSAGES = GUILD_MESSAGES | DIRECT_MESSAGES REACTIONS = GUILD_MESSAGE_REACTIONS | DIRECT_MESSAGE_REACTIONS TYPING = GUILD_MESSAGE_TYPING | DIRECT_MESSAGE_TYPING PRIVILEGED = GUILD_PRESENCES | GUILD_MEMBERS NON_PRIVILEGED = AntiFlag ( PRIVILEGED ) DEFAULT = NON_PRIVILEGED # Special members NONE = 0 ALL = AntiFlag () @classmethod def new ( cls , guilds = False , guild_members = False , guild_bans = False , guild_emojis_and_stickers = False , guild_integrations = False , guild_webhooks = False , guild_invites = False , guild_voice_states = False , guild_presences = False , guild_messages = False , guild_message_reactions = False , guild_message_typing = False , direct_messages = False , direct_message_reactions = False , direct_message_typing = False , messages = False , reactions = False , typing = False , privileged = False , non_privileged = False , default = True , all = False , ): \"\"\" Set your desired intents \"\"\" kwargs = locals () del kwargs [ \"cls\" ] intents = cls . NONE for key in kwargs : if kwargs [ key ]: intents |= getattr ( cls , key . upper ()) return intents DIRECT_MESSAGES \u00b6 DIRECT_MESSAGE_REACTIONS \u00b6 DIRECT_MESSAGE_TYPING \u00b6 GUILDS \u00b6 GUILD_BANS \u00b6 GUILD_EMOJIS_AND_STICKERS \u00b6 GUILD_INTEGRATIONS \u00b6 GUILD_INVITES \u00b6 GUILD_MEMBERS \u00b6 GUILD_MESSAGES \u00b6 GUILD_MESSAGE_REACTIONS \u00b6 GUILD_MESSAGE_TYPING \u00b6 GUILD_PRESENCES \u00b6 GUILD_VOICE_STATES \u00b6 GUILD_WEBHOOKS \u00b6 MESSAGES \u00b6 NONE \u00b6 PRIVILEGED \u00b6 REACTIONS \u00b6 TYPING \u00b6 UserFlags ( DiscordIntFlag ) \u00b6 Flags a user can have Source code in dis_snek/models/enums.py class UserFlags ( DiscordIntFlag ): # type: ignore \"\"\"Flags a user can have\"\"\" DISCORD_EMPLOYEE = 1 << 0 \"\"\"This person works for Discord\"\"\" PARTNERED_SERVER_OWNER = 1 << 1 \"\"\"User owns a partnered server\"\"\" HYPESQUAD_EVENTS = 1 << 2 \"\"\"User has helped with a hypesquad event\"\"\" BUG_HUNTER_LEVEL_1 = 1 << 3 \"\"\"User has passed the bug hunters quiz\"\"\" HOUSE_BRAVERY = 1 << 6 \"\"\"User belongs to the `bravery` house\"\"\" HOUSE_BRILLIANCE = 1 << 7 \"\"\"User belongs to the `brilliance` house\"\"\" HOUSE_BALANCE = 1 << 8 \"\"\"User belongs to the `balance` house\"\"\" EARLY_SUPPORTER = 1 << 9 \"\"\"This person had Nitro prior to prior to Wednesday, October 10th, 2018\"\"\" TEAM_USER = 1 << 10 \"\"\"A team user\"\"\" BUG_HUNTER_LEVEL_2 = 1 << 14 \"\"\"User is a bug hunter level 2\"\"\" VERIFIED_BOT = 1 << 16 \"\"\"This bot has been verified by Discord\"\"\" EARLY_VERIFIED_BOT_DEVELOPER = 1 << 17 \"\"\"This user was one of the first to be verified\"\"\" DISCORD_CERTIFIED_MODERATOR = 1 << 18 \"\"\"This user is a certified moderator\"\"\" # Shortcuts/grouping/aliases HYPESQUAD = HOUSE_BRAVERY | HOUSE_BRILLIANCE | HOUSE_BALANCE BUG_HUNTER = BUG_HUNTER_LEVEL_1 | BUG_HUNTER_LEVEL_2 # Special members NONE = 0 ALL = AntiFlag () BUG_HUNTER \u00b6 BUG_HUNTER_LEVEL_1 \u00b6 User has passed the bug hunters quiz BUG_HUNTER_LEVEL_2 \u00b6 User is a bug hunter level 2 DISCORD_CERTIFIED_MODERATOR \u00b6 This user is a certified moderator DISCORD_EMPLOYEE \u00b6 This person works for Discord EARLY_SUPPORTER \u00b6 This person had Nitro prior to prior to Wednesday, October 10 th , 2018 EARLY_VERIFIED_BOT_DEVELOPER \u00b6 This user was one of the first to be verified HOUSE_BALANCE \u00b6 User belongs to the balance house HOUSE_BRAVERY \u00b6 User belongs to the bravery house HOUSE_BRILLIANCE \u00b6 User belongs to the brilliance house HYPESQUAD \u00b6 HYPESQUAD_EVENTS \u00b6 User has helped with a hypesquad event NONE \u00b6 PARTNERED_SERVER_OWNER \u00b6 User owns a partnered server TEAM_USER \u00b6 A team user VERIFIED_BOT \u00b6 This bot has been verified by Discord ApplicationFlags ( DiscordIntFlag ) \u00b6 Flags an application can have Source code in dis_snek/models/enums.py class ApplicationFlags ( DiscordIntFlag ): # type: ignore \"\"\"Flags an application can have\"\"\" # Flags defined by the Discord API GATEWAY_PRESENCE = 1 << 12 \"\"\"Verified to use presence intent\"\"\" GATEWAY_PRESENCE_LIMITED = 1 << 13 \"\"\"Using presence intent, without verification\"\"\" GATEWAY_GUILD_MEMBERS = 1 << 14 \"\"\"Verified to use guild members intent\"\"\" GATEWAY_GUILD_MEMBERS_LIMITED = 1 << 15 \"\"\"Using members intent, without verification\"\"\" VERIFICATION_PENDING_GUILD_LIMIT = 1 << 16 \"\"\"Bot has hit guild limit, and has not been successfully verified\"\"\" EMBEDDED = 1 << 17 \"\"\"Application is a voice channel activity (ie YouTube Together)\"\"\" EMBEDDED \u00b6 Application is a voice channel activity (ie YouTube Together) GATEWAY_GUILD_MEMBERS \u00b6 Verified to use guild members intent GATEWAY_GUILD_MEMBERS_LIMITED \u00b6 Using members intent, without verification GATEWAY_PRESENCE \u00b6 Verified to use presence intent GATEWAY_PRESENCE_LIMITED \u00b6 Using presence intent, without verification VERIFICATION_PENDING_GUILD_LIMIT \u00b6 Bot has hit guild limit, and has not been successfully verified TeamMembershipState ( IntEnum ) \u00b6 Self explanatory Source code in dis_snek/models/enums.py class TeamMembershipState ( IntEnum ): \"\"\"Self explanatory\"\"\" INVITED = 1 ACCEPTED = 2 ACCEPTED \u00b6 INVITED \u00b6 PremiumTypes ( IntEnum ) \u00b6 Types of premium membership Source code in dis_snek/models/enums.py class PremiumTypes ( IntEnum ): \"\"\"Types of premium membership\"\"\" NONE = 0 \"\"\"No premium membership\"\"\" NITRO_CLASSIC = 1 \"\"\"Using Nitro Classic\"\"\" NITRO = 2 \"\"\"Full Nitro membership\"\"\" NITRO \u00b6 Full Nitro membership NITRO_CLASSIC \u00b6 Using Nitro Classic NONE \u00b6 No premium membership MessageTypes ( IntEnum ) \u00b6 Types of message Source code in dis_snek/models/enums.py class MessageTypes ( IntEnum ): \"\"\"Types of message\"\"\" DEFAULT = 0 RECIPIENT_ADD = 1 RECIPIENT_REMOVE = 2 CALL = 3 CHANNEL_NAME_CHANGE = 4 CHANNEL_ICON_CHANGE = 5 CHANNEL_PINNED_MESSAGE = 6 GUILD_MEMBER_JOIN = 7 USER_PREMIUM_GUILD_SUBSCRIPTION = 8 USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 = 9 USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 = 10 USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 = 11 CHANNEL_FOLLOW_ADD = 12 GUILD_DISCOVERY_DISQUALIFIED = 14 GUILD_DISCOVERY_REQUALIFIED = 15 GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING = 16 GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING = 17 THREAD_CREATED = 18 REPLY = 19 APPLICATION_COMMAND = 20 THREAD_STARTER_MESSAGE = 21 GUILD_INVITE_REMINDER = 22 CONTEXT_MENU_COMMAND = 23 APPLICATION_COMMAND \u00b6 CALL \u00b6 CHANNEL_FOLLOW_ADD \u00b6 CHANNEL_ICON_CHANGE \u00b6 CHANNEL_NAME_CHANGE \u00b6 CHANNEL_PINNED_MESSAGE \u00b6 CONTEXT_MENU_COMMAND \u00b6 DEFAULT \u00b6 GUILD_DISCOVERY_DISQUALIFIED \u00b6 GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING \u00b6 GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING \u00b6 GUILD_DISCOVERY_REQUALIFIED \u00b6 GUILD_INVITE_REMINDER \u00b6 GUILD_MEMBER_JOIN \u00b6 RECIPIENT_ADD \u00b6 RECIPIENT_REMOVE \u00b6 REPLY \u00b6 THREAD_CREATED \u00b6 THREAD_STARTER_MESSAGE \u00b6 USER_PREMIUM_GUILD_SUBSCRIPTION \u00b6 USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 \u00b6 USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 \u00b6 USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 \u00b6 MessageActivityTypes ( IntEnum ) \u00b6 An activity object, similar to an embed Source code in dis_snek/models/enums.py class MessageActivityTypes ( IntEnum ): \"\"\"An activity object, similar to an embed\"\"\" JOIN = 1 \"\"\"Join the event\"\"\" SPECTATE = 2 \"\"\"Watch the event\"\"\" LISTEN = 3 \"\"\"Listen along to the event\"\"\" JOIN_REQUEST = 5 \"\"\"Asking a user to join the activity\"\"\" JOIN \u00b6 Join the event JOIN_REQUEST \u00b6 Asking a user to join the activity LISTEN \u00b6 Listen along to the event SPECTATE \u00b6 Watch the event MessageFlags ( DiscordIntFlag ) \u00b6 Message flags Source code in dis_snek/models/enums.py class MessageFlags ( DiscordIntFlag ): # type: ignore \"\"\"Message flags\"\"\" CROSSPOSTED = 1 << 0 IS_CROSSPOST = 1 << 1 SUPPRESS_EMBEDS = 1 << 2 SOURCE_MESSAGE_DELETED = 1 << 3 URGENT = 1 << 4 HAS_THREAD = 1 << 5 EPHEMERAL = 1 << 6 LOADING = 1 << 7 # Special members NONE = 0 ALL = AntiFlag () CROSSPOSTED \u00b6 EPHEMERAL \u00b6 HAS_THREAD \u00b6 IS_CROSSPOST \u00b6 LOADING \u00b6 NONE \u00b6 SOURCE_MESSAGE_DELETED \u00b6 SUPPRESS_EMBEDS \u00b6 URGENT \u00b6 Permissions ( DiscordIntFlag ) \u00b6 Permissions a user or role may have Source code in dis_snek/models/enums.py class Permissions ( DiscordIntFlag ): # type: ignore \"\"\"Permissions a user or role may have\"\"\" # Permissions defined by Discord API CREATE_INSTANT_INVITE = 1 << 0 KICK_MEMBERS = 1 << 1 BAN_MEMBERS = 1 << 2 ADMINISTRATOR = 1 << 3 MANAGE_CHANNELS = 1 << 4 MANAGE_GUILD = 1 << 5 ADD_REACTIONS = 1 << 6 VIEW_AUDIT_LOG = 1 << 7 PRIORITY_SPEAKER = 1 << 8 STREAM = 1 << 9 VIEW_CHANNEL = 1 << 10 SEND_MESSAGES = 1 << 11 SEND_TTS_MESSAGES = 1 << 12 MANAGE_MESSAGES = 1 << 13 EMBED_LINKS = 1 << 14 ATTACH_FILES = 1 << 15 READ_MESSAGE_HISTORY = 1 << 16 MENTION_EVERYONE = 1 << 17 USE_EXTERNAL_EMOJIS = 1 << 18 VIEW_GUILD_INSIGHTS = 1 << 19 CONNECT = 1 << 20 SPEAK = 1 << 21 MUTE_MEMBERS = 1 << 22 DEAFEN_MEMBERS = 1 << 23 MOVE_MEMBERS = 1 << 24 USE_VAD = 1 << 25 CHANGE_NICKNAME = 1 << 26 MANAGE_NICKNAMES = 1 << 27 MANAGE_ROLES = 1 << 28 MANAGE_WEBHOOKS = 1 << 29 MANAGE_EMOJIS_AND_STICKERS = 1 << 30 USE_SLASH_COMMANDS = 1 << 31 REQUEST_TO_SPEAK = 1 << 32 # This permission is under active development and may be changed or removed. MANAGE_THREADS = 1 << 34 USE_PUBLIC_THREADS = 1 << 35 USE_PRIVATE_THREADS = 1 << 36 USE_EXTERNAL_STICKERS = 1 << 37 # Shortcuts/grouping/aliases REQUIRES_MFA = ( KICK_MEMBERS | BAN_MEMBERS | ADMINISTRATOR | MANAGE_CHANNELS | MANAGE_GUILD | MANAGE_MESSAGES | MANAGE_ROLES | MANAGE_WEBHOOKS | MANAGE_EMOJIS_AND_STICKERS | MANAGE_THREADS ) # Special members NONE = 0 ALL = AntiFlag () ADD_REACTIONS \u00b6 ADMINISTRATOR \u00b6 ATTACH_FILES \u00b6 BAN_MEMBERS \u00b6 CHANGE_NICKNAME \u00b6 CONNECT \u00b6 CREATE_INSTANT_INVITE \u00b6 DEAFEN_MEMBERS \u00b6 EMBED_LINKS \u00b6 KICK_MEMBERS \u00b6 MANAGE_CHANNELS \u00b6 MANAGE_EMOJIS_AND_STICKERS \u00b6 MANAGE_GUILD \u00b6 MANAGE_MESSAGES \u00b6 MANAGE_NICKNAMES \u00b6 MANAGE_ROLES \u00b6 MANAGE_THREADS \u00b6 MANAGE_WEBHOOKS \u00b6 MENTION_EVERYONE \u00b6 MOVE_MEMBERS \u00b6 MUTE_MEMBERS \u00b6 NONE \u00b6 PRIORITY_SPEAKER \u00b6 READ_MESSAGE_HISTORY \u00b6 REQUEST_TO_SPEAK \u00b6 REQUIRES_MFA \u00b6 SEND_MESSAGES \u00b6 SEND_TTS_MESSAGES \u00b6 SPEAK \u00b6 STREAM \u00b6 USE_EXTERNAL_EMOJIS \u00b6 USE_EXTERNAL_STICKERS \u00b6 USE_PRIVATE_THREADS \u00b6 USE_PUBLIC_THREADS \u00b6 USE_SLASH_COMMANDS \u00b6 USE_VAD \u00b6 VIEW_AUDIT_LOG \u00b6 VIEW_CHANNEL \u00b6 VIEW_GUILD_INSIGHTS \u00b6 ChannelTypes ( IntEnum ) \u00b6 Types of channel Source code in dis_snek/models/enums.py class ChannelTypes ( IntEnum ): \"\"\"Types of channel\"\"\" GUILD_TEXT = 0 DM = 1 GUILD_VOICE = 2 GROUP_DM = 3 GUILD_CATEGORY = 4 GUILD_NEWS = 5 GUILD_STORE = 6 GUILD_NEWS_THREAD = 10 GUILD_PUBLIC_THREAD = 11 GUILD_PRIVATE_THREAD = 12 GUILD_STAGE_VOICE = 13 @property def guild ( self ) -> bool : return self . value not in { 1 , 3 } @property def voice ( self ) -> bool : return self . value in { 2 , 13 } DM \u00b6 GROUP_DM \u00b6 GUILD_CATEGORY \u00b6 GUILD_NEWS \u00b6 GUILD_NEWS_THREAD \u00b6 GUILD_PRIVATE_THREAD \u00b6 GUILD_PUBLIC_THREAD \u00b6 GUILD_STAGE_VOICE \u00b6 GUILD_STORE \u00b6 GUILD_TEXT \u00b6 GUILD_VOICE \u00b6 ComponentTypes ( IntEnum ) \u00b6 The types of components supported by discord Source code in dis_snek/models/enums.py class ComponentTypes ( IntEnum ): \"\"\" The types of components supported by discord \"\"\" ACTION_ROW = 1 BUTTON = 2 SELECT = 3 ACTION_ROW \u00b6 BUTTON \u00b6 SELECT \u00b6 CommandTypes ( IntEnum ) \u00b6 The interaction commands supported by discord Source code in dis_snek/models/enums.py class CommandTypes ( IntEnum ): \"\"\" The interaction commands supported by discord \"\"\" CHAT_INPUT = 1 USER = 2 MESSAGE = 3 CHAT_INPUT \u00b6 MESSAGE \u00b6 USER \u00b6 InteractionTypes ( IntEnum ) \u00b6 The type of interaction received by discord Source code in dis_snek/models/enums.py class InteractionTypes ( IntEnum ): \"\"\" The type of interaction received by discord \"\"\" PING = 1 APPLICATION_COMMAND = 2 MESSAGE_COMPONENT = 3 AUTOCOMPLETE = 4 APPLICATION_COMMAND \u00b6 AUTOCOMPLETE \u00b6 MESSAGE_COMPONENT \u00b6 PING \u00b6 ButtonStyles ( IntEnum ) \u00b6 The styles of buttons supported Source code in dis_snek/models/enums.py class ButtonStyles ( IntEnum ): \"\"\" The styles of buttons supported \"\"\" # Based on discord api PRIMARY = 1 \"\"\"blurple\"\"\" SECONDARY = 2 \"\"\"grey\"\"\" SUCCESS = 3 \"\"\"green\"\"\" DANGER = 4 \"\"\"red\"\"\" LINK = 5 \"\"\"url button\"\"\" # Aliases BLUE = 1 BLURPLE = 1 GRAY = 2 GREY = 2 GREEN = 3 RED = 4 URL = 5 DANGER \u00b6 red LINK \u00b6 url button PRIMARY \u00b6 blurple SECONDARY \u00b6 grey SUCCESS \u00b6 green MentionTypes ( str , Enum ) \u00b6 Types of mention Source code in dis_snek/models/enums.py class MentionTypes ( str , Enum ): \"\"\"Types of mention\"\"\" EVERYONE = \"everyone\" ROLES = \"roles\" USERS = \"users\" EVERYONE \u00b6 ROLES \u00b6 USERS \u00b6 OverwriteTypes ( IntEnum ) \u00b6 Types of permission overwrite Source code in dis_snek/models/enums.py class OverwriteTypes ( IntEnum ): \"\"\"Types of permission overwrite\"\"\" ROLE = 0 MEMBER = 1 MEMBER \u00b6 ROLE \u00b6 DefaultNotificationLevels ( IntEnum ) \u00b6 Default Notification levels for dms and guilds Source code in dis_snek/models/enums.py class DefaultNotificationLevels ( IntEnum ): \"\"\"Default Notification levels for dms and guilds\"\"\" ALL_MESSAGES = 0 ONLY_MENTIONS = 1 ALL_MESSAGES \u00b6 ONLY_MENTIONS \u00b6 ExplicitContentFilterLevels ( IntEnum ) \u00b6 Automatic filtering of explicit content Source code in dis_snek/models/enums.py class ExplicitContentFilterLevels ( IntEnum ): \"\"\"Automatic filtering of explicit content\"\"\" DISABLED = 0 MEMBERS_WITHOUT_ROLES = 1 ALL_MEMBERS = 2 ALL_MEMBERS \u00b6 DISABLED \u00b6 MEMBERS_WITHOUT_ROLES \u00b6 MFALevels ( IntEnum ) \u00b6 Does the user use 2FA Source code in dis_snek/models/enums.py class MFALevels ( IntEnum ): \"\"\"Does the user use 2FA\"\"\" NONE = 0 ELEVATED = 1 ELEVATED \u00b6 NONE \u00b6 VerificationLevels ( IntEnum ) \u00b6 Levels of verification needed by a guild Source code in dis_snek/models/enums.py class VerificationLevels ( IntEnum ): \"\"\"Levels of verification needed by a guild\"\"\" NONE = 0 \"\"\"No verification needed\"\"\" LOW = 1 \"\"\"Must have a verified email on their Discord Account\"\"\" MEDIUM = 2 \"\"\"Must also be registered on Discord for longer than 5 minutes\"\"\" HIGH = 3 \"\"\"Must also be a member of this server for longer than 10 minutes\"\"\" VERY_HIGH = 4 \"\"\"Must have a verified phone number on their Discord Account\"\"\" HIGH \u00b6 Must also be a member of this server for longer than 10 minutes LOW \u00b6 Must have a verified email on their Discord Account MEDIUM \u00b6 Must also be registered on Discord for longer than 5 minutes NONE \u00b6 No verification needed VERY_HIGH \u00b6 Must have a verified phone number on their Discord Account NSFWLevels ( IntEnum ) \u00b6 A guilds NSFW Level Source code in dis_snek/models/enums.py class NSFWLevels ( IntEnum ): \"\"\"A guilds NSFW Level\"\"\" DEFAULT = 0 EXPLICIT = 1 SAFE = 2 AGE_RESTRICTED = 3 AGE_RESTRICTED \u00b6 DEFAULT \u00b6 EXPLICIT \u00b6 SAFE \u00b6 PremiumTiers ( IntEnum ) \u00b6 The boost level of a server Source code in dis_snek/models/enums.py class PremiumTiers ( IntEnum ): \"\"\"The boost level of a server\"\"\" NONE = 0 TIER_1 = 1 TIER_2 = 2 TIER_3 = 3 NONE \u00b6 TIER_1 \u00b6 TIER_2 \u00b6 TIER_3 \u00b6 SystemChannelFlags ( DiscordIntFlag ) \u00b6 System channel settings Source code in dis_snek/models/enums.py class SystemChannelFlags ( DiscordIntFlag ): \"\"\"System channel settings\"\"\" SUPPRESS_JOIN_NOTIFICATIONS = 1 << 0 SUPPRESS_PREMIUM_SUBSCRIPTIONS = 1 << 1 SUPPRESS_GUILD_REMINDER_NOTIFICATIONS = 1 << 2 # Special members NONE = 0 ALL = AntiFlag () NONE \u00b6 SUPPRESS_GUILD_REMINDER_NOTIFICATIONS \u00b6 SUPPRESS_JOIN_NOTIFICATIONS \u00b6 SUPPRESS_PREMIUM_SUBSCRIPTIONS \u00b6 VideoQualityModes ( IntEnum ) \u00b6 Video quality settings Source code in dis_snek/models/enums.py class VideoQualityModes ( IntEnum ): \"\"\"Video quality settings\"\"\" AUTO = 1 FULL = 2 AUTO \u00b6 FULL \u00b6 AutoArchiveDuration ( IntEnum ) \u00b6 Thread archive duration, in minutes Source code in dis_snek/models/enums.py class AutoArchiveDuration ( IntEnum ): \"\"\"Thread archive duration, in minutes\"\"\" ONE_HOUR = 60 ONE_DAY = 1440 THREE_DAY = 4320 ONE_WEEK = 10080 ONE_DAY \u00b6 ONE_HOUR \u00b6 ONE_WEEK \u00b6 THREE_DAY \u00b6 ActivityType ( IntEnum ) \u00b6 The types of presence activity that can be used in presences Note Only GAME STREAMING AND WATCHING are usable by bots Source code in dis_snek/models/enums.py class ActivityType ( IntEnum ): \"\"\"The types of presence activity that can be used in presences !!! note Only `GAME` `STREAMING` AND `WATCHING` are usable by bots \"\"\" GAME = 0 # \"Playing Rocket League\" STREAMING = 1 # \"Streaming Rocket League\" LISTENING = 2 # \"Listening to Spotify\" WATCHING = 3 # \"Watching YouTube Together\" CUSTOM = 4 # \":smiley: I am cool\" COMPETING = 5 # \"Competing in Arena World Champions\" PLAYING = GAME COMPETING \u00b6 CUSTOM \u00b6 GAME \u00b6 LISTENING \u00b6 STREAMING \u00b6 WATCHING \u00b6 Status ( str , Enum ) \u00b6 Represents the statuses a user may have Source code in dis_snek/models/enums.py class Status ( str , Enum ): \"\"\"Represents the statuses a user may have\"\"\" ONLINE = \"online\" OFFLINE = \"offline\" DND = \"dnd\" IDLE = \"idle\" INVISIBLE = \"invisible\" AFK = IDLE DO_NOT_DISTURB = DND DND \u00b6 IDLE \u00b6 INVISIBLE \u00b6 OFFLINE \u00b6 ONLINE \u00b6 StagePrivacyLevel ( IntEnum ) \u00b6 An enumeration. Source code in dis_snek/models/enums.py class StagePrivacyLevel ( IntEnum ): PUBLIC = 1 GUILD_ONLY = 2 GUILD_ONLY \u00b6 PUBLIC \u00b6 IntegrationExpireBehaviour ( IntEnum ) \u00b6 An enumeration. Source code in dis_snek/models/enums.py class IntegrationExpireBehaviour ( IntEnum ): REMOVE_ROLE = 0 KICK = 1 KICK \u00b6 REMOVE_ROLE \u00b6","title":"Enums"},{"location":"API%20Reference/enums/#dis_snek.models.enums.AntiFlag","text":"Source code in dis_snek/models/enums.py class AntiFlag : def __init__ ( self , anti = 0 ): self . anti = anti def __get__ ( self , instance , cls ): negative = ~ cls ( self . anti ) positive = cls ( reduce ( or_ , negative )) return positive","title":"AntiFlag"},{"location":"API%20Reference/enums/#dis_snek.models.enums.DistinctFlag","text":"Source code in dis_snek/models/enums.py class DistinctFlag ( EnumMeta ): def __iter__ ( cls ): yield from _distinct ( super () . __iter__ ()) def __call__ ( cls , value , names = None , * , module = None , qualname = None , type = None , start = 1 ): # To automatically convert string values into ints (eg for permissions) return super () . __call__ ( int ( value ), names , module = module , qualname = qualname , type = type , start = start )","title":"DistinctFlag"},{"location":"API%20Reference/enums/#dis_snek.models.enums.DiscordIntFlag","text":"An enumeration. Source code in dis_snek/models/enums.py class DiscordIntFlag ( IntFlag , metaclass = DistinctFlag ): def __iter__ ( self ): yield from _decompose ( self . __class__ , self )[ 0 ]","title":"DiscordIntFlag"},{"location":"API%20Reference/enums/#dis_snek.models.enums.WebSocketOPCodes","text":"Codes used by the Gateway to signify events Source code in dis_snek/models/enums.py class WebSocketOPCodes ( IntEnum ): \"\"\"Codes used by the Gateway to signify events\"\"\" DISPATCH = 0 \"\"\"An event was dispatched\"\"\" HEARTBEAT = 1 \"\"\"Fired periodically by the client to keep the connection alive\"\"\" IDENTIFY = 2 \"\"\"Starts a new session during the initial handshake.\"\"\" PRESENCE = 3 \"\"\"Update the client's presence.\"\"\" VOICE_STATE = 4 \"\"\"Used to join/leave or move between voice channels.\"\"\" VOICE_PING = 5 RESUME = 6 \"\"\"Resume a previous session that was disconnected.\"\"\" RECONNECT = 7 \"\"\"You should attempt to reconnect and resume immediately.\"\"\" REQUEST_MEMBERS = 8 \"\"\"Request information about offline guild members in a large guild.\"\"\" INVALIDATE_SESSION = 9 \"\"\"The session has been invalidated. You should reconnect and identify/resume accordingly.\"\"\" HELLO = 10 \"\"\"Sent immediately after connecting, contains the `heartbeat_interval` to use.\"\"\" HEARTBEAT_ACK = 11 \"\"\"Sent in response to receiving a heartbeat to acknowledge that it has been received.\"\"\" GUILD_SYNC = 12","title":"WebSocketOPCodes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.Intents","text":"When identifying to the gateway, you can specify an intents parameter which allows you to conditionally subscribe to pre-defined \"intents\", groups of events defined by Discord. Info For details about what intents do, or which intents you'll want, please read the Discord API Documentation Source code in dis_snek/models/enums.py class Intents ( DiscordIntFlag ): # type: ignore \"\"\"When identifying to the gateway, you can specify an intents parameter which allows you to conditionally subscribe to pre-defined \"intents\", groups of events defined by Discord. info: For details about what intents do, or which intents you'll want, please read the [Discord API Documentation](https://discord.com/developers/docs/topics/gateway#gateway-intents)\"\"\" GUILDS = 1 << 0 GUILD_MEMBERS = 1 << 1 GUILD_BANS = 1 << 2 GUILD_EMOJIS_AND_STICKERS = 1 << 3 GUILD_INTEGRATIONS = 1 << 4 GUILD_WEBHOOKS = 1 << 5 GUILD_INVITES = 1 << 6 GUILD_VOICE_STATES = 1 << 7 GUILD_PRESENCES = 1 << 8 GUILD_MESSAGES = 1 << 9 GUILD_MESSAGE_REACTIONS = 1 << 10 GUILD_MESSAGE_TYPING = 1 << 11 DIRECT_MESSAGES = 1 << 12 DIRECT_MESSAGE_REACTIONS = 1 << 13 DIRECT_MESSAGE_TYPING = 1 << 14 # Shortcuts/grouping/aliases MESSAGES = GUILD_MESSAGES | DIRECT_MESSAGES REACTIONS = GUILD_MESSAGE_REACTIONS | DIRECT_MESSAGE_REACTIONS TYPING = GUILD_MESSAGE_TYPING | DIRECT_MESSAGE_TYPING PRIVILEGED = GUILD_PRESENCES | GUILD_MEMBERS NON_PRIVILEGED = AntiFlag ( PRIVILEGED ) DEFAULT = NON_PRIVILEGED # Special members NONE = 0 ALL = AntiFlag () @classmethod def new ( cls , guilds = False , guild_members = False , guild_bans = False , guild_emojis_and_stickers = False , guild_integrations = False , guild_webhooks = False , guild_invites = False , guild_voice_states = False , guild_presences = False , guild_messages = False , guild_message_reactions = False , guild_message_typing = False , direct_messages = False , direct_message_reactions = False , direct_message_typing = False , messages = False , reactions = False , typing = False , privileged = False , non_privileged = False , default = True , all = False , ): \"\"\" Set your desired intents \"\"\" kwargs = locals () del kwargs [ \"cls\" ] intents = cls . NONE for key in kwargs : if kwargs [ key ]: intents |= getattr ( cls , key . upper ()) return intents","title":"Intents"},{"location":"API%20Reference/enums/#dis_snek.models.enums.UserFlags","text":"Flags a user can have Source code in dis_snek/models/enums.py class UserFlags ( DiscordIntFlag ): # type: ignore \"\"\"Flags a user can have\"\"\" DISCORD_EMPLOYEE = 1 << 0 \"\"\"This person works for Discord\"\"\" PARTNERED_SERVER_OWNER = 1 << 1 \"\"\"User owns a partnered server\"\"\" HYPESQUAD_EVENTS = 1 << 2 \"\"\"User has helped with a hypesquad event\"\"\" BUG_HUNTER_LEVEL_1 = 1 << 3 \"\"\"User has passed the bug hunters quiz\"\"\" HOUSE_BRAVERY = 1 << 6 \"\"\"User belongs to the `bravery` house\"\"\" HOUSE_BRILLIANCE = 1 << 7 \"\"\"User belongs to the `brilliance` house\"\"\" HOUSE_BALANCE = 1 << 8 \"\"\"User belongs to the `balance` house\"\"\" EARLY_SUPPORTER = 1 << 9 \"\"\"This person had Nitro prior to prior to Wednesday, October 10th, 2018\"\"\" TEAM_USER = 1 << 10 \"\"\"A team user\"\"\" BUG_HUNTER_LEVEL_2 = 1 << 14 \"\"\"User is a bug hunter level 2\"\"\" VERIFIED_BOT = 1 << 16 \"\"\"This bot has been verified by Discord\"\"\" EARLY_VERIFIED_BOT_DEVELOPER = 1 << 17 \"\"\"This user was one of the first to be verified\"\"\" DISCORD_CERTIFIED_MODERATOR = 1 << 18 \"\"\"This user is a certified moderator\"\"\" # Shortcuts/grouping/aliases HYPESQUAD = HOUSE_BRAVERY | HOUSE_BRILLIANCE | HOUSE_BALANCE BUG_HUNTER = BUG_HUNTER_LEVEL_1 | BUG_HUNTER_LEVEL_2 # Special members NONE = 0 ALL = AntiFlag ()","title":"UserFlags"},{"location":"API%20Reference/enums/#dis_snek.models.enums.ApplicationFlags","text":"Flags an application can have Source code in dis_snek/models/enums.py class ApplicationFlags ( DiscordIntFlag ): # type: ignore \"\"\"Flags an application can have\"\"\" # Flags defined by the Discord API GATEWAY_PRESENCE = 1 << 12 \"\"\"Verified to use presence intent\"\"\" GATEWAY_PRESENCE_LIMITED = 1 << 13 \"\"\"Using presence intent, without verification\"\"\" GATEWAY_GUILD_MEMBERS = 1 << 14 \"\"\"Verified to use guild members intent\"\"\" GATEWAY_GUILD_MEMBERS_LIMITED = 1 << 15 \"\"\"Using members intent, without verification\"\"\" VERIFICATION_PENDING_GUILD_LIMIT = 1 << 16 \"\"\"Bot has hit guild limit, and has not been successfully verified\"\"\" EMBEDDED = 1 << 17 \"\"\"Application is a voice channel activity (ie YouTube Together)\"\"\"","title":"ApplicationFlags"},{"location":"API%20Reference/enums/#dis_snek.models.enums.TeamMembershipState","text":"Self explanatory Source code in dis_snek/models/enums.py class TeamMembershipState ( IntEnum ): \"\"\"Self explanatory\"\"\" INVITED = 1 ACCEPTED = 2","title":"TeamMembershipState"},{"location":"API%20Reference/enums/#dis_snek.models.enums.PremiumTypes","text":"Types of premium membership Source code in dis_snek/models/enums.py class PremiumTypes ( IntEnum ): \"\"\"Types of premium membership\"\"\" NONE = 0 \"\"\"No premium membership\"\"\" NITRO_CLASSIC = 1 \"\"\"Using Nitro Classic\"\"\" NITRO = 2 \"\"\"Full Nitro membership\"\"\"","title":"PremiumTypes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.MessageTypes","text":"Types of message Source code in dis_snek/models/enums.py class MessageTypes ( IntEnum ): \"\"\"Types of message\"\"\" DEFAULT = 0 RECIPIENT_ADD = 1 RECIPIENT_REMOVE = 2 CALL = 3 CHANNEL_NAME_CHANGE = 4 CHANNEL_ICON_CHANGE = 5 CHANNEL_PINNED_MESSAGE = 6 GUILD_MEMBER_JOIN = 7 USER_PREMIUM_GUILD_SUBSCRIPTION = 8 USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1 = 9 USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2 = 10 USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3 = 11 CHANNEL_FOLLOW_ADD = 12 GUILD_DISCOVERY_DISQUALIFIED = 14 GUILD_DISCOVERY_REQUALIFIED = 15 GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING = 16 GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING = 17 THREAD_CREATED = 18 REPLY = 19 APPLICATION_COMMAND = 20 THREAD_STARTER_MESSAGE = 21 GUILD_INVITE_REMINDER = 22 CONTEXT_MENU_COMMAND = 23","title":"MessageTypes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.MessageActivityTypes","text":"An activity object, similar to an embed Source code in dis_snek/models/enums.py class MessageActivityTypes ( IntEnum ): \"\"\"An activity object, similar to an embed\"\"\" JOIN = 1 \"\"\"Join the event\"\"\" SPECTATE = 2 \"\"\"Watch the event\"\"\" LISTEN = 3 \"\"\"Listen along to the event\"\"\" JOIN_REQUEST = 5 \"\"\"Asking a user to join the activity\"\"\"","title":"MessageActivityTypes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.MessageFlags","text":"Message flags Source code in dis_snek/models/enums.py class MessageFlags ( DiscordIntFlag ): # type: ignore \"\"\"Message flags\"\"\" CROSSPOSTED = 1 << 0 IS_CROSSPOST = 1 << 1 SUPPRESS_EMBEDS = 1 << 2 SOURCE_MESSAGE_DELETED = 1 << 3 URGENT = 1 << 4 HAS_THREAD = 1 << 5 EPHEMERAL = 1 << 6 LOADING = 1 << 7 # Special members NONE = 0 ALL = AntiFlag ()","title":"MessageFlags"},{"location":"API%20Reference/enums/#dis_snek.models.enums.Permissions","text":"Permissions a user or role may have Source code in dis_snek/models/enums.py class Permissions ( DiscordIntFlag ): # type: ignore \"\"\"Permissions a user or role may have\"\"\" # Permissions defined by Discord API CREATE_INSTANT_INVITE = 1 << 0 KICK_MEMBERS = 1 << 1 BAN_MEMBERS = 1 << 2 ADMINISTRATOR = 1 << 3 MANAGE_CHANNELS = 1 << 4 MANAGE_GUILD = 1 << 5 ADD_REACTIONS = 1 << 6 VIEW_AUDIT_LOG = 1 << 7 PRIORITY_SPEAKER = 1 << 8 STREAM = 1 << 9 VIEW_CHANNEL = 1 << 10 SEND_MESSAGES = 1 << 11 SEND_TTS_MESSAGES = 1 << 12 MANAGE_MESSAGES = 1 << 13 EMBED_LINKS = 1 << 14 ATTACH_FILES = 1 << 15 READ_MESSAGE_HISTORY = 1 << 16 MENTION_EVERYONE = 1 << 17 USE_EXTERNAL_EMOJIS = 1 << 18 VIEW_GUILD_INSIGHTS = 1 << 19 CONNECT = 1 << 20 SPEAK = 1 << 21 MUTE_MEMBERS = 1 << 22 DEAFEN_MEMBERS = 1 << 23 MOVE_MEMBERS = 1 << 24 USE_VAD = 1 << 25 CHANGE_NICKNAME = 1 << 26 MANAGE_NICKNAMES = 1 << 27 MANAGE_ROLES = 1 << 28 MANAGE_WEBHOOKS = 1 << 29 MANAGE_EMOJIS_AND_STICKERS = 1 << 30 USE_SLASH_COMMANDS = 1 << 31 REQUEST_TO_SPEAK = 1 << 32 # This permission is under active development and may be changed or removed. MANAGE_THREADS = 1 << 34 USE_PUBLIC_THREADS = 1 << 35 USE_PRIVATE_THREADS = 1 << 36 USE_EXTERNAL_STICKERS = 1 << 37 # Shortcuts/grouping/aliases REQUIRES_MFA = ( KICK_MEMBERS | BAN_MEMBERS | ADMINISTRATOR | MANAGE_CHANNELS | MANAGE_GUILD | MANAGE_MESSAGES | MANAGE_ROLES | MANAGE_WEBHOOKS | MANAGE_EMOJIS_AND_STICKERS | MANAGE_THREADS ) # Special members NONE = 0 ALL = AntiFlag ()","title":"Permissions"},{"location":"API%20Reference/enums/#dis_snek.models.enums.ChannelTypes","text":"Types of channel Source code in dis_snek/models/enums.py class ChannelTypes ( IntEnum ): \"\"\"Types of channel\"\"\" GUILD_TEXT = 0 DM = 1 GUILD_VOICE = 2 GROUP_DM = 3 GUILD_CATEGORY = 4 GUILD_NEWS = 5 GUILD_STORE = 6 GUILD_NEWS_THREAD = 10 GUILD_PUBLIC_THREAD = 11 GUILD_PRIVATE_THREAD = 12 GUILD_STAGE_VOICE = 13 @property def guild ( self ) -> bool : return self . value not in { 1 , 3 } @property def voice ( self ) -> bool : return self . value in { 2 , 13 }","title":"ChannelTypes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.ComponentTypes","text":"The types of components supported by discord Source code in dis_snek/models/enums.py class ComponentTypes ( IntEnum ): \"\"\" The types of components supported by discord \"\"\" ACTION_ROW = 1 BUTTON = 2 SELECT = 3","title":"ComponentTypes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.CommandTypes","text":"The interaction commands supported by discord Source code in dis_snek/models/enums.py class CommandTypes ( IntEnum ): \"\"\" The interaction commands supported by discord \"\"\" CHAT_INPUT = 1 USER = 2 MESSAGE = 3","title":"CommandTypes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.InteractionTypes","text":"The type of interaction received by discord Source code in dis_snek/models/enums.py class InteractionTypes ( IntEnum ): \"\"\" The type of interaction received by discord \"\"\" PING = 1 APPLICATION_COMMAND = 2 MESSAGE_COMPONENT = 3 AUTOCOMPLETE = 4","title":"InteractionTypes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.ButtonStyles","text":"The styles of buttons supported Source code in dis_snek/models/enums.py class ButtonStyles ( IntEnum ): \"\"\" The styles of buttons supported \"\"\" # Based on discord api PRIMARY = 1 \"\"\"blurple\"\"\" SECONDARY = 2 \"\"\"grey\"\"\" SUCCESS = 3 \"\"\"green\"\"\" DANGER = 4 \"\"\"red\"\"\" LINK = 5 \"\"\"url button\"\"\" # Aliases BLUE = 1 BLURPLE = 1 GRAY = 2 GREY = 2 GREEN = 3 RED = 4 URL = 5","title":"ButtonStyles"},{"location":"API%20Reference/enums/#dis_snek.models.enums.MentionTypes","text":"Types of mention Source code in dis_snek/models/enums.py class MentionTypes ( str , Enum ): \"\"\"Types of mention\"\"\" EVERYONE = \"everyone\" ROLES = \"roles\" USERS = \"users\"","title":"MentionTypes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.OverwriteTypes","text":"Types of permission overwrite Source code in dis_snek/models/enums.py class OverwriteTypes ( IntEnum ): \"\"\"Types of permission overwrite\"\"\" ROLE = 0 MEMBER = 1","title":"OverwriteTypes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.DefaultNotificationLevels","text":"Default Notification levels for dms and guilds Source code in dis_snek/models/enums.py class DefaultNotificationLevels ( IntEnum ): \"\"\"Default Notification levels for dms and guilds\"\"\" ALL_MESSAGES = 0 ONLY_MENTIONS = 1","title":"DefaultNotificationLevels"},{"location":"API%20Reference/enums/#dis_snek.models.enums.ExplicitContentFilterLevels","text":"Automatic filtering of explicit content Source code in dis_snek/models/enums.py class ExplicitContentFilterLevels ( IntEnum ): \"\"\"Automatic filtering of explicit content\"\"\" DISABLED = 0 MEMBERS_WITHOUT_ROLES = 1 ALL_MEMBERS = 2","title":"ExplicitContentFilterLevels"},{"location":"API%20Reference/enums/#dis_snek.models.enums.MFALevels","text":"Does the user use 2FA Source code in dis_snek/models/enums.py class MFALevels ( IntEnum ): \"\"\"Does the user use 2FA\"\"\" NONE = 0 ELEVATED = 1","title":"MFALevels"},{"location":"API%20Reference/enums/#dis_snek.models.enums.VerificationLevels","text":"Levels of verification needed by a guild Source code in dis_snek/models/enums.py class VerificationLevels ( IntEnum ): \"\"\"Levels of verification needed by a guild\"\"\" NONE = 0 \"\"\"No verification needed\"\"\" LOW = 1 \"\"\"Must have a verified email on their Discord Account\"\"\" MEDIUM = 2 \"\"\"Must also be registered on Discord for longer than 5 minutes\"\"\" HIGH = 3 \"\"\"Must also be a member of this server for longer than 10 minutes\"\"\" VERY_HIGH = 4 \"\"\"Must have a verified phone number on their Discord Account\"\"\"","title":"VerificationLevels"},{"location":"API%20Reference/enums/#dis_snek.models.enums.NSFWLevels","text":"A guilds NSFW Level Source code in dis_snek/models/enums.py class NSFWLevels ( IntEnum ): \"\"\"A guilds NSFW Level\"\"\" DEFAULT = 0 EXPLICIT = 1 SAFE = 2 AGE_RESTRICTED = 3","title":"NSFWLevels"},{"location":"API%20Reference/enums/#dis_snek.models.enums.PremiumTiers","text":"The boost level of a server Source code in dis_snek/models/enums.py class PremiumTiers ( IntEnum ): \"\"\"The boost level of a server\"\"\" NONE = 0 TIER_1 = 1 TIER_2 = 2 TIER_3 = 3","title":"PremiumTiers"},{"location":"API%20Reference/enums/#dis_snek.models.enums.SystemChannelFlags","text":"System channel settings Source code in dis_snek/models/enums.py class SystemChannelFlags ( DiscordIntFlag ): \"\"\"System channel settings\"\"\" SUPPRESS_JOIN_NOTIFICATIONS = 1 << 0 SUPPRESS_PREMIUM_SUBSCRIPTIONS = 1 << 1 SUPPRESS_GUILD_REMINDER_NOTIFICATIONS = 1 << 2 # Special members NONE = 0 ALL = AntiFlag ()","title":"SystemChannelFlags"},{"location":"API%20Reference/enums/#dis_snek.models.enums.VideoQualityModes","text":"Video quality settings Source code in dis_snek/models/enums.py class VideoQualityModes ( IntEnum ): \"\"\"Video quality settings\"\"\" AUTO = 1 FULL = 2","title":"VideoQualityModes"},{"location":"API%20Reference/enums/#dis_snek.models.enums.AutoArchiveDuration","text":"Thread archive duration, in minutes Source code in dis_snek/models/enums.py class AutoArchiveDuration ( IntEnum ): \"\"\"Thread archive duration, in minutes\"\"\" ONE_HOUR = 60 ONE_DAY = 1440 THREE_DAY = 4320 ONE_WEEK = 10080","title":"AutoArchiveDuration"},{"location":"API%20Reference/enums/#dis_snek.models.enums.ActivityType","text":"The types of presence activity that can be used in presences Note Only GAME STREAMING AND WATCHING are usable by bots Source code in dis_snek/models/enums.py class ActivityType ( IntEnum ): \"\"\"The types of presence activity that can be used in presences !!! note Only `GAME` `STREAMING` AND `WATCHING` are usable by bots \"\"\" GAME = 0 # \"Playing Rocket League\" STREAMING = 1 # \"Streaming Rocket League\" LISTENING = 2 # \"Listening to Spotify\" WATCHING = 3 # \"Watching YouTube Together\" CUSTOM = 4 # \":smiley: I am cool\" COMPETING = 5 # \"Competing in Arena World Champions\" PLAYING = GAME","title":"ActivityType"},{"location":"API%20Reference/enums/#dis_snek.models.enums.Status","text":"Represents the statuses a user may have Source code in dis_snek/models/enums.py class Status ( str , Enum ): \"\"\"Represents the statuses a user may have\"\"\" ONLINE = \"online\" OFFLINE = \"offline\" DND = \"dnd\" IDLE = \"idle\" INVISIBLE = \"invisible\" AFK = IDLE DO_NOT_DISTURB = DND","title":"Status"},{"location":"API%20Reference/enums/#dis_snek.models.enums.StagePrivacyLevel","text":"An enumeration. Source code in dis_snek/models/enums.py class StagePrivacyLevel ( IntEnum ): PUBLIC = 1 GUILD_ONLY = 2","title":"StagePrivacyLevel"},{"location":"API%20Reference/enums/#dis_snek.models.enums.IntegrationExpireBehaviour","text":"An enumeration. Source code in dis_snek/models/enums.py class IntegrationExpireBehaviour ( IntEnum ): REMOVE_ROLE = 0 KICK = 1","title":"IntegrationExpireBehaviour"},{"location":"API%20Reference/exceptions/","text":"SnakeException ( Exception ) \u00b6 Base Exception of discord-snakes BotException ( SnakeException ) \u00b6 An issue occurred in the client, likely user error GatewayNotFound ( SnakeException ) \u00b6 An exception that is raised when the gateway for Discord could not be found LoginError ( BotException ) \u00b6 The bot failed to login, check your token HTTPException ( SnakeException ) \u00b6 A HTTP request resulted in an exception Attributes: Name Type Description response aiohttp.ClientResponse The response of the HTTP request text str The text of the exception, could be None status int The HTTP status code code int The discord error code, if one is provided route Route The HTTP route that was used DiscordError ( HTTPException ) \u00b6 A discord-side error BadRequest ( HTTPException ) \u00b6 A bad request was made Forbidden ( HTTPException ) \u00b6 You do not have access to this NotFound ( HTTPException ) \u00b6 This resource could not be found RateLimited ( HTTPException ) \u00b6 Discord is rate limiting this application TooManyChanges ( SnakeException ) \u00b6 You have changed something too frequently WebSocketClosed ( SnakeException ) \u00b6 The websocket was closed WebSocketRestart ( SnakeException ) \u00b6 The websocket closed, and is safe to restart ExtensionException ( BotException ) \u00b6 An error occurred with an extension ExtensionNotFound ( ExtensionException ) \u00b6 The desired extension was not found ExtensionLoadException ( ExtensionException ) \u00b6 An error occurred loading an extension ScaleLoadException ( ExtensionLoadException ) \u00b6 A scale failed to load CommandException ( BotException ) \u00b6 An error occurred trying to execute a command CommandOnCooldown ( CommandException ) \u00b6 A command is on cooldown, and was attempted to be executed Attributes: Name Type Description command BaseCommand The command that is on cooldown cooldown CooldownSystem The cooldown system MaxConcurrencyReached ( CommandException ) \u00b6 A command has exhausted the max concurrent requests. CommandCheckFailure ( CommandException ) \u00b6 A command check failed Attributes: Name Type Description command BaseCommand The command that's check failed check Callable[..., Coroutine] The check that failed MessageException ( BotException ) \u00b6 A message operation encountered an exception. EphemeralEditException ( MessageException ) \u00b6 Your bot attempted to edit an ephemeral message. This is not possible. Its worth noting you can edit an ephemeral message with component's edit_origin method ThreadException ( BotException ) \u00b6 A thread operation encountered an exception. ThreadOutsideOfGuild ( ThreadException ) \u00b6 A thread was attempted to be created outside of a guild. InteractionException ( BotException ) \u00b6 An error occurred with an interaction InteractionMissingAccess ( InteractionException ) \u00b6 The bot does not have access to the specified scope","title":"Exceptions"},{"location":"API%20Reference/exceptions/#dis_snek.errors.SnakeException","text":"Base Exception of discord-snakes","title":"SnakeException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.BotException","text":"An issue occurred in the client, likely user error","title":"BotException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.GatewayNotFound","text":"An exception that is raised when the gateway for Discord could not be found","title":"GatewayNotFound"},{"location":"API%20Reference/exceptions/#dis_snek.errors.LoginError","text":"The bot failed to login, check your token","title":"LoginError"},{"location":"API%20Reference/exceptions/#dis_snek.errors.HTTPException","text":"A HTTP request resulted in an exception Attributes: Name Type Description response aiohttp.ClientResponse The response of the HTTP request text str The text of the exception, could be None status int The HTTP status code code int The discord error code, if one is provided route Route The HTTP route that was used","title":"HTTPException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.DiscordError","text":"A discord-side error","title":"DiscordError"},{"location":"API%20Reference/exceptions/#dis_snek.errors.BadRequest","text":"A bad request was made","title":"BadRequest"},{"location":"API%20Reference/exceptions/#dis_snek.errors.Forbidden","text":"You do not have access to this","title":"Forbidden"},{"location":"API%20Reference/exceptions/#dis_snek.errors.NotFound","text":"This resource could not be found","title":"NotFound"},{"location":"API%20Reference/exceptions/#dis_snek.errors.RateLimited","text":"Discord is rate limiting this application","title":"RateLimited"},{"location":"API%20Reference/exceptions/#dis_snek.errors.TooManyChanges","text":"You have changed something too frequently","title":"TooManyChanges"},{"location":"API%20Reference/exceptions/#dis_snek.errors.WebSocketClosed","text":"The websocket was closed","title":"WebSocketClosed"},{"location":"API%20Reference/exceptions/#dis_snek.errors.WebSocketRestart","text":"The websocket closed, and is safe to restart","title":"WebSocketRestart"},{"location":"API%20Reference/exceptions/#dis_snek.errors.ExtensionException","text":"An error occurred with an extension","title":"ExtensionException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.ExtensionNotFound","text":"The desired extension was not found","title":"ExtensionNotFound"},{"location":"API%20Reference/exceptions/#dis_snek.errors.ExtensionLoadException","text":"An error occurred loading an extension","title":"ExtensionLoadException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.ScaleLoadException","text":"A scale failed to load","title":"ScaleLoadException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.CommandException","text":"An error occurred trying to execute a command","title":"CommandException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.CommandOnCooldown","text":"A command is on cooldown, and was attempted to be executed Attributes: Name Type Description command BaseCommand The command that is on cooldown cooldown CooldownSystem The cooldown system","title":"CommandOnCooldown"},{"location":"API%20Reference/exceptions/#dis_snek.errors.MaxConcurrencyReached","text":"A command has exhausted the max concurrent requests.","title":"MaxConcurrencyReached"},{"location":"API%20Reference/exceptions/#dis_snek.errors.CommandCheckFailure","text":"A command check failed Attributes: Name Type Description command BaseCommand The command that's check failed check Callable[..., Coroutine] The check that failed","title":"CommandCheckFailure"},{"location":"API%20Reference/exceptions/#dis_snek.errors.MessageException","text":"A message operation encountered an exception.","title":"MessageException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.EphemeralEditException","text":"Your bot attempted to edit an ephemeral message. This is not possible. Its worth noting you can edit an ephemeral message with component's edit_origin method","title":"EphemeralEditException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.ThreadException","text":"A thread operation encountered an exception.","title":"ThreadException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.ThreadOutsideOfGuild","text":"A thread was attempted to be created outside of a guild.","title":"ThreadOutsideOfGuild"},{"location":"API%20Reference/exceptions/#dis_snek.errors.InteractionException","text":"An error occurred with an interaction","title":"InteractionException"},{"location":"API%20Reference/exceptions/#dis_snek.errors.InteractionMissingAccess","text":"The bot does not have access to the specified scope","title":"InteractionMissingAccess"},{"location":"API%20Reference/gateway/","text":"This file outlines the interaction between snek and Discord's Gateway API. BeeGees ( Thread ) \u00b6 Keeps the gateway connection alive. \u266b Stayin' Alive \u266b Parameters: Name Type Description Default ws WebsocketClient WebsocketClient required interval int How often to send heartbeats -- dictated by discord required Attributes: Name Type Description last_recv float When the last heartbeat was received Source code in dis_snek/gateway.py class BeeGees ( threading . Thread ): \"\"\" Keeps the gateway connection alive. \u266b Stayin' Alive \u266b Parameters: ws WebsocketClient: WebsocketClient interval int: How often to send heartbeats -- dictated by discord Attributes: last_recv: When the last heartbeat was received \"\"\" ws : Any # actually WebsocketClient, but these 2 classes reference each other so \u00af\\_(\u30c4)_/\u00af _main_thread_id : int _interval : int daemon : bool _stop_ev : threading . Event _last_ack : float _last_send : float last_recv : float heartbeat_timeout : int def __init__ ( self , ws : Any , interval : int ) -> None : self . ws = ws self . _main_thread_id = ws . thread_id self . interval = interval super () . __init__ () self . daemon = True self . _stop_ev = threading . Event () self . _last_ack = 0 self . _last_send = 0 self . _last_recv = 0 self . latency = float ( \"inf\" ) self . heartbeat_timeout = ws . _max_heartbeat_timeout def run ( self ) -> None : \"\"\"Start automatically sending heartbeats to discord.\"\"\" while not self . _stop_ev . wait ( self . interval ): data = self . get_payload () f = asyncio . run_coroutine_threadsafe ( self . ws . send_heartbeat ( data ), loop = self . ws . http . loop ) duration = 0 try : # block until sending is complete while True : try : f . result ( 10 ) break except concurrent . futures . TimeoutError : duration += 10 log . warning ( \"Heartbeat took too long\" ) except Exception : log . debug ( f \"Unable to send heartbeat for { duration } seconds. Closing\" ) self . stop () else : self . _last_send = time . perf_counter () def get_payload ( self ) -> dict : \"\"\" Get a payload representing a heartbeat. returns: representation of the heartbeat payload \"\"\" return { \"op\" : OPCODE . HEARTBEAT , \"d\" : self . ws . sequence } def stop ( self ) -> None : \"\"\"Stop sending heartbeats.\"\"\" self . _stop_ev . set () def recv ( self ) -> None : \"\"\"Log the time that the last heartbeat was received.\"\"\" self . _last_recv = time . perf_counter () def ack ( self ) -> None : \"\"\"Log discord ack the heartbeat.\"\"\" ack_time = time . perf_counter () self . _last_ack = time . perf_counter () self . latency = ack_time - self . _last_send if self . _last_send != 0 and self . latency > 10 : log . warning ( f \"Can't keep up! shard ID { 0 } websocket is { self . latency : .1f } s behind.\" ) run ( self ) \u00b6 Start automatically sending heartbeats to discord. Source code in dis_snek/gateway.py def run ( self ) -> None : \"\"\"Start automatically sending heartbeats to discord.\"\"\" while not self . _stop_ev . wait ( self . interval ): data = self . get_payload () f = asyncio . run_coroutine_threadsafe ( self . ws . send_heartbeat ( data ), loop = self . ws . http . loop ) duration = 0 try : # block until sending is complete while True : try : f . result ( 10 ) break except concurrent . futures . TimeoutError : duration += 10 log . warning ( \"Heartbeat took too long\" ) except Exception : log . debug ( f \"Unable to send heartbeat for { duration } seconds. Closing\" ) self . stop () else : self . _last_send = time . perf_counter () get_payload ( self ) \u00b6 Get a payload representing a heartbeat. Returns: Type Description dict representation of the heartbeat payload Source code in dis_snek/gateway.py def get_payload ( self ) -> dict : \"\"\" Get a payload representing a heartbeat. returns: representation of the heartbeat payload \"\"\" return { \"op\" : OPCODE . HEARTBEAT , \"d\" : self . ws . sequence } stop ( self ) \u00b6 Stop sending heartbeats. Source code in dis_snek/gateway.py def stop ( self ) -> None : \"\"\"Stop sending heartbeats.\"\"\" self . _stop_ev . set () recv ( self ) \u00b6 Log the time that the last heartbeat was received. Source code in dis_snek/gateway.py def recv ( self ) -> None : \"\"\"Log the time that the last heartbeat was received.\"\"\" self . _last_recv = time . perf_counter () ack ( self ) \u00b6 Log discord ack the heartbeat. Source code in dis_snek/gateway.py def ack ( self ) -> None : \"\"\"Log discord ack the heartbeat.\"\"\" ack_time = time . perf_counter () self . _last_ack = time . perf_counter () self . latency = ack_time - self . _last_send if self . _last_send != 0 and self . latency > 10 : log . warning ( f \"Can't keep up! shard ID { 0 } websocket is { self . latency : .1f } s behind.\" ) inherited start ( self ) \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in dis_snek/gateway.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () inherited join ( self , timeout = None ) \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in dis_snek/gateway.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) inherited property writable name \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. inherited property readonly ident \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. inherited property readonly native_id \u00b6 Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. inherited is_alive ( self ) \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in dis_snek/gateway.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped inherited property writable daemon \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. WebsocketClient \u00b6 Manages the connection to discord's websocket. Parameters: Name Type Description Default session_id Optional[int] The session_id to use, if resuming None sequence Optional[int] The sequence to use, if resuming None Attributes: Name Type Description buffer bytearray A buffer to hold incoming data until its complete compress int Should the connection be compressed intents Intents The intents used in this connection sequence Optional[int] The sequence of this connection session_id Optional[int] The session ID of this connection Source code in dis_snek/gateway.py class WebsocketClient : \"\"\" Manages the connection to discord's websocket. Parameters: session_id: The session_id to use, if resuming sequence: The sequence to use, if resuming Attributes: buffer: A buffer to hold incoming data until its complete compress: Should the connection be compressed intents: The intents used in this connection sequence: The sequence of this connection session_id: The session ID of this connection \"\"\" __slots__ = ( \"http\" , \"_gateway\" , \"ws\" , \"intents\" , \"session_id\" , \"dispatch\" , \"sequence\" , \"_keep_alive\" , \"_closed\" , \"buffer\" , \"_zlib\" , \"_max_heartbeat_timeout\" , \"thread_id\" , \"_trace\" , ) buffer : bytearray _closed : bool compress : int dispatch : Callable [ ... , Coroutine ] _gateway : str http : HTTPClient _keep_alive : Optional [ BeeGees ] _max_heartbeat_timeout : int intents : Intents sequence : Optional [ int ] session_id : Optional [ int ] thread_id : int _trace : List [ str ] ws : DiscordClientWebSocketResponse def __init__ ( self , session_id : Optional [ int ] = None , sequence : Optional [ int ] = None ) -> None : self . session_id = session_id self . sequence = sequence self . buffer = bytearray () self . _zlib = zlib . decompressobj () self . _keep_alive = MISSING self . _max_heartbeat_timeout = 120 self . thread_id = threading . get_ident () self . _trace = [] self . _closed = False @property def _loop ( self ): return asyncio . get_running_loop () @classmethod async def connect ( cls , http : HTTPClient , dispatch : Callable [ ... , Coroutine ], intents : Intents , resume : bool = False , session_id : Optional [ int ] = None , sequence : Optional [ int ] = None , presence : Optional [ dict ] = None , ): \"\"\" Connect to the discord gateway. parameters: http: The HTTPClient dispatch: A method to dispatch events intents: The intents of this bot resume: Are we attempting to resume? session_id: The session id to use, if resuming sequence: The sequence to use, if resuming \"\"\" cls . http = http cls . _gateway = await http . get_gateway () cls . intents = intents cls . dispatch = dispatch cls . presence = presence cls . ws = await cls . http . websocket_connect ( cls . _gateway ) dispatch ( events . Connect ()) if resume : return cls ( session_id , sequence ) return cls () @property def latency ( self ) -> float : \"\"\"Get the latency of the connection.\"\"\" return float ( \"inf\" ) if not self . _keep_alive else self . _keep_alive . latency async def _receive ( self ) -> None : resp = await self . ws . receive () msg = resp . data if isinstance ( resp . data , bytes ): self . buffer . extend ( msg ) if len ( msg ) < 4 or msg [ - 4 :] != b \" \\x00\\x00\\xff\\xff \" : # message isnt complete yet, wait return msg = self . _zlib . decompress ( self . buffer ) self . buffer = bytearray () msg = msg . decode ( \"utf-8\" ) if resp . type == WSMsgType . CLOSE : log . debug ( f \"Disconnecting from gateway! Reason: { resp . data } :: { resp . extra } \" ) await self . close ( msg ) return if resp . type == WSMsgType . CLOSING : return if resp . type == WSMsgType . CLOSED : raise WebSocketClosed ( 1000 ) msg = OverriddenJson . loads ( msg ) log . debug ( f \"Websocket Event: { msg } \" ) op = msg . get ( \"op\" ) data = msg . get ( \"d\" ) seq = msg . get ( \"s\" ) if seq is not None : self . sequence = seq if op != OPCODE . DISPATCH : if op == OPCODE . HELLO : interval = data [ \"heartbeat_interval\" ] / 1000 self . _keep_alive = BeeGees ( ws = self , interval = interval ) self . _loop . call_later ( interval * random . uniform ( 0 , 0.5 ), asyncio . ensure_future , self . send_heartbeat ( self . _keep_alive . get_payload ()), ) self . _keep_alive . start () if not self . session_id : await self . identify () else : await self . resume () return if op == OPCODE . HEARTBEAT : if self . _keep_alive : await self . send_json ( self . _keep_alive . get_payload ()) return if op == OPCODE . HEARTBEAT_ACK : if self . _keep_alive : self . _keep_alive . ack () return if op in ( OPCODE . INVALIDATE_SESSION , OPCODE . RECONNECT ): # session invalidated, restart log . debug ( f \"Reconnecting to discord due to opcode { op } :: { OPCODE ( op ) . name } \" ) if data is True or op == OPCODE . RECONNECT : await self . close ( code = 1001 ) raise WebSocketRestart ( True ) self . session_id = self . sequence = None log . warning ( \"Session has been invalidated\" ) await self . close ( code = 1000 ) raise WebSocketRestart else : if msg . get ( \"t\" ) == \"READY\" : self . _trace = data . get ( \"_trace\" , []) self . sequence = msg [ \"s\" ] self . session_id = data [ \"session_id\" ] log . info ( f \"Successfully connected to Gateway! Trace: { self . _trace } Session_ID: { self . session_id } \" ) self . dispatch ( events . RawGatewayEvent ( data , override_name = \"websocket_ready\" )) return else : self . dispatch ( events . RawGatewayEvent ( msg , override_name = \"raw_socket_receive\" )) self . dispatch ( events . RawGatewayEvent ( data , override_name = f \"raw_ { msg . get ( 't' ) . lower () } \" )) async def run ( self ) -> None : \"\"\"Start receiving events from the websocket.\"\"\" while not self . _closed : await self . _receive () def __del__ ( self ) -> None : if not self . _closed : self . http . loop . run_until_complete ( self . close ()) async def close ( self , code : int = 1000 ) -> None : \"\"\" Close the connection to the gateway. Parameters: code: the close code to use \"\"\" await self . ws . close ( code = code ) if isinstance ( self . _keep_alive , BeeGees ): self . _keep_alive . stop () self . _closed = True async def send ( self , data : str ) -> None : \"\"\" Send data to the gateway. Parameters: data: The data to send \"\"\" await self . ws . send_str ( data ) async def send_json ( self , data : dict ) -> None : \"\"\" Send json data to the gateway. Parameters: data: The data to send \"\"\" data = OverriddenJson . dumps ( data ) log . debug ( f \"Sending data to gateway: { data } \" ) await self . send ( data ) async def identify ( self ) -> None : \"\"\"Send an identify payload to the gateway.\"\"\" data = { \"op\" : OPCODE . IDENTIFY , \"d\" : { \"token\" : self . http . token , \"intents\" : self . intents , \"large_threshold\" : 250 , \"properties\" : { \"$os\" : sys . platform , \"$browser\" : \"dis.snek\" , \"$device\" : \"dis.snek\" }, \"presence\" : self . presence , }, \"compress\" : True , } await self . send_json ( data ) log . debug ( f \"Client has identified itself to Gateway, requesting intents: { self . intents } !\" ) async def resume ( self ) -> None : \"\"\"Send a resume payload to the gateway.\"\"\" data = { \"op\" : OPCODE . RESUME , \"d\" : { \"token\" : self . http . token , \"seq\" : self . sequence , \"session_id\" : self . session_id }, } await self . send_json ( data ) self . dispatch ( events . Resume ()) log . debug ( \"Client is attempting to resume a connection\" ) async def send_heartbeat ( self , data : dict ) -> None : \"\"\"Send a heartbeat to the gateway.\"\"\" await self . send_json ( data ) log . debug ( f \"Keeping Shard ID { 0 } alive with sequence { self . sequence } \" ) async def change_presence ( self , activity = None , status : Status = Status . ONLINE , since = None ): payload = dict_filter_none ( { \"since\" : int ( since if since else time . time () * 1000 ), \"activities\" : [ activity ] if activity else [], \"status\" : status , \"afk\" : False , } ) await self . send_json ({ \"op\" : OPCODE . PRESENCE , \"d\" : payload }) async classmethod connect ( http , dispatch , intents , resume = False , session_id = None , sequence = None , presence = None ) \u00b6 Connect to the discord gateway. Parameters: Name Type Description Default http HTTPClient The HTTPClient required dispatch Callable[..., Coroutine] A method to dispatch events required intents Intents The intents of this bot required resume bool Are we attempting to resume? False session_id Optional[int] The session id to use, if resuming None sequence Optional[int] The sequence to use, if resuming None Source code in dis_snek/gateway.py @classmethod async def connect ( cls , http : HTTPClient , dispatch : Callable [ ... , Coroutine ], intents : Intents , resume : bool = False , session_id : Optional [ int ] = None , sequence : Optional [ int ] = None , presence : Optional [ dict ] = None , ): \"\"\" Connect to the discord gateway. parameters: http: The HTTPClient dispatch: A method to dispatch events intents: The intents of this bot resume: Are we attempting to resume? session_id: The session id to use, if resuming sequence: The sequence to use, if resuming \"\"\" cls . http = http cls . _gateway = await http . get_gateway () cls . intents = intents cls . dispatch = dispatch cls . presence = presence cls . ws = await cls . http . websocket_connect ( cls . _gateway ) dispatch ( events . Connect ()) if resume : return cls ( session_id , sequence ) return cls () property readonly latency : float \u00b6 Get the latency of the connection. async run ( self ) \u00b6 Start receiving events from the websocket. Source code in dis_snek/gateway.py async def run ( self ) -> None : \"\"\"Start receiving events from the websocket.\"\"\" while not self . _closed : await self . _receive () async close ( self , code = 1000 ) \u00b6 Close the connection to the gateway. Parameters: Name Type Description Default code int the close code to use 1000 Source code in dis_snek/gateway.py async def close ( self , code : int = 1000 ) -> None : \"\"\" Close the connection to the gateway. Parameters: code: the close code to use \"\"\" await self . ws . close ( code = code ) if isinstance ( self . _keep_alive , BeeGees ): self . _keep_alive . stop () self . _closed = True async send ( self , data ) \u00b6 Send data to the gateway. Parameters: Name Type Description Default data str The data to send required Source code in dis_snek/gateway.py async def send ( self , data : str ) -> None : \"\"\" Send data to the gateway. Parameters: data: The data to send \"\"\" await self . ws . send_str ( data ) async send_json ( self , data ) \u00b6 Send json data to the gateway. Parameters: Name Type Description Default data dict The data to send required Source code in dis_snek/gateway.py async def send_json ( self , data : dict ) -> None : \"\"\" Send json data to the gateway. Parameters: data: The data to send \"\"\" data = OverriddenJson . dumps ( data ) log . debug ( f \"Sending data to gateway: { data } \" ) await self . send ( data ) async identify ( self ) \u00b6 Send an identify payload to the gateway. Source code in dis_snek/gateway.py async def identify ( self ) -> None : \"\"\"Send an identify payload to the gateway.\"\"\" data = { \"op\" : OPCODE . IDENTIFY , \"d\" : { \"token\" : self . http . token , \"intents\" : self . intents , \"large_threshold\" : 250 , \"properties\" : { \"$os\" : sys . platform , \"$browser\" : \"dis.snek\" , \"$device\" : \"dis.snek\" }, \"presence\" : self . presence , }, \"compress\" : True , } await self . send_json ( data ) log . debug ( f \"Client has identified itself to Gateway, requesting intents: { self . intents } !\" ) async resume ( self ) \u00b6 Send a resume payload to the gateway. Source code in dis_snek/gateway.py async def resume ( self ) -> None : \"\"\"Send a resume payload to the gateway.\"\"\" data = { \"op\" : OPCODE . RESUME , \"d\" : { \"token\" : self . http . token , \"seq\" : self . sequence , \"session_id\" : self . session_id }, } await self . send_json ( data ) self . dispatch ( events . Resume ()) log . debug ( \"Client is attempting to resume a connection\" ) async send_heartbeat ( self , data ) \u00b6 Send a heartbeat to the gateway. Source code in dis_snek/gateway.py async def send_heartbeat ( self , data : dict ) -> None : \"\"\"Send a heartbeat to the gateway.\"\"\" await self . send_json ( data ) log . debug ( f \"Keeping Shard ID { 0 } alive with sequence { self . sequence } \" )","title":"Gateway"},{"location":"API%20Reference/gateway/#dis_snek.gateway.BeeGees","text":"Keeps the gateway connection alive. \u266b Stayin' Alive \u266b Parameters: Name Type Description Default ws WebsocketClient WebsocketClient required interval int How often to send heartbeats -- dictated by discord required Attributes: Name Type Description last_recv float When the last heartbeat was received Source code in dis_snek/gateway.py class BeeGees ( threading . Thread ): \"\"\" Keeps the gateway connection alive. \u266b Stayin' Alive \u266b Parameters: ws WebsocketClient: WebsocketClient interval int: How often to send heartbeats -- dictated by discord Attributes: last_recv: When the last heartbeat was received \"\"\" ws : Any # actually WebsocketClient, but these 2 classes reference each other so \u00af\\_(\u30c4)_/\u00af _main_thread_id : int _interval : int daemon : bool _stop_ev : threading . Event _last_ack : float _last_send : float last_recv : float heartbeat_timeout : int def __init__ ( self , ws : Any , interval : int ) -> None : self . ws = ws self . _main_thread_id = ws . thread_id self . interval = interval super () . __init__ () self . daemon = True self . _stop_ev = threading . Event () self . _last_ack = 0 self . _last_send = 0 self . _last_recv = 0 self . latency = float ( \"inf\" ) self . heartbeat_timeout = ws . _max_heartbeat_timeout def run ( self ) -> None : \"\"\"Start automatically sending heartbeats to discord.\"\"\" while not self . _stop_ev . wait ( self . interval ): data = self . get_payload () f = asyncio . run_coroutine_threadsafe ( self . ws . send_heartbeat ( data ), loop = self . ws . http . loop ) duration = 0 try : # block until sending is complete while True : try : f . result ( 10 ) break except concurrent . futures . TimeoutError : duration += 10 log . warning ( \"Heartbeat took too long\" ) except Exception : log . debug ( f \"Unable to send heartbeat for { duration } seconds. Closing\" ) self . stop () else : self . _last_send = time . perf_counter () def get_payload ( self ) -> dict : \"\"\" Get a payload representing a heartbeat. returns: representation of the heartbeat payload \"\"\" return { \"op\" : OPCODE . HEARTBEAT , \"d\" : self . ws . sequence } def stop ( self ) -> None : \"\"\"Stop sending heartbeats.\"\"\" self . _stop_ev . set () def recv ( self ) -> None : \"\"\"Log the time that the last heartbeat was received.\"\"\" self . _last_recv = time . perf_counter () def ack ( self ) -> None : \"\"\"Log discord ack the heartbeat.\"\"\" ack_time = time . perf_counter () self . _last_ack = time . perf_counter () self . latency = ack_time - self . _last_send if self . _last_send != 0 and self . latency > 10 : log . warning ( f \"Can't keep up! shard ID { 0 } websocket is { self . latency : .1f } s behind.\" )","title":"BeeGees"},{"location":"API%20Reference/gateway/#dis_snek.gateway.WebsocketClient","text":"Manages the connection to discord's websocket. Parameters: Name Type Description Default session_id Optional[int] The session_id to use, if resuming None sequence Optional[int] The sequence to use, if resuming None Attributes: Name Type Description buffer bytearray A buffer to hold incoming data until its complete compress int Should the connection be compressed intents Intents The intents used in this connection sequence Optional[int] The sequence of this connection session_id Optional[int] The session ID of this connection Source code in dis_snek/gateway.py class WebsocketClient : \"\"\" Manages the connection to discord's websocket. Parameters: session_id: The session_id to use, if resuming sequence: The sequence to use, if resuming Attributes: buffer: A buffer to hold incoming data until its complete compress: Should the connection be compressed intents: The intents used in this connection sequence: The sequence of this connection session_id: The session ID of this connection \"\"\" __slots__ = ( \"http\" , \"_gateway\" , \"ws\" , \"intents\" , \"session_id\" , \"dispatch\" , \"sequence\" , \"_keep_alive\" , \"_closed\" , \"buffer\" , \"_zlib\" , \"_max_heartbeat_timeout\" , \"thread_id\" , \"_trace\" , ) buffer : bytearray _closed : bool compress : int dispatch : Callable [ ... , Coroutine ] _gateway : str http : HTTPClient _keep_alive : Optional [ BeeGees ] _max_heartbeat_timeout : int intents : Intents sequence : Optional [ int ] session_id : Optional [ int ] thread_id : int _trace : List [ str ] ws : DiscordClientWebSocketResponse def __init__ ( self , session_id : Optional [ int ] = None , sequence : Optional [ int ] = None ) -> None : self . session_id = session_id self . sequence = sequence self . buffer = bytearray () self . _zlib = zlib . decompressobj () self . _keep_alive = MISSING self . _max_heartbeat_timeout = 120 self . thread_id = threading . get_ident () self . _trace = [] self . _closed = False @property def _loop ( self ): return asyncio . get_running_loop () @classmethod async def connect ( cls , http : HTTPClient , dispatch : Callable [ ... , Coroutine ], intents : Intents , resume : bool = False , session_id : Optional [ int ] = None , sequence : Optional [ int ] = None , presence : Optional [ dict ] = None , ): \"\"\" Connect to the discord gateway. parameters: http: The HTTPClient dispatch: A method to dispatch events intents: The intents of this bot resume: Are we attempting to resume? session_id: The session id to use, if resuming sequence: The sequence to use, if resuming \"\"\" cls . http = http cls . _gateway = await http . get_gateway () cls . intents = intents cls . dispatch = dispatch cls . presence = presence cls . ws = await cls . http . websocket_connect ( cls . _gateway ) dispatch ( events . Connect ()) if resume : return cls ( session_id , sequence ) return cls () @property def latency ( self ) -> float : \"\"\"Get the latency of the connection.\"\"\" return float ( \"inf\" ) if not self . _keep_alive else self . _keep_alive . latency async def _receive ( self ) -> None : resp = await self . ws . receive () msg = resp . data if isinstance ( resp . data , bytes ): self . buffer . extend ( msg ) if len ( msg ) < 4 or msg [ - 4 :] != b \" \\x00\\x00\\xff\\xff \" : # message isnt complete yet, wait return msg = self . _zlib . decompress ( self . buffer ) self . buffer = bytearray () msg = msg . decode ( \"utf-8\" ) if resp . type == WSMsgType . CLOSE : log . debug ( f \"Disconnecting from gateway! Reason: { resp . data } :: { resp . extra } \" ) await self . close ( msg ) return if resp . type == WSMsgType . CLOSING : return if resp . type == WSMsgType . CLOSED : raise WebSocketClosed ( 1000 ) msg = OverriddenJson . loads ( msg ) log . debug ( f \"Websocket Event: { msg } \" ) op = msg . get ( \"op\" ) data = msg . get ( \"d\" ) seq = msg . get ( \"s\" ) if seq is not None : self . sequence = seq if op != OPCODE . DISPATCH : if op == OPCODE . HELLO : interval = data [ \"heartbeat_interval\" ] / 1000 self . _keep_alive = BeeGees ( ws = self , interval = interval ) self . _loop . call_later ( interval * random . uniform ( 0 , 0.5 ), asyncio . ensure_future , self . send_heartbeat ( self . _keep_alive . get_payload ()), ) self . _keep_alive . start () if not self . session_id : await self . identify () else : await self . resume () return if op == OPCODE . HEARTBEAT : if self . _keep_alive : await self . send_json ( self . _keep_alive . get_payload ()) return if op == OPCODE . HEARTBEAT_ACK : if self . _keep_alive : self . _keep_alive . ack () return if op in ( OPCODE . INVALIDATE_SESSION , OPCODE . RECONNECT ): # session invalidated, restart log . debug ( f \"Reconnecting to discord due to opcode { op } :: { OPCODE ( op ) . name } \" ) if data is True or op == OPCODE . RECONNECT : await self . close ( code = 1001 ) raise WebSocketRestart ( True ) self . session_id = self . sequence = None log . warning ( \"Session has been invalidated\" ) await self . close ( code = 1000 ) raise WebSocketRestart else : if msg . get ( \"t\" ) == \"READY\" : self . _trace = data . get ( \"_trace\" , []) self . sequence = msg [ \"s\" ] self . session_id = data [ \"session_id\" ] log . info ( f \"Successfully connected to Gateway! Trace: { self . _trace } Session_ID: { self . session_id } \" ) self . dispatch ( events . RawGatewayEvent ( data , override_name = \"websocket_ready\" )) return else : self . dispatch ( events . RawGatewayEvent ( msg , override_name = \"raw_socket_receive\" )) self . dispatch ( events . RawGatewayEvent ( data , override_name = f \"raw_ { msg . get ( 't' ) . lower () } \" )) async def run ( self ) -> None : \"\"\"Start receiving events from the websocket.\"\"\" while not self . _closed : await self . _receive () def __del__ ( self ) -> None : if not self . _closed : self . http . loop . run_until_complete ( self . close ()) async def close ( self , code : int = 1000 ) -> None : \"\"\" Close the connection to the gateway. Parameters: code: the close code to use \"\"\" await self . ws . close ( code = code ) if isinstance ( self . _keep_alive , BeeGees ): self . _keep_alive . stop () self . _closed = True async def send ( self , data : str ) -> None : \"\"\" Send data to the gateway. Parameters: data: The data to send \"\"\" await self . ws . send_str ( data ) async def send_json ( self , data : dict ) -> None : \"\"\" Send json data to the gateway. Parameters: data: The data to send \"\"\" data = OverriddenJson . dumps ( data ) log . debug ( f \"Sending data to gateway: { data } \" ) await self . send ( data ) async def identify ( self ) -> None : \"\"\"Send an identify payload to the gateway.\"\"\" data = { \"op\" : OPCODE . IDENTIFY , \"d\" : { \"token\" : self . http . token , \"intents\" : self . intents , \"large_threshold\" : 250 , \"properties\" : { \"$os\" : sys . platform , \"$browser\" : \"dis.snek\" , \"$device\" : \"dis.snek\" }, \"presence\" : self . presence , }, \"compress\" : True , } await self . send_json ( data ) log . debug ( f \"Client has identified itself to Gateway, requesting intents: { self . intents } !\" ) async def resume ( self ) -> None : \"\"\"Send a resume payload to the gateway.\"\"\" data = { \"op\" : OPCODE . RESUME , \"d\" : { \"token\" : self . http . token , \"seq\" : self . sequence , \"session_id\" : self . session_id }, } await self . send_json ( data ) self . dispatch ( events . Resume ()) log . debug ( \"Client is attempting to resume a connection\" ) async def send_heartbeat ( self , data : dict ) -> None : \"\"\"Send a heartbeat to the gateway.\"\"\" await self . send_json ( data ) log . debug ( f \"Keeping Shard ID { 0 } alive with sequence { self . sequence } \" ) async def change_presence ( self , activity = None , status : Status = Status . ONLINE , since = None ): payload = dict_filter_none ( { \"since\" : int ( since if since else time . time () * 1000 ), \"activities\" : [ activity ] if activity else [], \"status\" : status , \"afk\" : False , } ) await self . send_json ({ \"op\" : OPCODE . PRESENCE , \"d\" : payload })","title":"WebsocketClient"},{"location":"API%20Reference/smart_cache/","text":"create_cache ( ttl = 60 , hard_limit = 250 , soft_limit = MISSING ) \u00b6 Create a cache object based on the parameters passed. If ttl and max_values are set to None, the cache will just be a regular dict, with no culling. Parameters: Name Type Description Default ttl Optional[int] The time to live of an object in the cache 60 hard_limit Optional[int] The hard limit of values allowed to be within the cache 250 soft_limit Optional[int] The amount of values allowed before objects expire due to ttl MISSING Returns: Type Description Union[dict, dis_snek.utils.cache.TTLCache] dict or TTLCache based on parameters passed Source code in dis_snek/smart_cache.py def create_cache ( ttl : Optional [ int ] = 60 , hard_limit : Optional [ int ] = 250 , soft_limit : Optional [ int ] = MISSING ) -> Union [ dict , TTLCache ]: \"\"\" Create a cache object based on the parameters passed. If `ttl` and `max_values` are set to None, the cache will just be a regular dict, with no culling. Args: ttl: The time to live of an object in the cache hard_limit: The hard limit of values allowed to be within the cache soft_limit: The amount of values allowed before objects expire due to ttl Returns: dict or TTLCache based on parameters passed \"\"\" \"\" if ttl is None and hard_limit is None : print ( \"set to dict\" ) return dict () else : if not soft_limit : soft_limit = int ( hard_limit / 4 ) if hard_limit else 50 return TTLCache ( hard_limit = hard_limit or float ( \"inf\" ), soft_limit = soft_limit or 0 , ttl = ttl or float ( \"inf\" )) GlobalCache attrs \u00b6 Source code in dis_snek/smart_cache.py @attr . define () class GlobalCache : _client : \"Snake\" = field () # Non expiring discord objects cache user_cache : dict = field ( factory = dict ) # key: user_id member_cache : dict = field ( factory = dict ) # key: (guild_id, user_id) channel_cache : dict = field ( factory = dict ) # key: channel_id guild_cache : dict = field ( factory = dict ) # key: guild_id # Expiring discord objects cache message_cache : TTLCache = field ( factory = TTLCache ) # key: (channel_id, message_id) role_cache : TTLCache = field ( factory = TTLCache ) # key: role_id # Expiring id reference cache dm_channels : TTLCache = field ( factory = TTLCache ) # key: user_id user_guilds : TTLCache = field ( factory = TTLCache ) # key: user_id; value: set[guild_id] def __attrs_post_init__ ( self ): if isinstance ( self . message_cache , dict ): log . warning ( \"Disabling cache limits for message_cache is not recommended! This can result in very high memory usage\" ) async def get_user ( self , user_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ User ]: \"\"\" Get a user by their ID Args: user_id: The user's ID request_fallback: Should data be requested from Discord if not cached? Returns: User object if found \"\"\" user_id = to_snowflake ( user_id ) user = self . user_cache . get ( user_id ) if request_fallback and user is None : data = await self . _client . http . get_user ( user_id ) user = self . place_user_data ( data ) return user def place_user_data ( self , data : dict ) -> User : \"\"\" Take json data representing a User, process it, and cache it Args: data: json representation of user Returns: The processed User data \"\"\" user_id = to_snowflake ( data [ \"id\" ]) user = self . user_cache . get ( user_id ) if user is None : user = User . from_dict ( data , self . _client ) self . user_cache [ user_id ] = user else : user . update_from_dict ( data ) return user # Member cache methods async def get_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Member ]: \"\"\" Get a member by their guild and user IDs. Args: guild_id: The ID of the guild this user belongs to user_id: The ID of the user request_fallback: Should data be requested from Discord if not cached? Returns: Member object if found \"\"\" guild_id = to_snowflake ( guild_id ) user_id = to_snowflake ( user_id ) member = self . member_cache . get (( guild_id , user_id )) if request_fallback and member is None : data = await self . _client . http . get_member ( guild_id , user_id ) member = self . place_member_data ( guild_id , data ) return member def place_member_data ( self , guild_id : \"Snowflake_Type\" , data : dict ) -> Member : \"\"\" Take json data representing a User, process it, and cache it Args: guild_id: The ID of the guild this member belongs to data: json representation of the member Returns: The processed member \"\"\" guild_id = to_snowflake ( guild_id ) is_user = \"member\" in data user_id = to_snowflake ( data [ \"id\" ] if is_user else data [ \"user\" ][ \"id\" ]) member = self . member_cache . get (( guild_id , user_id )) if member is None : member_extra = { \"guild_id\" : guild_id } member = data [ \"member\" ] if is_user else data member . update ( member_extra ) member = Member . from_dict ( data , self . _client ) self . member_cache [( guild_id , user_id )] = member else : member . update_from_dict ( data ) self . place_user_guild ( user_id , guild_id ) return member def place_user_guild ( self , user_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" ) -> None : \"\"\" Add a guild to the list of guilds a user has joined. Args: user_id: The ID of the user guild_id: The ID of the guild to add \"\"\" user_id = to_snowflake ( user_id ) guild_id = to_snowflake ( guild_id ) if user_id == self . _client . user . id : # noinspection PyProtectedMember self . _client . user . _add_guilds ({ guild_id }) else : guilds = self . user_guilds . get ( user_id ) if guilds : guilds . add ( guild_id ) async def is_user_in_guild ( self , user_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> bool : \"\"\" Determine if a user is in a specified guild. Args: user_id: The ID of the user to check guild_id: The ID of the guild request_fallback: Should data be requested from Discord if not cached? \"\"\" user_id = to_snowflake ( user_id ) guild_id = to_snowflake ( guild_id ) # Try to get guild members list from the cache, without sending requests guild = await self . get_guild ( guild_id , request_fallback = False ) if guild and ( user_id in guild . members . ids ): return True # If no such guild in cache or member not in guild cache, try to get member directly. May send requests try : member = await self . get_member ( guild_id , user_id , request_fallback ) except ( NotFound , Forbidden ): # there is no such member in the guild (as per request) pass else : if member : return True return False async def get_user_guild_ids ( self , user_id : \"Snowflake_Type\" , calculation_fallback : bool = True , request_fallback : bool = True ) -> List [ \"Snowflake_Type\" ]: \"\"\" Get a list of IDs for the guilds a user has joined Args: user_id: The ID of the user calculation_fallback: Should we use guild caches to determine what guilds the user belongs to request_fallback: Should data be requested from Discord if not cached? Returns: A list of snowflakes for the guilds the client can see the user is within \"\"\" user_id = to_snowflake ( user_id ) guild_ids = self . user_guilds . get ( user_id ) if not guild_ids and calculation_fallback : guild_ids = [ guild_id for guild_id in self . _client . user . guilds . ids if await self . is_user_in_guild ( user_id , guild_id , request_fallback ) ] return guild_ids # Message cache methods async def get_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Message ]: \"\"\" Get a message from a channel based on their IDs Args: channel_id: The ID of the channel the message is in message_id: The ID of the message request_fallback: Should data be requested from Discord if not cached? Returns: The message if found \"\"\" channel_id = to_snowflake ( channel_id ) message_id = to_snowflake ( message_id ) message = self . message_cache . get (( channel_id , message_id )) if request_fallback and message is None : data = await self . _client . http . get_message ( channel_id , message_id ) message = self . place_message_data ( data ) return message def place_message_data ( self , data : dict ) -> Message : \"\"\" Take json data representing a message, process it, and cache it Args: data: json representation of the message Returns: The processed message \"\"\" channel_id = to_snowflake ( data [ \"channel_id\" ]) message_id = to_snowflake ( data [ \"id\" ]) message = self . message_cache . get (( channel_id , message_id )) if message is None : message = Message . from_dict ( data , self . _client ) self . message_cache [( channel_id , message_id )] = message else : message . update_from_dict ( data ) return message # Channel cache methods async def get_channel ( self , channel_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ \"TYPE_ALL_CHANNEL\" ]: \"\"\" Get a channel based on it's ID Args: channel_id: The ID of the channel request_fallback: Should data be requested from Discord if not cached? Returns: The channel if found \"\"\" channel_id = to_snowflake ( channel_id ) channel = self . channel_cache . get ( channel_id ) if request_fallback and channel is None : data = await self . _client . http . get_channel ( channel_id ) channel = self . place_channel_data ( data ) return channel def place_channel_data ( self , data : dict ) -> \"TYPE_ALL_CHANNEL\" : \"\"\" Take json data representing a channel, process it, and cache it Args: data: json representation of the channel Returns: The processed channel \"\"\" channel_id = to_snowflake ( data [ \"id\" ]) channel = self . channel_cache . get ( channel_id ) if channel is None : channel = BaseChannel . from_dict_factory ( data , self . _client ) self . channel_cache [ channel_id ] = channel else : channel . update_from_dict ( data ) return channel def place_dm_channel_id ( self , user_id , channel_id ) -> None : \"\"\" Cache that the bot is active within a DM channel. Args: user_id: The id of the user this DM channel belongs to channel_id: The id of the DM channel \"\"\" self . dm_channels [ to_snowflake ( user_id )] = to_snowflake ( channel_id ) async def get_dm_channel_id ( self , user_id ) -> \"Snowflake_Type\" : \"\"\" Get the DM channel ID for a user Args: user_id: The ID of the user \"\"\" user_id = to_snowflake ( user_id ) channel_id = self . dm_channels . get ( user_id ) if channel_id is None : data = await self . _client . http . create_dm ( user_id ) channel = self . place_channel_data ( data ) channel_id = channel . id return channel_id async def get_dm_channel ( self , user_id ) -> \"DM\" : \"\"\" Get the DM channel for a user Args: user_id: The ID of the user \"\"\" user_id = to_snowflake ( user_id ) channel_id = await self . get_dm_channel_id ( user_id ) channel = await self . get_channel ( channel_id ) return channel # Guild cache methods async def get_guild ( self , guild_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Guild ]: \"\"\" Get a guild based on it's ID Args: guild_id: The ID of the guild request_fallback: Should data be requested from Discord if not cached? Returns: The guild if found \"\"\" guild_id = to_snowflake ( guild_id ) guild = self . guild_cache . get ( guild_id ) if request_fallback and guild is None : data = await self . _client . http . get_guild ( guild_id ) guild = self . place_guild_data ( data ) return guild def place_guild_data ( self , data ) -> Guild : \"\"\" Take json data representing a guild, process it, and cache it Args: data: json representation of the guild Returns: The processed guild \"\"\" guild_id = to_snowflake ( data [ \"id\" ]) guild = self . guild_cache . get ( guild_id ) if guild is None : guild = Guild . from_dict ( data , self . _client ) self . guild_cache [ guild_id ] = guild else : guild . update_from_dict ( data ) return guild # Roles cache methods async def get_role ( self , guild_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Role ]: \"\"\" Get a role based on the guild and its own ID Args: guild_id: The ID of the guild this role belongs to role_id: The ID of the role request_fallback: Should data be requested from Discord if not cached? \"\"\" guild_id = to_snowflake ( guild_id ) role_id = to_snowflake ( role_id ) role = self . role_cache . get ( role_id ) if request_fallback and role is None : data = await self . _client . http . get_roles ( guild_id ) try : role = self . place_role_data ( guild_id , data )[ role_id ] except KeyError : return None return role def place_role_data ( self , guild_id : \"Snowflake_Type\" , data : List [ Dict [ \"Snowflake_Type\" , Any ]] ) -> Dict [ \"Snowflake_Type\" , Role ]: \"\"\" Take json data representing a role, process it, and cache it Can handle multiple roles at once Args: guild_id: The ID of the guild this role belongs to data: json representation of the role Returns: The processed role \"\"\" guild_id = to_snowflake ( guild_id ) roles = {} for role_data in data : # todo not update cache expiration order for roles role_data . update ({ \"guild_id\" : guild_id }) role_id = to_snowflake ( role_data [ \"id\" ]) role = self . role_cache . get ( role_id ) if role is None : role = Role . from_dict ( role_data , self . _client ) self . role_cache [ role_id ] = role else : role . update_from_dict ( role_data ) roles [ role_id ] = role return roles async get_user ( self , user_id , request_fallback = True ) \u00b6 Get a user by their ID Parameters: Name Type Description Default user_id Snowflake_Type The user's ID required request_fallback bool Should data be requested from Discord if not cached? True Returns: Type Description Optional[dis_snek.models.discord_objects.user.User] User object if found Source code in dis_snek/smart_cache.py async def get_user ( self , user_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ User ]: \"\"\" Get a user by their ID Args: user_id: The user's ID request_fallback: Should data be requested from Discord if not cached? Returns: User object if found \"\"\" user_id = to_snowflake ( user_id ) user = self . user_cache . get ( user_id ) if request_fallback and user is None : data = await self . _client . http . get_user ( user_id ) user = self . place_user_data ( data ) return user place_user_data ( self , data ) \u00b6 Take json data representing a User, process it, and cache it Parameters: Name Type Description Default data dict json representation of user required Returns: Type Description User The processed User data Source code in dis_snek/smart_cache.py def place_user_data ( self , data : dict ) -> User : \"\"\" Take json data representing a User, process it, and cache it Args: data: json representation of user Returns: The processed User data \"\"\" user_id = to_snowflake ( data [ \"id\" ]) user = self . user_cache . get ( user_id ) if user is None : user = User . from_dict ( data , self . _client ) self . user_cache [ user_id ] = user else : user . update_from_dict ( data ) return user async get_member ( self , guild_id , user_id , request_fallback = True ) \u00b6 Get a member by their guild and user IDs. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild this user belongs to required user_id Snowflake_Type The ID of the user required request_fallback bool Should data be requested from Discord if not cached? True Returns: Type Description Optional[dis_snek.models.discord_objects.user.Member] Member object if found Source code in dis_snek/smart_cache.py async def get_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Member ]: \"\"\" Get a member by their guild and user IDs. Args: guild_id: The ID of the guild this user belongs to user_id: The ID of the user request_fallback: Should data be requested from Discord if not cached? Returns: Member object if found \"\"\" guild_id = to_snowflake ( guild_id ) user_id = to_snowflake ( user_id ) member = self . member_cache . get (( guild_id , user_id )) if request_fallback and member is None : data = await self . _client . http . get_member ( guild_id , user_id ) member = self . place_member_data ( guild_id , data ) return member place_member_data ( self , guild_id , data ) \u00b6 Take json data representing a User, process it, and cache it Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild this member belongs to required data dict json representation of the member required Returns: Type Description Member The processed member Source code in dis_snek/smart_cache.py def place_member_data ( self , guild_id : \"Snowflake_Type\" , data : dict ) -> Member : \"\"\" Take json data representing a User, process it, and cache it Args: guild_id: The ID of the guild this member belongs to data: json representation of the member Returns: The processed member \"\"\" guild_id = to_snowflake ( guild_id ) is_user = \"member\" in data user_id = to_snowflake ( data [ \"id\" ] if is_user else data [ \"user\" ][ \"id\" ]) member = self . member_cache . get (( guild_id , user_id )) if member is None : member_extra = { \"guild_id\" : guild_id } member = data [ \"member\" ] if is_user else data member . update ( member_extra ) member = Member . from_dict ( data , self . _client ) self . member_cache [( guild_id , user_id )] = member else : member . update_from_dict ( data ) self . place_user_guild ( user_id , guild_id ) return member place_user_guild ( self , user_id , guild_id ) \u00b6 Add a guild to the list of guilds a user has joined. Parameters: Name Type Description Default user_id Snowflake_Type The ID of the user required guild_id Snowflake_Type The ID of the guild to add required Source code in dis_snek/smart_cache.py def place_user_guild ( self , user_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" ) -> None : \"\"\" Add a guild to the list of guilds a user has joined. Args: user_id: The ID of the user guild_id: The ID of the guild to add \"\"\" user_id = to_snowflake ( user_id ) guild_id = to_snowflake ( guild_id ) if user_id == self . _client . user . id : # noinspection PyProtectedMember self . _client . user . _add_guilds ({ guild_id }) else : guilds = self . user_guilds . get ( user_id ) if guilds : guilds . add ( guild_id ) async is_user_in_guild ( self , user_id , guild_id , request_fallback = True ) \u00b6 Determine if a user is in a specified guild. Parameters: Name Type Description Default user_id Snowflake_Type The ID of the user to check required guild_id Snowflake_Type The ID of the guild required request_fallback bool Should data be requested from Discord if not cached? True Source code in dis_snek/smart_cache.py async def is_user_in_guild ( self , user_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> bool : \"\"\" Determine if a user is in a specified guild. Args: user_id: The ID of the user to check guild_id: The ID of the guild request_fallback: Should data be requested from Discord if not cached? \"\"\" user_id = to_snowflake ( user_id ) guild_id = to_snowflake ( guild_id ) # Try to get guild members list from the cache, without sending requests guild = await self . get_guild ( guild_id , request_fallback = False ) if guild and ( user_id in guild . members . ids ): return True # If no such guild in cache or member not in guild cache, try to get member directly. May send requests try : member = await self . get_member ( guild_id , user_id , request_fallback ) except ( NotFound , Forbidden ): # there is no such member in the guild (as per request) pass else : if member : return True return False async get_user_guild_ids ( self , user_id , calculation_fallback = True , request_fallback = True ) \u00b6 Get a list of IDs for the guilds a user has joined Parameters: Name Type Description Default user_id Snowflake_Type The ID of the user required calculation_fallback bool Should we use guild caches to determine what guilds the user belongs to True request_fallback bool Should data be requested from Discord if not cached? True Returns: Type Description List[Snowflake_Type] A list of snowflakes for the guilds the client can see the user is within Source code in dis_snek/smart_cache.py async def get_user_guild_ids ( self , user_id : \"Snowflake_Type\" , calculation_fallback : bool = True , request_fallback : bool = True ) -> List [ \"Snowflake_Type\" ]: \"\"\" Get a list of IDs for the guilds a user has joined Args: user_id: The ID of the user calculation_fallback: Should we use guild caches to determine what guilds the user belongs to request_fallback: Should data be requested from Discord if not cached? Returns: A list of snowflakes for the guilds the client can see the user is within \"\"\" user_id = to_snowflake ( user_id ) guild_ids = self . user_guilds . get ( user_id ) if not guild_ids and calculation_fallback : guild_ids = [ guild_id for guild_id in self . _client . user . guilds . ids if await self . is_user_in_guild ( user_id , guild_id , request_fallback ) ] return guild_ids async get_message ( self , channel_id , message_id , request_fallback = True ) \u00b6 Get a message from a channel based on their IDs Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel the message is in required message_id Snowflake_Type The ID of the message required request_fallback bool Should data be requested from Discord if not cached? True Returns: Type Description Optional[dis_snek.models.discord_objects.message.Message] The message if found Source code in dis_snek/smart_cache.py async def get_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Message ]: \"\"\" Get a message from a channel based on their IDs Args: channel_id: The ID of the channel the message is in message_id: The ID of the message request_fallback: Should data be requested from Discord if not cached? Returns: The message if found \"\"\" channel_id = to_snowflake ( channel_id ) message_id = to_snowflake ( message_id ) message = self . message_cache . get (( channel_id , message_id )) if request_fallback and message is None : data = await self . _client . http . get_message ( channel_id , message_id ) message = self . place_message_data ( data ) return message place_message_data ( self , data ) \u00b6 Take json data representing a message, process it, and cache it Parameters: Name Type Description Default data dict json representation of the message required Returns: Type Description Message The processed message Source code in dis_snek/smart_cache.py def place_message_data ( self , data : dict ) -> Message : \"\"\" Take json data representing a message, process it, and cache it Args: data: json representation of the message Returns: The processed message \"\"\" channel_id = to_snowflake ( data [ \"channel_id\" ]) message_id = to_snowflake ( data [ \"id\" ]) message = self . message_cache . get (( channel_id , message_id )) if message is None : message = Message . from_dict ( data , self . _client ) self . message_cache [( channel_id , message_id )] = message else : message . update_from_dict ( data ) return message async get_channel ( self , channel_id , request_fallback = True ) \u00b6 Get a channel based on it's ID Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel required request_fallback bool Should data be requested from Discord if not cached? True Returns: Type Description Optional[TYPE_ALL_CHANNEL] The channel if found Source code in dis_snek/smart_cache.py async def get_channel ( self , channel_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ \"TYPE_ALL_CHANNEL\" ]: \"\"\" Get a channel based on it's ID Args: channel_id: The ID of the channel request_fallback: Should data be requested from Discord if not cached? Returns: The channel if found \"\"\" channel_id = to_snowflake ( channel_id ) channel = self . channel_cache . get ( channel_id ) if request_fallback and channel is None : data = await self . _client . http . get_channel ( channel_id ) channel = self . place_channel_data ( data ) return channel place_channel_data ( self , data ) \u00b6 Take json data representing a channel, process it, and cache it Parameters: Name Type Description Default data dict json representation of the channel required Returns: Type Description TYPE_ALL_CHANNEL The processed channel Source code in dis_snek/smart_cache.py def place_channel_data ( self , data : dict ) -> \"TYPE_ALL_CHANNEL\" : \"\"\" Take json data representing a channel, process it, and cache it Args: data: json representation of the channel Returns: The processed channel \"\"\" channel_id = to_snowflake ( data [ \"id\" ]) channel = self . channel_cache . get ( channel_id ) if channel is None : channel = BaseChannel . from_dict_factory ( data , self . _client ) self . channel_cache [ channel_id ] = channel else : channel . update_from_dict ( data ) return channel place_dm_channel_id ( self , user_id , channel_id ) \u00b6 Cache that the bot is active within a DM channel. Parameters: Name Type Description Default user_id The id of the user this DM channel belongs to required channel_id The id of the DM channel required Source code in dis_snek/smart_cache.py def place_dm_channel_id ( self , user_id , channel_id ) -> None : \"\"\" Cache that the bot is active within a DM channel. Args: user_id: The id of the user this DM channel belongs to channel_id: The id of the DM channel \"\"\" self . dm_channels [ to_snowflake ( user_id )] = to_snowflake ( channel_id ) async get_dm_channel_id ( self , user_id ) \u00b6 Get the DM channel ID for a user Parameters: Name Type Description Default user_id The ID of the user required Source code in dis_snek/smart_cache.py async def get_dm_channel_id ( self , user_id ) -> \"Snowflake_Type\" : \"\"\" Get the DM channel ID for a user Args: user_id: The ID of the user \"\"\" user_id = to_snowflake ( user_id ) channel_id = self . dm_channels . get ( user_id ) if channel_id is None : data = await self . _client . http . create_dm ( user_id ) channel = self . place_channel_data ( data ) channel_id = channel . id return channel_id async get_dm_channel ( self , user_id ) \u00b6 Get the DM channel for a user Parameters: Name Type Description Default user_id The ID of the user required Source code in dis_snek/smart_cache.py async def get_dm_channel ( self , user_id ) -> \"DM\" : \"\"\" Get the DM channel for a user Args: user_id: The ID of the user \"\"\" user_id = to_snowflake ( user_id ) channel_id = await self . get_dm_channel_id ( user_id ) channel = await self . get_channel ( channel_id ) return channel async get_guild ( self , guild_id , request_fallback = True ) \u00b6 Get a guild based on it's ID Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required request_fallback bool Should data be requested from Discord if not cached? True Returns: Type Description Optional[dis_snek.models.discord_objects.guild.Guild] The guild if found Source code in dis_snek/smart_cache.py async def get_guild ( self , guild_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Guild ]: \"\"\" Get a guild based on it's ID Args: guild_id: The ID of the guild request_fallback: Should data be requested from Discord if not cached? Returns: The guild if found \"\"\" guild_id = to_snowflake ( guild_id ) guild = self . guild_cache . get ( guild_id ) if request_fallback and guild is None : data = await self . _client . http . get_guild ( guild_id ) guild = self . place_guild_data ( data ) return guild place_guild_data ( self , data ) \u00b6 Take json data representing a guild, process it, and cache it Parameters: Name Type Description Default data json representation of the guild required Returns: Type Description Guild The processed guild Source code in dis_snek/smart_cache.py def place_guild_data ( self , data ) -> Guild : \"\"\" Take json data representing a guild, process it, and cache it Args: data: json representation of the guild Returns: The processed guild \"\"\" guild_id = to_snowflake ( data [ \"id\" ]) guild = self . guild_cache . get ( guild_id ) if guild is None : guild = Guild . from_dict ( data , self . _client ) self . guild_cache [ guild_id ] = guild else : guild . update_from_dict ( data ) return guild async get_role ( self , guild_id , role_id , request_fallback = True ) \u00b6 Get a role based on the guild and its own ID Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild this role belongs to required role_id Snowflake_Type The ID of the role required request_fallback bool Should data be requested from Discord if not cached? True Source code in dis_snek/smart_cache.py async def get_role ( self , guild_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Role ]: \"\"\" Get a role based on the guild and its own ID Args: guild_id: The ID of the guild this role belongs to role_id: The ID of the role request_fallback: Should data be requested from Discord if not cached? \"\"\" guild_id = to_snowflake ( guild_id ) role_id = to_snowflake ( role_id ) role = self . role_cache . get ( role_id ) if request_fallback and role is None : data = await self . _client . http . get_roles ( guild_id ) try : role = self . place_role_data ( guild_id , data )[ role_id ] except KeyError : return None return role place_role_data ( self , guild_id , data ) \u00b6 Take json data representing a role, process it, and cache it Can handle multiple roles at once Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild this role belongs to required data List[Dict[Snowflake_Type, Any]] json representation of the role required Returns: Type Description Dict[Snowflake_Type, dis_snek.models.discord_objects.role.Role] The processed role Source code in dis_snek/smart_cache.py def place_role_data ( self , guild_id : \"Snowflake_Type\" , data : List [ Dict [ \"Snowflake_Type\" , Any ]] ) -> Dict [ \"Snowflake_Type\" , Role ]: \"\"\" Take json data representing a role, process it, and cache it Can handle multiple roles at once Args: guild_id: The ID of the guild this role belongs to data: json representation of the role Returns: The processed role \"\"\" guild_id = to_snowflake ( guild_id ) roles = {} for role_data in data : # todo not update cache expiration order for roles role_data . update ({ \"guild_id\" : guild_id }) role_id = to_snowflake ( role_data [ \"id\" ]) role = self . role_cache . get ( role_id ) if role is None : role = Role . from_dict ( role_data , self . _client ) self . role_cache [ role_id ] = role else : role . update_from_dict ( role_data ) roles [ role_id ] = role return roles","title":"Smart cache"},{"location":"API%20Reference/smart_cache/#dis_snek.smart_cache.create_cache","text":"Create a cache object based on the parameters passed. If ttl and max_values are set to None, the cache will just be a regular dict, with no culling. Parameters: Name Type Description Default ttl Optional[int] The time to live of an object in the cache 60 hard_limit Optional[int] The hard limit of values allowed to be within the cache 250 soft_limit Optional[int] The amount of values allowed before objects expire due to ttl MISSING Returns: Type Description Union[dict, dis_snek.utils.cache.TTLCache] dict or TTLCache based on parameters passed Source code in dis_snek/smart_cache.py def create_cache ( ttl : Optional [ int ] = 60 , hard_limit : Optional [ int ] = 250 , soft_limit : Optional [ int ] = MISSING ) -> Union [ dict , TTLCache ]: \"\"\" Create a cache object based on the parameters passed. If `ttl` and `max_values` are set to None, the cache will just be a regular dict, with no culling. Args: ttl: The time to live of an object in the cache hard_limit: The hard limit of values allowed to be within the cache soft_limit: The amount of values allowed before objects expire due to ttl Returns: dict or TTLCache based on parameters passed \"\"\" \"\" if ttl is None and hard_limit is None : print ( \"set to dict\" ) return dict () else : if not soft_limit : soft_limit = int ( hard_limit / 4 ) if hard_limit else 50 return TTLCache ( hard_limit = hard_limit or float ( \"inf\" ), soft_limit = soft_limit or 0 , ttl = ttl or float ( \"inf\" ))","title":"create_cache()"},{"location":"API%20Reference/smart_cache/#dis_snek.smart_cache.GlobalCache","text":"Source code in dis_snek/smart_cache.py @attr . define () class GlobalCache : _client : \"Snake\" = field () # Non expiring discord objects cache user_cache : dict = field ( factory = dict ) # key: user_id member_cache : dict = field ( factory = dict ) # key: (guild_id, user_id) channel_cache : dict = field ( factory = dict ) # key: channel_id guild_cache : dict = field ( factory = dict ) # key: guild_id # Expiring discord objects cache message_cache : TTLCache = field ( factory = TTLCache ) # key: (channel_id, message_id) role_cache : TTLCache = field ( factory = TTLCache ) # key: role_id # Expiring id reference cache dm_channels : TTLCache = field ( factory = TTLCache ) # key: user_id user_guilds : TTLCache = field ( factory = TTLCache ) # key: user_id; value: set[guild_id] def __attrs_post_init__ ( self ): if isinstance ( self . message_cache , dict ): log . warning ( \"Disabling cache limits for message_cache is not recommended! This can result in very high memory usage\" ) async def get_user ( self , user_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ User ]: \"\"\" Get a user by their ID Args: user_id: The user's ID request_fallback: Should data be requested from Discord if not cached? Returns: User object if found \"\"\" user_id = to_snowflake ( user_id ) user = self . user_cache . get ( user_id ) if request_fallback and user is None : data = await self . _client . http . get_user ( user_id ) user = self . place_user_data ( data ) return user def place_user_data ( self , data : dict ) -> User : \"\"\" Take json data representing a User, process it, and cache it Args: data: json representation of user Returns: The processed User data \"\"\" user_id = to_snowflake ( data [ \"id\" ]) user = self . user_cache . get ( user_id ) if user is None : user = User . from_dict ( data , self . _client ) self . user_cache [ user_id ] = user else : user . update_from_dict ( data ) return user # Member cache methods async def get_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Member ]: \"\"\" Get a member by their guild and user IDs. Args: guild_id: The ID of the guild this user belongs to user_id: The ID of the user request_fallback: Should data be requested from Discord if not cached? Returns: Member object if found \"\"\" guild_id = to_snowflake ( guild_id ) user_id = to_snowflake ( user_id ) member = self . member_cache . get (( guild_id , user_id )) if request_fallback and member is None : data = await self . _client . http . get_member ( guild_id , user_id ) member = self . place_member_data ( guild_id , data ) return member def place_member_data ( self , guild_id : \"Snowflake_Type\" , data : dict ) -> Member : \"\"\" Take json data representing a User, process it, and cache it Args: guild_id: The ID of the guild this member belongs to data: json representation of the member Returns: The processed member \"\"\" guild_id = to_snowflake ( guild_id ) is_user = \"member\" in data user_id = to_snowflake ( data [ \"id\" ] if is_user else data [ \"user\" ][ \"id\" ]) member = self . member_cache . get (( guild_id , user_id )) if member is None : member_extra = { \"guild_id\" : guild_id } member = data [ \"member\" ] if is_user else data member . update ( member_extra ) member = Member . from_dict ( data , self . _client ) self . member_cache [( guild_id , user_id )] = member else : member . update_from_dict ( data ) self . place_user_guild ( user_id , guild_id ) return member def place_user_guild ( self , user_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" ) -> None : \"\"\" Add a guild to the list of guilds a user has joined. Args: user_id: The ID of the user guild_id: The ID of the guild to add \"\"\" user_id = to_snowflake ( user_id ) guild_id = to_snowflake ( guild_id ) if user_id == self . _client . user . id : # noinspection PyProtectedMember self . _client . user . _add_guilds ({ guild_id }) else : guilds = self . user_guilds . get ( user_id ) if guilds : guilds . add ( guild_id ) async def is_user_in_guild ( self , user_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> bool : \"\"\" Determine if a user is in a specified guild. Args: user_id: The ID of the user to check guild_id: The ID of the guild request_fallback: Should data be requested from Discord if not cached? \"\"\" user_id = to_snowflake ( user_id ) guild_id = to_snowflake ( guild_id ) # Try to get guild members list from the cache, without sending requests guild = await self . get_guild ( guild_id , request_fallback = False ) if guild and ( user_id in guild . members . ids ): return True # If no such guild in cache or member not in guild cache, try to get member directly. May send requests try : member = await self . get_member ( guild_id , user_id , request_fallback ) except ( NotFound , Forbidden ): # there is no such member in the guild (as per request) pass else : if member : return True return False async def get_user_guild_ids ( self , user_id : \"Snowflake_Type\" , calculation_fallback : bool = True , request_fallback : bool = True ) -> List [ \"Snowflake_Type\" ]: \"\"\" Get a list of IDs for the guilds a user has joined Args: user_id: The ID of the user calculation_fallback: Should we use guild caches to determine what guilds the user belongs to request_fallback: Should data be requested from Discord if not cached? Returns: A list of snowflakes for the guilds the client can see the user is within \"\"\" user_id = to_snowflake ( user_id ) guild_ids = self . user_guilds . get ( user_id ) if not guild_ids and calculation_fallback : guild_ids = [ guild_id for guild_id in self . _client . user . guilds . ids if await self . is_user_in_guild ( user_id , guild_id , request_fallback ) ] return guild_ids # Message cache methods async def get_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Message ]: \"\"\" Get a message from a channel based on their IDs Args: channel_id: The ID of the channel the message is in message_id: The ID of the message request_fallback: Should data be requested from Discord if not cached? Returns: The message if found \"\"\" channel_id = to_snowflake ( channel_id ) message_id = to_snowflake ( message_id ) message = self . message_cache . get (( channel_id , message_id )) if request_fallback and message is None : data = await self . _client . http . get_message ( channel_id , message_id ) message = self . place_message_data ( data ) return message def place_message_data ( self , data : dict ) -> Message : \"\"\" Take json data representing a message, process it, and cache it Args: data: json representation of the message Returns: The processed message \"\"\" channel_id = to_snowflake ( data [ \"channel_id\" ]) message_id = to_snowflake ( data [ \"id\" ]) message = self . message_cache . get (( channel_id , message_id )) if message is None : message = Message . from_dict ( data , self . _client ) self . message_cache [( channel_id , message_id )] = message else : message . update_from_dict ( data ) return message # Channel cache methods async def get_channel ( self , channel_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ \"TYPE_ALL_CHANNEL\" ]: \"\"\" Get a channel based on it's ID Args: channel_id: The ID of the channel request_fallback: Should data be requested from Discord if not cached? Returns: The channel if found \"\"\" channel_id = to_snowflake ( channel_id ) channel = self . channel_cache . get ( channel_id ) if request_fallback and channel is None : data = await self . _client . http . get_channel ( channel_id ) channel = self . place_channel_data ( data ) return channel def place_channel_data ( self , data : dict ) -> \"TYPE_ALL_CHANNEL\" : \"\"\" Take json data representing a channel, process it, and cache it Args: data: json representation of the channel Returns: The processed channel \"\"\" channel_id = to_snowflake ( data [ \"id\" ]) channel = self . channel_cache . get ( channel_id ) if channel is None : channel = BaseChannel . from_dict_factory ( data , self . _client ) self . channel_cache [ channel_id ] = channel else : channel . update_from_dict ( data ) return channel def place_dm_channel_id ( self , user_id , channel_id ) -> None : \"\"\" Cache that the bot is active within a DM channel. Args: user_id: The id of the user this DM channel belongs to channel_id: The id of the DM channel \"\"\" self . dm_channels [ to_snowflake ( user_id )] = to_snowflake ( channel_id ) async def get_dm_channel_id ( self , user_id ) -> \"Snowflake_Type\" : \"\"\" Get the DM channel ID for a user Args: user_id: The ID of the user \"\"\" user_id = to_snowflake ( user_id ) channel_id = self . dm_channels . get ( user_id ) if channel_id is None : data = await self . _client . http . create_dm ( user_id ) channel = self . place_channel_data ( data ) channel_id = channel . id return channel_id async def get_dm_channel ( self , user_id ) -> \"DM\" : \"\"\" Get the DM channel for a user Args: user_id: The ID of the user \"\"\" user_id = to_snowflake ( user_id ) channel_id = await self . get_dm_channel_id ( user_id ) channel = await self . get_channel ( channel_id ) return channel # Guild cache methods async def get_guild ( self , guild_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Guild ]: \"\"\" Get a guild based on it's ID Args: guild_id: The ID of the guild request_fallback: Should data be requested from Discord if not cached? Returns: The guild if found \"\"\" guild_id = to_snowflake ( guild_id ) guild = self . guild_cache . get ( guild_id ) if request_fallback and guild is None : data = await self . _client . http . get_guild ( guild_id ) guild = self . place_guild_data ( data ) return guild def place_guild_data ( self , data ) -> Guild : \"\"\" Take json data representing a guild, process it, and cache it Args: data: json representation of the guild Returns: The processed guild \"\"\" guild_id = to_snowflake ( data [ \"id\" ]) guild = self . guild_cache . get ( guild_id ) if guild is None : guild = Guild . from_dict ( data , self . _client ) self . guild_cache [ guild_id ] = guild else : guild . update_from_dict ( data ) return guild # Roles cache methods async def get_role ( self , guild_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , request_fallback : bool = True ) -> Optional [ Role ]: \"\"\" Get a role based on the guild and its own ID Args: guild_id: The ID of the guild this role belongs to role_id: The ID of the role request_fallback: Should data be requested from Discord if not cached? \"\"\" guild_id = to_snowflake ( guild_id ) role_id = to_snowflake ( role_id ) role = self . role_cache . get ( role_id ) if request_fallback and role is None : data = await self . _client . http . get_roles ( guild_id ) try : role = self . place_role_data ( guild_id , data )[ role_id ] except KeyError : return None return role def place_role_data ( self , guild_id : \"Snowflake_Type\" , data : List [ Dict [ \"Snowflake_Type\" , Any ]] ) -> Dict [ \"Snowflake_Type\" , Role ]: \"\"\" Take json data representing a role, process it, and cache it Can handle multiple roles at once Args: guild_id: The ID of the guild this role belongs to data: json representation of the role Returns: The processed role \"\"\" guild_id = to_snowflake ( guild_id ) roles = {} for role_data in data : # todo not update cache expiration order for roles role_data . update ({ \"guild_id\" : guild_id }) role_id = to_snowflake ( role_data [ \"id\" ]) role = self . role_cache . get ( role_id ) if role is None : role = Role . from_dict ( role_data , self . _client ) self . role_cache [ role_id ] = role else : role . update_from_dict ( role_data ) roles [ role_id ] = role return roles","title":"GlobalCache"},{"location":"API%20Reference/HTTP/HTTP_client/","text":"A http client for sending requests to the Discord API. Source code in dis_snek/http_client.py class HTTPClient ( BotRequests , ChannelRequests , EmojiRequests , GuildRequests , InteractionRequests , MemberRequests , MessageRequests , ReactionRequests , StickerRequests , ThreadRequests , UserRequests , WebhookRequests , ): \"\"\"A http client for sending requests to the Discord API.\"\"\" def __init__ ( self , connector : Optional [ BaseConnector ] = None , loop : Optional [ asyncio . AbstractEventLoop ] = None ): self . connector : Optional [ BaseConnector ] = connector self . loop = asyncio . get_event_loop () if loop is None else loop self . __session : Optional [ ClientSession ] = MISSING self . _retries : int = 5 self . token : Optional [ str ] = None self . ratelimit_locks : Dict [ str , asyncio . Lock ] = defaultdict ( asyncio . Lock ) self . user_agent : str = ( f \"DiscordBot ( { __repo_url__ } { __version__ } Python/ { __py_version__ } ) aiohttp/ { aiohttp . __version__ } \" ) def __del__ ( self ): if self . __session and not self . __session . closed : self . loop . run_until_complete ( self . __session . close ()) @staticmethod def _parse_ratelimit ( header : CIMultiDictProxy [ str ]) -> dict : \"\"\" Parse the ratelimit data into a more usable format. parameters: header: the header of the response :return: \"\"\" return { \"bucket\" : header . get ( \"x-ratelimit-bucket\" ), \"limit\" : int ( header . get ( \"x-ratelimit-limit\" ) or - 1 ), \"remaining\" : int ( header . get ( \"x-ratelimit-remaining\" ) or - 1 ), \"delta\" : float ( header . get ( \"x-ratelimit-reset-after\" , 0 )), # type: ignore \"time\" : datetime . datetime . utcfromtimestamp ( float ( header . get ( \"x-ratelimit-reset\" , 0 ))), # type: ignore } async def request ( self , route : Route , data : Union [ dict , FormData ] = MISSING , reason : str = MISSING , ** kwargs : Dict [ str , Any ] ) -> Any : \"\"\" Make a request to discord parameters: route: The route to take json: A json payload to send in the request reason: Attach a reason to this request, used for audit logs \"\"\" # Assemble headers headers : Dict [ str , str ] = { \"User-Agent\" : self . user_agent } if self . token not in ( None , MISSING ): headers [ \"Authorization\" ] = \"Bot \" + self . token if isinstance ( data , list ): headers [ \"Content-Type\" ] = \"application/json\" kwargs [ \"json\" ] = [ dict_filter_missing ( x ) if isinstance ( x , dict ) else x for x in data ] elif isinstance ( data , dict ): headers [ \"Content-Type\" ] = \"application/json\" kwargs [ \"json\" ] = dict_filter_missing ( data ) elif isinstance ( data , FormData ): kwargs [ \"data\" ] = data if reason not in ( None , MISSING ): headers [ \"X-Audit-Log-Reason\" ] = _uriquote ( reason , safe = \"/ \" ) kwargs [ \"headers\" ] = headers if route . rl_bucket is not None : lock = self . ratelimit_locks [ route . rl_bucket ] else : lock = asyncio . Lock () response : Optional [ ClientResponse ] = None result : Optional [ Union [ Dict [ str , Any ], str ]] = None await lock . acquire () for tries in range ( self . _retries ): try : if self . __session . closed : await self . login ( self . token ) async with self . __session . request ( route . method , route . url , ** kwargs ) as response : result = await response_decode ( response ) r_limit_data = self . _parse_ratelimit ( response . headers ) if response . status == 429 : # ratelimit exceeded log . error ( f \" { route . method } :: { route . url } : Has exceeded ratelimit! Reset in { r_limit_data [ 'delta' ] } seconds\" ) await asyncio . sleep ( r_limit_data [ \"delta\" ]) continue elif r_limit_data [ \"remaining\" ] == 0 : # ratelimit about to be exceeded, stop calls log . debug ( f \" { route . method } :: { route . url } : Has exhausted its ratelimit! Locking route for { r_limit_data [ 'delta' ] } seconds\" ) self . loop . call_later ( r_limit_data [ \"delta\" ], lock . release ) elif response . status in { 500 , 502 , 504 }: # server issues, retry log . warning ( f \" { route . method } :: { route . url } : Received { response . status } ... retrying in { 1 + tries * 2 } seconds\" ) await asyncio . sleep ( 1 + tries * 2 ) continue if not 300 > response . status >= 200 : if not r_limit_data [ \"remaining\" ] == 0 : lock . release () await self . _raise_exception ( response , route , result ) # Success! log . debug ( f \" { route . method } :: { route . url } : Received { response . status } , releasing\" ) if not r_limit_data [ \"remaining\" ] == 0 : lock . release () return result except OSError as e : if tries < self . _retries - 1 and e . errno in ( 54 , 10054 ): await asyncio . sleep ( 1 + tries * 2 ) continue try : lock . release () except RuntimeError : pass raise except ( Forbidden , NotFound , DiscordError , HTTPException ): raise except Exception as e : try : lock . release () except RuntimeError : pass log . error ( \"\" . join ( traceback . format_exception ( type ( e ), e , e . __traceback__ ))) break if lock . locked (): # be clean and make sure we unlock lock . release () async def _raise_exception ( self , response , route , result ): log . error ( f \" { route . method } :: { route . url } : { response . status } \" ) if response . status == 403 : raise Forbidden ( response , response_data = result , route = route ) elif response . status == 404 : raise NotFound ( response , response_data = result , route = route ) elif response . status >= 500 : raise DiscordError ( response , response_data = result , route = route ) else : raise HTTPException ( response , response_data = result , route = route ) async def request_cdn ( self , url , asset ) -> bytes : log . debug ( f \" { asset } requests { url } from CDN\" ) async with self . __session . get ( url ) as response : if response . status == 200 : return await response . read () await self . _raise_exception ( response , asset , await response_decode ( response )) async def login ( self , token : str ) -> dict : \"\"\" \"Login\" to the gateway, basically validates the token and grabs user data. parameters: token: the token to use returns: The currently logged in bot's data \"\"\" self . __session = ClientSession ( connector = self . connector , ws_response_class = DiscordClientWebSocketResponse ) self . token = token try : return await self . request ( Route ( \"GET\" , \"/users/@me\" )) except HTTPException as e : if e . status == 401 : raise LoginError ( \"An improper token was passed\" ) from e raise async def close ( self ) -> None : \"\"\"Close the session.\"\"\" if self . __session : await self . __session . close () async def get_gateway ( self ) -> str : \"\"\"Get the gateway url.\"\"\" try : data : dict = await self . request ( Route ( \"GET\" , \"/gateway\" )) except HTTPException as exc : raise GatewayNotFound from exc return \" {0} ?encoding= {1} &v=9&compress=zlib-stream\" . format ( data [ \"url\" ], \"json\" ) async def websocket_connect ( self , url : str ) -> ClientWebSocketResponse : \"\"\" Connect to the websocket. parameters: url: the url to connect to \"\"\" return await self . __session . ws_connect ( url , timeout = 30 , max_msg_size = 0 , autoclose = False , headers = { \"User-Agent\" : self . user_agent }, compress = 0 ) async request ( self , route , data = MISSING , reason = MISSING , ** kwargs ) \u00b6 Make a request to discord Parameters: Name Type Description Default route Route The route to take required json A json payload to send in the request required reason str Attach a reason to this request, used for audit logs MISSING Source code in dis_snek/http_client.py async def request ( self , route : Route , data : Union [ dict , FormData ] = MISSING , reason : str = MISSING , ** kwargs : Dict [ str , Any ] ) -> Any : \"\"\" Make a request to discord parameters: route: The route to take json: A json payload to send in the request reason: Attach a reason to this request, used for audit logs \"\"\" # Assemble headers headers : Dict [ str , str ] = { \"User-Agent\" : self . user_agent } if self . token not in ( None , MISSING ): headers [ \"Authorization\" ] = \"Bot \" + self . token if isinstance ( data , list ): headers [ \"Content-Type\" ] = \"application/json\" kwargs [ \"json\" ] = [ dict_filter_missing ( x ) if isinstance ( x , dict ) else x for x in data ] elif isinstance ( data , dict ): headers [ \"Content-Type\" ] = \"application/json\" kwargs [ \"json\" ] = dict_filter_missing ( data ) elif isinstance ( data , FormData ): kwargs [ \"data\" ] = data if reason not in ( None , MISSING ): headers [ \"X-Audit-Log-Reason\" ] = _uriquote ( reason , safe = \"/ \" ) kwargs [ \"headers\" ] = headers if route . rl_bucket is not None : lock = self . ratelimit_locks [ route . rl_bucket ] else : lock = asyncio . Lock () response : Optional [ ClientResponse ] = None result : Optional [ Union [ Dict [ str , Any ], str ]] = None await lock . acquire () for tries in range ( self . _retries ): try : if self . __session . closed : await self . login ( self . token ) async with self . __session . request ( route . method , route . url , ** kwargs ) as response : result = await response_decode ( response ) r_limit_data = self . _parse_ratelimit ( response . headers ) if response . status == 429 : # ratelimit exceeded log . error ( f \" { route . method } :: { route . url } : Has exceeded ratelimit! Reset in { r_limit_data [ 'delta' ] } seconds\" ) await asyncio . sleep ( r_limit_data [ \"delta\" ]) continue elif r_limit_data [ \"remaining\" ] == 0 : # ratelimit about to be exceeded, stop calls log . debug ( f \" { route . method } :: { route . url } : Has exhausted its ratelimit! Locking route for { r_limit_data [ 'delta' ] } seconds\" ) self . loop . call_later ( r_limit_data [ \"delta\" ], lock . release ) elif response . status in { 500 , 502 , 504 }: # server issues, retry log . warning ( f \" { route . method } :: { route . url } : Received { response . status } ... retrying in { 1 + tries * 2 } seconds\" ) await asyncio . sleep ( 1 + tries * 2 ) continue if not 300 > response . status >= 200 : if not r_limit_data [ \"remaining\" ] == 0 : lock . release () await self . _raise_exception ( response , route , result ) # Success! log . debug ( f \" { route . method } :: { route . url } : Received { response . status } , releasing\" ) if not r_limit_data [ \"remaining\" ] == 0 : lock . release () return result except OSError as e : if tries < self . _retries - 1 and e . errno in ( 54 , 10054 ): await asyncio . sleep ( 1 + tries * 2 ) continue try : lock . release () except RuntimeError : pass raise except ( Forbidden , NotFound , DiscordError , HTTPException ): raise except Exception as e : try : lock . release () except RuntimeError : pass log . error ( \"\" . join ( traceback . format_exception ( type ( e ), e , e . __traceback__ ))) break if lock . locked (): # be clean and make sure we unlock lock . release () async login ( self , token ) \u00b6 \"Login\" to the gateway, basically validates the token and grabs user data. Parameters: Name Type Description Default token str the token to use required Returns: Type Description dict The currently logged in bot's data Source code in dis_snek/http_client.py async def login ( self , token : str ) -> dict : \"\"\" \"Login\" to the gateway, basically validates the token and grabs user data. parameters: token: the token to use returns: The currently logged in bot's data \"\"\" self . __session = ClientSession ( connector = self . connector , ws_response_class = DiscordClientWebSocketResponse ) self . token = token try : return await self . request ( Route ( \"GET\" , \"/users/@me\" )) except HTTPException as e : if e . status == 401 : raise LoginError ( \"An improper token was passed\" ) from e raise async close ( self ) \u00b6 Close the session. Source code in dis_snek/http_client.py async def close ( self ) -> None : \"\"\"Close the session.\"\"\" if self . __session : await self . __session . close () async get_gateway ( self ) \u00b6 Get the gateway url. Source code in dis_snek/http_client.py async def get_gateway ( self ) -> str : \"\"\"Get the gateway url.\"\"\" try : data : dict = await self . request ( Route ( \"GET\" , \"/gateway\" )) except HTTPException as exc : raise GatewayNotFound from exc return \" {0} ?encoding= {1} &v=9&compress=zlib-stream\" . format ( data [ \"url\" ], \"json\" ) async websocket_connect ( self , url ) \u00b6 Connect to the websocket. Parameters: Name Type Description Default url str the url to connect to required Source code in dis_snek/http_client.py async def websocket_connect ( self , url : str ) -> ClientWebSocketResponse : \"\"\" Connect to the websocket. parameters: url: the url to connect to \"\"\" return await self . __session . ws_connect ( url , timeout = 30 , max_msg_size = 0 , autoclose = False , headers = { \"User-Agent\" : self . user_agent }, compress = 0 )","title":"HTTP client"},{"location":"API%20Reference/HTTP/HTTP_client/#dis_snek.http_client.HTTPClient.request","text":"Make a request to discord Parameters: Name Type Description Default route Route The route to take required json A json payload to send in the request required reason str Attach a reason to this request, used for audit logs MISSING Source code in dis_snek/http_client.py async def request ( self , route : Route , data : Union [ dict , FormData ] = MISSING , reason : str = MISSING , ** kwargs : Dict [ str , Any ] ) -> Any : \"\"\" Make a request to discord parameters: route: The route to take json: A json payload to send in the request reason: Attach a reason to this request, used for audit logs \"\"\" # Assemble headers headers : Dict [ str , str ] = { \"User-Agent\" : self . user_agent } if self . token not in ( None , MISSING ): headers [ \"Authorization\" ] = \"Bot \" + self . token if isinstance ( data , list ): headers [ \"Content-Type\" ] = \"application/json\" kwargs [ \"json\" ] = [ dict_filter_missing ( x ) if isinstance ( x , dict ) else x for x in data ] elif isinstance ( data , dict ): headers [ \"Content-Type\" ] = \"application/json\" kwargs [ \"json\" ] = dict_filter_missing ( data ) elif isinstance ( data , FormData ): kwargs [ \"data\" ] = data if reason not in ( None , MISSING ): headers [ \"X-Audit-Log-Reason\" ] = _uriquote ( reason , safe = \"/ \" ) kwargs [ \"headers\" ] = headers if route . rl_bucket is not None : lock = self . ratelimit_locks [ route . rl_bucket ] else : lock = asyncio . Lock () response : Optional [ ClientResponse ] = None result : Optional [ Union [ Dict [ str , Any ], str ]] = None await lock . acquire () for tries in range ( self . _retries ): try : if self . __session . closed : await self . login ( self . token ) async with self . __session . request ( route . method , route . url , ** kwargs ) as response : result = await response_decode ( response ) r_limit_data = self . _parse_ratelimit ( response . headers ) if response . status == 429 : # ratelimit exceeded log . error ( f \" { route . method } :: { route . url } : Has exceeded ratelimit! Reset in { r_limit_data [ 'delta' ] } seconds\" ) await asyncio . sleep ( r_limit_data [ \"delta\" ]) continue elif r_limit_data [ \"remaining\" ] == 0 : # ratelimit about to be exceeded, stop calls log . debug ( f \" { route . method } :: { route . url } : Has exhausted its ratelimit! Locking route for { r_limit_data [ 'delta' ] } seconds\" ) self . loop . call_later ( r_limit_data [ \"delta\" ], lock . release ) elif response . status in { 500 , 502 , 504 }: # server issues, retry log . warning ( f \" { route . method } :: { route . url } : Received { response . status } ... retrying in { 1 + tries * 2 } seconds\" ) await asyncio . sleep ( 1 + tries * 2 ) continue if not 300 > response . status >= 200 : if not r_limit_data [ \"remaining\" ] == 0 : lock . release () await self . _raise_exception ( response , route , result ) # Success! log . debug ( f \" { route . method } :: { route . url } : Received { response . status } , releasing\" ) if not r_limit_data [ \"remaining\" ] == 0 : lock . release () return result except OSError as e : if tries < self . _retries - 1 and e . errno in ( 54 , 10054 ): await asyncio . sleep ( 1 + tries * 2 ) continue try : lock . release () except RuntimeError : pass raise except ( Forbidden , NotFound , DiscordError , HTTPException ): raise except Exception as e : try : lock . release () except RuntimeError : pass log . error ( \"\" . join ( traceback . format_exception ( type ( e ), e , e . __traceback__ ))) break if lock . locked (): # be clean and make sure we unlock lock . release ()","title":"request()"},{"location":"API%20Reference/HTTP/HTTP_client/#dis_snek.http_client.HTTPClient.login","text":"\"Login\" to the gateway, basically validates the token and grabs user data. Parameters: Name Type Description Default token str the token to use required Returns: Type Description dict The currently logged in bot's data Source code in dis_snek/http_client.py async def login ( self , token : str ) -> dict : \"\"\" \"Login\" to the gateway, basically validates the token and grabs user data. parameters: token: the token to use returns: The currently logged in bot's data \"\"\" self . __session = ClientSession ( connector = self . connector , ws_response_class = DiscordClientWebSocketResponse ) self . token = token try : return await self . request ( Route ( \"GET\" , \"/users/@me\" )) except HTTPException as e : if e . status == 401 : raise LoginError ( \"An improper token was passed\" ) from e raise","title":"login()"},{"location":"API%20Reference/HTTP/HTTP_client/#dis_snek.http_client.HTTPClient.close","text":"Close the session. Source code in dis_snek/http_client.py async def close ( self ) -> None : \"\"\"Close the session.\"\"\" if self . __session : await self . __session . close ()","title":"close()"},{"location":"API%20Reference/HTTP/HTTP_client/#dis_snek.http_client.HTTPClient.get_gateway","text":"Get the gateway url. Source code in dis_snek/http_client.py async def get_gateway ( self ) -> str : \"\"\"Get the gateway url.\"\"\" try : data : dict = await self . request ( Route ( \"GET\" , \"/gateway\" )) except HTTPException as exc : raise GatewayNotFound from exc return \" {0} ?encoding= {1} &v=9&compress=zlib-stream\" . format ( data [ \"url\" ], \"json\" )","title":"get_gateway()"},{"location":"API%20Reference/HTTP/HTTP_client/#dis_snek.http_client.HTTPClient.websocket_connect","text":"Connect to the websocket. Parameters: Name Type Description Default url str the url to connect to required Source code in dis_snek/http_client.py async def websocket_connect ( self , url : str ) -> ClientWebSocketResponse : \"\"\" Connect to the websocket. parameters: url: the url to connect to \"\"\" return await self . __session . ws_connect ( url , timeout = 30 , max_msg_size = 0 , autoclose = False , headers = { \"User-Agent\" : self . user_agent }, compress = 0 )","title":"websocket_connect()"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/","text":"This is a list of endpoints that are supported by dis-snek. These methods are organised in sub-files of dis-snek/http_requests according to where they best fit. Note The majority of the time you should never need to interact with these. They\u2019re only documented for people contributing to dis-snek. bot \u00b6 BotRequests \u00b6 Source code in dis_snek/http_requests/bot.py class BotRequests : request : Any async def get_current_bot_information ( self ) -> dict : \"\"\" Returns the bot's application object without flags. returns: application object \"\"\" return await self . request ( Route ( \"GET\" , \"/oauth2/applications/@me\" )) async def get_current_authorisation_information ( self ) -> dict : \"\"\" Returns info about the current authorization returns: Authorisation information \"\"\" return await self . request ( Route ( \"GET\" , \"/oauth2/@me\" )) async def list_voice_regions ( self ) -> List [ dict ]: \"\"\" Returns an array of voice region objects that can be used when setting a voice or stage channel's `rtc_region`. returns: an array of voice region objects \"\"\" return await self . request ( Route ( \"GET\" , \"/voice/regions\" )) async get_current_bot_information ( self ) \u00b6 Returns the bot's application object without flags. Returns: Type Description dict application object Source code in dis_snek/http_requests/bot.py async def get_current_bot_information ( self ) -> dict : \"\"\" Returns the bot's application object without flags. returns: application object \"\"\" return await self . request ( Route ( \"GET\" , \"/oauth2/applications/@me\" )) async get_current_authorisation_information ( self ) \u00b6 Returns info about the current authorization Returns: Type Description dict Authorisation information Source code in dis_snek/http_requests/bot.py async def get_current_authorisation_information ( self ) -> dict : \"\"\" Returns info about the current authorization returns: Authorisation information \"\"\" return await self . request ( Route ( \"GET\" , \"/oauth2/@me\" )) async list_voice_regions ( self ) \u00b6 Returns an array of voice region objects that can be used when setting a voice or stage channel's rtc_region . Returns: Type Description List[dict] an array of voice region objects Source code in dis_snek/http_requests/bot.py async def list_voice_regions ( self ) -> List [ dict ]: \"\"\" Returns an array of voice region objects that can be used when setting a voice or stage channel's `rtc_region`. returns: an array of voice region objects \"\"\" return await self . request ( Route ( \"GET\" , \"/voice/regions\" )) channels \u00b6 ChannelRequests \u00b6 Source code in dis_snek/http_requests/channels.py class ChannelRequests : request : Any async def get_channel ( self , channel_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a channel by ID. Returns a channel object. If the channel is a thread, a thread member object is included. parameters: channel_id: The id of the channel returns: channel \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } \" )) async def get_channel_messages ( self , channel_id : \"Snowflake_Type\" , limit : int = 50 , around : Optional [ \"Snowflake_Type\" ] = None , before : Optional [ \"Snowflake_Type\" ] = None , after : Optional [ \"Snowflake_Type\" ] = None , ) -> List [ dict ]: \"\"\" Get the messages for a channel. parameters: channel_id: The channel to get messages from limit: How many messages to get (default 50, max 100) around: Get messages around this snowflake before: Get messages before this snowflake after: Get messages after this snowflake returns: List of message dicts \"\"\" params : Dict [ str , Union [ int , str ]] = { \"limit\" : limit } params_used = 0 if before : params_used += 1 params [ \"before\" ] = before if after : params_used += 1 params [ \"after\" ] = after if around : params_used += 1 params [ \"around\" ] = around if params_used > 1 : raise ValueError ( \"`before` `after` and `around` are mutually exclusive, only one may be passed at a time.\" ) return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /messages\" ), params = params ) async def create_guild_channel ( self , guild_id : \"Snowflake_Type\" , name : str , channel_type : Union [ \"ChannelTypes\" , int ], topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : List [ Union [ \"PermissionOverwrite\" , dict ]] = MISSING , parent_id : \"Snowflake_Type\" = MISSING , nsfw : bool = False , bitrate : int = 64000 , user_limit : int = 0 , rate_limit_per_user : int = 0 , reason : str = MISSING , ) -> Dict : \"\"\"\"\"\" payload = dict ( name = name , type = channel_type , topic = topic , position = position , rate_limit_per_user = rate_limit_per_user , nsfw = nsfw , parent_id = parent_id , permission_overwrites = permission_overwrites , ) if channel_type in ( 2 , 13 ): payload . update ( bitrate = bitrate , user_limit = user_limit , ) # clean up payload payload = dict_filter_missing ( payload ) return await self . request ( Route ( \"POST\" , f \"/guilds/ { guild_id } /channels\" ), data = payload , reason = reason ) async def move_channel ( self , guild_id : \"Snowflake_Type\" , channel_id : \"Snowflake_Type\" , new_pos : int , parent_id : \"Snowflake_Type\" = None , lock_perms : bool = False , reason : str = MISSING , ) -> None : \"\"\" Move a channel. parameters: guild_id: The ID of the guild this affects channel_id: The ID of the channel to move new_pos: The new position of this channel parent_id: The parent ID if needed lock_perms: Sync permissions with the new parent reason: An optional reason for the audit log \"\"\" payload = dict ( id = channel_id , position = new_pos , lock_permissions = lock_perms ) if parent_id : payload [ \"parent_id\" ] = parent_id return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /channels\" ), data = payload , reason = reason ) async def modify_channel ( self , channel_id : \"Snowflake_Type\" , data : dict , reason : str = MISSING ) -> dict : \"\"\" Update a channel's settings, returns the updated channel object on success. parameters: channel_id: The ID of the channel to update data: The data to update with reason: An optional reason for the audit log returns: Channel object on success \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/channels/ { channel_id } \" ), data = data , reason = reason ) async def delete_channel ( self , channel_id : \"Snowflake_Type\" , reason : str = MISSING ): \"\"\" Delete the channel parameters: channel_id: The ID of the channel to delete reason: An optional reason for the audit log \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } \" ), reason = reason ) async def get_channel_invites ( self , channel_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get the invites for the channel. parameters: channel_id: The ID of the channel to retrieve from returns: List of invite objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /invites\" )) async def create_channel_invite ( self , channel_id : \"Snowflake_Type\" , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : int = None , target_user_id : \"Snowflake_Type\" = None , target_application_id : \"Snowflake_Type\" = None , reason : str = MISSING , ) -> dict : \"\"\" Create an invite for the given channel. parameters: channel_id: The ID of the channel to create an invite for max_age: duration of invite in seconds before expiry, or 0 for never. between 0 and 604800 (7 days) (default 24 hours) max_uses: max number of uses or 0 for unlimited. between 0 and 100 temporary: whether this invite only grants temporary membership unique: if true, don't try to reuse a similar invite (useful for creating many unique one time use invites) target_type: the type of target for this voice channel invite target_user_id: the id of the user whose stream to display for this invite, required if target_type is 1, the user must be streaming in the channel target_application_id: the id of the embedded application to open for this invite, required if target_type is 2, the application must have the EMBEDDED flag reason: An optional reason for the audit log returns: an invite object \"\"\" payload = dict ( max_age = max_age , max_uses = max_uses , temporary = temporary , unique = unique ) if target_type : payload [ \"target_type\" ] = target_type if target_user_id : payload [ \"target_user_id\" ] = target_user_id if target_application_id : payload [ \"target_application_id\" ] = target_application_id return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /invites\" ), data = payload , reason = reason ) async def delete_invite ( self , invite_code : str , reason : str = MISSING ) -> dict : \"\"\" Delete an invite. parameters: invite_code: The code of the invite to delete reason: The reason to delete the invite returns: The deleted invite object \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/invites/ { invite_code } \" )) async def edit_channel_permission ( self , channel_id : \"Snowflake_Type\" , overwrite_id : \"Snowflake_Type\" , allow : str , deny : str , perm_type : int , reason : str = MISSING , ) -> None : \"\"\" Edit the channel permission overwrites for a user or role in a channel. parameters: channel_id: The id of the channel overwrite_id: The id of the object to override allow: the bitwise value of all allowed permissions deny: the bitwise value of all disallowed permissions perm_type: 0 for a role or 1 for a member reason: The reason for this action \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { channel_id } /permissions/ { overwrite_id } \" ), data = { \"allow\" : allow , \"deny\" : deny , \"type\" : perm_type }, reason = reason , ) async def delete_channel_permission ( self , channel_id : \"Snowflake_Type\" , overwrite_id : int , reason : str = MISSING ) -> None : \"\"\" Delete a channel permission overwrite for a user or role in a channel. parameters: channel_id: The ID of the channel. overwrite_id: The ID of the overwrite reason: An optional reason for the audit log \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } / { overwrite_id } \" ), reason = reason ) async def follow_news_channel ( self , channel_id : \"Snowflake_Type\" , webhook_channel_id : \"Snowflake_Type\" ) -> dict : \"\"\" Follow a news channel to send messages to the target channel. parameters: channel_id: The channel to follow webhook_channel_id: ID of the target channel returns: Followed channel object \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /followers\" ), data = { \"webhook_channel_id\" : webhook_channel_id } ) async def trigger_typing_indicator ( self , channel_id : \"Snowflake_Type\" ) -> None : \"\"\" Post a typing indicator for the specified channel. Generally bots should not implement this route. parameters: channel_id: The id of the channel to \"type\" in \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /typing\" )) async def get_pinned_messages ( self , channel_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get all pinned messages from a channel. parameters: channel_id: The ID of the channel to get pins from returns: A list of pinned message objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /pins\" )) async def create_stage_instance ( self , channel_id : \"Snowflake_Type\" , topic : str , privacy_level : StagePrivacyLevel = 1 , reason : str = MISSING ) -> dict : \"\"\" Create a new stage instance. parameters: channel_id: The ID of the stage channel topic: The topic of the stage instance (1-120 characters) privacy_level: Them privacy_level of the stage instance (default guild only) reason: The reason for the creating the stage instance returns: The stage instance \"\"\" return await self . request ( Route ( \"POST\" , \"/stage-instances\" ), data = { \"channel_id\" : channel_id , \"topic\" : topic , \"privacy_level\" : StagePrivacyLevel ( privacy_level ), }, reason = reason , ) async def get_stage_instance ( self , channel_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get the stage instance associated with a given channel, if it exists. parameters: channel_id: The ID of the channel to retrieve the instance for. returns: A stage instance. \"\"\" return await self . request ( Route ( \"GET\" , f \"/stage-instances/ { channel_id } \" )) async def modify_stage_instance ( self , channel_id : \"Snowflake_Type\" , topic : str = None , privacy_level : int = None , reason : str = MISSING ) -> dict : \"\"\" Update the fields of a given stage instance. parameters: channel_id: The id of the stage channel. topic: The new topic for the stage instance privacy_level: The privacy level for the stage instance reason: The reason for the change returns: The updated stage instance. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/stage-instances/ { channel_id } \" ), data = dict_filter_none ({ \"topic\" : topic , \"privacy_level\" : privacy_level }), reason = reason , ) async def delete_stage_instance ( self , channel_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Delete a stage instance. parameters: channel_id: The ID of the channel to delete the stage instance for. reason: The reason for the deletion \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/stage-instances/ { channel_id } \" ), reason = reason ) async get_channel ( self , channel_id ) \u00b6 Get a channel by ID. Returns a channel object. If the channel is a thread, a thread member object is included. Parameters: Name Type Description Default channel_id Snowflake_Type The id of the channel required Returns: Type Description dict channel Source code in dis_snek/http_requests/channels.py async def get_channel ( self , channel_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a channel by ID. Returns a channel object. If the channel is a thread, a thread member object is included. parameters: channel_id: The id of the channel returns: channel \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } \" )) async get_channel_messages ( self , channel_id , limit = 50 , around = None , before = None , after = None ) \u00b6 Get the messages for a channel. Parameters: Name Type Description Default channel_id Snowflake_Type The channel to get messages from required limit int How many messages to get (default 50, max 100) 50 around Optional[Snowflake_Type] Get messages around this snowflake None before Optional[Snowflake_Type] Get messages before this snowflake None after Optional[Snowflake_Type] Get messages after this snowflake None Returns: Type Description List[dict] List of message dicts Source code in dis_snek/http_requests/channels.py async def get_channel_messages ( self , channel_id : \"Snowflake_Type\" , limit : int = 50 , around : Optional [ \"Snowflake_Type\" ] = None , before : Optional [ \"Snowflake_Type\" ] = None , after : Optional [ \"Snowflake_Type\" ] = None , ) -> List [ dict ]: \"\"\" Get the messages for a channel. parameters: channel_id: The channel to get messages from limit: How many messages to get (default 50, max 100) around: Get messages around this snowflake before: Get messages before this snowflake after: Get messages after this snowflake returns: List of message dicts \"\"\" params : Dict [ str , Union [ int , str ]] = { \"limit\" : limit } params_used = 0 if before : params_used += 1 params [ \"before\" ] = before if after : params_used += 1 params [ \"after\" ] = after if around : params_used += 1 params [ \"around\" ] = around if params_used > 1 : raise ValueError ( \"`before` `after` and `around` are mutually exclusive, only one may be passed at a time.\" ) return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /messages\" ), params = params ) async move_channel ( self , guild_id , channel_id , new_pos , parent_id = None , lock_perms = False , reason = MISSING ) \u00b6 Move a channel. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild this affects required channel_id Snowflake_Type The ID of the channel to move required new_pos int The new position of this channel required parent_id Snowflake_Type The parent ID if needed None lock_perms bool Sync permissions with the new parent False reason str An optional reason for the audit log MISSING Source code in dis_snek/http_requests/channels.py async def move_channel ( self , guild_id : \"Snowflake_Type\" , channel_id : \"Snowflake_Type\" , new_pos : int , parent_id : \"Snowflake_Type\" = None , lock_perms : bool = False , reason : str = MISSING , ) -> None : \"\"\" Move a channel. parameters: guild_id: The ID of the guild this affects channel_id: The ID of the channel to move new_pos: The new position of this channel parent_id: The parent ID if needed lock_perms: Sync permissions with the new parent reason: An optional reason for the audit log \"\"\" payload = dict ( id = channel_id , position = new_pos , lock_permissions = lock_perms ) if parent_id : payload [ \"parent_id\" ] = parent_id return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /channels\" ), data = payload , reason = reason ) async modify_channel ( self , channel_id , data , reason = MISSING ) \u00b6 Update a channel's settings, returns the updated channel object on success. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to update required data dict The data to update with required reason str An optional reason for the audit log MISSING Returns: Type Description dict Channel object on success Source code in dis_snek/http_requests/channels.py async def modify_channel ( self , channel_id : \"Snowflake_Type\" , data : dict , reason : str = MISSING ) -> dict : \"\"\" Update a channel's settings, returns the updated channel object on success. parameters: channel_id: The ID of the channel to update data: The data to update with reason: An optional reason for the audit log returns: Channel object on success \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/channels/ { channel_id } \" ), data = data , reason = reason ) async delete_channel ( self , channel_id , reason = MISSING ) \u00b6 Delete the channel Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to delete required reason str An optional reason for the audit log MISSING Source code in dis_snek/http_requests/channels.py async def delete_channel ( self , channel_id : \"Snowflake_Type\" , reason : str = MISSING ): \"\"\" Delete the channel parameters: channel_id: The ID of the channel to delete reason: An optional reason for the audit log \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } \" ), reason = reason ) async get_channel_invites ( self , channel_id ) \u00b6 Get the invites for the channel. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to retrieve from required Returns: Type Description List[dict] List of invite objects Source code in dis_snek/http_requests/channels.py async def get_channel_invites ( self , channel_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get the invites for the channel. parameters: channel_id: The ID of the channel to retrieve from returns: List of invite objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /invites\" )) async create_channel_invite ( self , channel_id , max_age = 86400 , max_uses = 0 , temporary = False , unique = False , target_type = None , target_user_id = None , target_application_id = None , reason = MISSING ) \u00b6 Create an invite for the given channel. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to create an invite for required max_age int duration of invite in seconds before expiry, or 0 for never. between 0 and 604800 (7 days) (default 24 hours) 86400 max_uses int max number of uses or 0 for unlimited. between 0 and 100 0 temporary bool whether this invite only grants temporary membership False unique bool if true, don't try to reuse a similar invite (useful for creating many unique one time use invites) False target_type int the type of target for this voice channel invite None target_user_id Snowflake_Type the id of the user whose stream to display for this invite, required if target_type is 1, the user must be streaming in the channel None target_application_id Snowflake_Type the id of the embedded application to open for this invite, required if target_type is 2, the application must have the EMBEDDED flag None reason str An optional reason for the audit log MISSING Returns: Type Description dict an invite object Source code in dis_snek/http_requests/channels.py async def create_channel_invite ( self , channel_id : \"Snowflake_Type\" , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : int = None , target_user_id : \"Snowflake_Type\" = None , target_application_id : \"Snowflake_Type\" = None , reason : str = MISSING , ) -> dict : \"\"\" Create an invite for the given channel. parameters: channel_id: The ID of the channel to create an invite for max_age: duration of invite in seconds before expiry, or 0 for never. between 0 and 604800 (7 days) (default 24 hours) max_uses: max number of uses or 0 for unlimited. between 0 and 100 temporary: whether this invite only grants temporary membership unique: if true, don't try to reuse a similar invite (useful for creating many unique one time use invites) target_type: the type of target for this voice channel invite target_user_id: the id of the user whose stream to display for this invite, required if target_type is 1, the user must be streaming in the channel target_application_id: the id of the embedded application to open for this invite, required if target_type is 2, the application must have the EMBEDDED flag reason: An optional reason for the audit log returns: an invite object \"\"\" payload = dict ( max_age = max_age , max_uses = max_uses , temporary = temporary , unique = unique ) if target_type : payload [ \"target_type\" ] = target_type if target_user_id : payload [ \"target_user_id\" ] = target_user_id if target_application_id : payload [ \"target_application_id\" ] = target_application_id return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /invites\" ), data = payload , reason = reason ) async delete_invite ( self , invite_code , reason = MISSING ) \u00b6 Delete an invite. Parameters: Name Type Description Default invite_code str The code of the invite to delete required reason str The reason to delete the invite MISSING Returns: Type Description dict The deleted invite object Source code in dis_snek/http_requests/channels.py async def delete_invite ( self , invite_code : str , reason : str = MISSING ) -> dict : \"\"\" Delete an invite. parameters: invite_code: The code of the invite to delete reason: The reason to delete the invite returns: The deleted invite object \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/invites/ { invite_code } \" )) async edit_channel_permission ( self , channel_id , overwrite_id , allow , deny , perm_type , reason = MISSING ) \u00b6 Edit the channel permission overwrites for a user or role in a channel. Parameters: Name Type Description Default channel_id Snowflake_Type The id of the channel required overwrite_id Snowflake_Type The id of the object to override required allow str the bitwise value of all allowed permissions required deny str the bitwise value of all disallowed permissions required perm_type int 0 for a role or 1 for a member required reason str The reason for this action MISSING Source code in dis_snek/http_requests/channels.py async def edit_channel_permission ( self , channel_id : \"Snowflake_Type\" , overwrite_id : \"Snowflake_Type\" , allow : str , deny : str , perm_type : int , reason : str = MISSING , ) -> None : \"\"\" Edit the channel permission overwrites for a user or role in a channel. parameters: channel_id: The id of the channel overwrite_id: The id of the object to override allow: the bitwise value of all allowed permissions deny: the bitwise value of all disallowed permissions perm_type: 0 for a role or 1 for a member reason: The reason for this action \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { channel_id } /permissions/ { overwrite_id } \" ), data = { \"allow\" : allow , \"deny\" : deny , \"type\" : perm_type }, reason = reason , ) async delete_channel_permission ( self , channel_id , overwrite_id , reason = MISSING ) \u00b6 Delete a channel permission overwrite for a user or role in a channel. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel. required overwrite_id int The ID of the overwrite required reason str An optional reason for the audit log MISSING Source code in dis_snek/http_requests/channels.py async def delete_channel_permission ( self , channel_id : \"Snowflake_Type\" , overwrite_id : int , reason : str = MISSING ) -> None : \"\"\" Delete a channel permission overwrite for a user or role in a channel. parameters: channel_id: The ID of the channel. overwrite_id: The ID of the overwrite reason: An optional reason for the audit log \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } / { overwrite_id } \" ), reason = reason ) async follow_news_channel ( self , channel_id , webhook_channel_id ) \u00b6 Follow a news channel to send messages to the target channel. Parameters: Name Type Description Default channel_id Snowflake_Type The channel to follow required webhook_channel_id Snowflake_Type ID of the target channel required Returns: Type Description dict Followed channel object Source code in dis_snek/http_requests/channels.py async def follow_news_channel ( self , channel_id : \"Snowflake_Type\" , webhook_channel_id : \"Snowflake_Type\" ) -> dict : \"\"\" Follow a news channel to send messages to the target channel. parameters: channel_id: The channel to follow webhook_channel_id: ID of the target channel returns: Followed channel object \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /followers\" ), data = { \"webhook_channel_id\" : webhook_channel_id } ) async trigger_typing_indicator ( self , channel_id ) \u00b6 Post a typing indicator for the specified channel. Generally bots should not implement this route. Parameters: Name Type Description Default channel_id Snowflake_Type The id of the channel to \"type\" in required Source code in dis_snek/http_requests/channels.py async def trigger_typing_indicator ( self , channel_id : \"Snowflake_Type\" ) -> None : \"\"\" Post a typing indicator for the specified channel. Generally bots should not implement this route. parameters: channel_id: The id of the channel to \"type\" in \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /typing\" )) async get_pinned_messages ( self , channel_id ) \u00b6 Get all pinned messages from a channel. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to get pins from required Returns: Type Description List[dict] A list of pinned message objects Source code in dis_snek/http_requests/channels.py async def get_pinned_messages ( self , channel_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get all pinned messages from a channel. parameters: channel_id: The ID of the channel to get pins from returns: A list of pinned message objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /pins\" )) async create_stage_instance ( self , channel_id , topic , privacy_level = 1 , reason = MISSING ) \u00b6 Create a new stage instance. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the stage channel required topic str The topic of the stage instance (1-120 characters) required privacy_level StagePrivacyLevel Them privacy_level of the stage instance (default guild only) 1 reason str The reason for the creating the stage instance MISSING Returns: Type Description dict The stage instance Source code in dis_snek/http_requests/channels.py async def create_stage_instance ( self , channel_id : \"Snowflake_Type\" , topic : str , privacy_level : StagePrivacyLevel = 1 , reason : str = MISSING ) -> dict : \"\"\" Create a new stage instance. parameters: channel_id: The ID of the stage channel topic: The topic of the stage instance (1-120 characters) privacy_level: Them privacy_level of the stage instance (default guild only) reason: The reason for the creating the stage instance returns: The stage instance \"\"\" return await self . request ( Route ( \"POST\" , \"/stage-instances\" ), data = { \"channel_id\" : channel_id , \"topic\" : topic , \"privacy_level\" : StagePrivacyLevel ( privacy_level ), }, reason = reason , ) async get_stage_instance ( self , channel_id ) \u00b6 Get the stage instance associated with a given channel, if it exists. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to retrieve the instance for. required Returns: Type Description dict A stage instance. Source code in dis_snek/http_requests/channels.py async def get_stage_instance ( self , channel_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get the stage instance associated with a given channel, if it exists. parameters: channel_id: The ID of the channel to retrieve the instance for. returns: A stage instance. \"\"\" return await self . request ( Route ( \"GET\" , f \"/stage-instances/ { channel_id } \" )) async modify_stage_instance ( self , channel_id , topic = None , privacy_level = None , reason = MISSING ) \u00b6 Update the fields of a given stage instance. Parameters: Name Type Description Default channel_id Snowflake_Type The id of the stage channel. required topic str The new topic for the stage instance None privacy_level int The privacy level for the stage instance None reason str The reason for the change MISSING Returns: Type Description dict The updated stage instance. Source code in dis_snek/http_requests/channels.py async def modify_stage_instance ( self , channel_id : \"Snowflake_Type\" , topic : str = None , privacy_level : int = None , reason : str = MISSING ) -> dict : \"\"\" Update the fields of a given stage instance. parameters: channel_id: The id of the stage channel. topic: The new topic for the stage instance privacy_level: The privacy level for the stage instance reason: The reason for the change returns: The updated stage instance. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/stage-instances/ { channel_id } \" ), data = dict_filter_none ({ \"topic\" : topic , \"privacy_level\" : privacy_level }), reason = reason , ) async delete_stage_instance ( self , channel_id , reason = MISSING ) \u00b6 Delete a stage instance. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to delete the stage instance for. required reason str The reason for the deletion MISSING Source code in dis_snek/http_requests/channels.py async def delete_stage_instance ( self , channel_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Delete a stage instance. parameters: channel_id: The ID of the channel to delete the stage instance for. reason: The reason for the deletion \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/stage-instances/ { channel_id } \" ), reason = reason ) emojis \u00b6 EmojiRequests \u00b6 Source code in dis_snek/http_requests/emojis.py class EmojiRequests : request : \"HTTPClient.request\" async def get_all_guild_emoji ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get all the emoji from a guild. parameters: guild_id: The ID of the guild to query. Returns: List of emoji objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /emojis\" )) async def get_guild_emoji ( self , guild_id : \"Snowflake_Type\" , emoji_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a specific guild emoji object parameters: guild_id: The ID of the guild to query emoji_id: The ID of the emoji to get Returns: Emoji object \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" )) async def create_guild_emoji ( self , payload : dict , guild_id : \"Snowflake_Type\" , reason : str = MISSING ) -> dict : \"\"\" Create a guild emoji. parameters: payload: The emoji's data guild_id: The ID of the guild reason: The reason for this creation Returns: The created emoji object \"\"\" return await self . request ( Route ( \"POST\" , f \"/guilds/ { guild_id } /emojis\" ), data = payload , reason = reason ) async def modify_guild_emoji ( self , payload : dict , guild_id : \"Snowflake_Type\" , emoji_id : \"Snowflake_Type\" , reason : str = MISSING ) -> dict : \"\"\" Modify an existing guild emoji. parameters: payload: The emoji's data guild_id: The ID of the guild emoji_id: The ID of the emoji to update reason: The reason for this creation Returns: The updated emoji object \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" ), data = payload , reason = reason ) async def delete_guild_emoji ( self , guild_id : \"Snowflake_Type\" , emoji_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Delete a guild emoji. Args: guild_id: The ID of the guild emoji_id: The ID of the emoji to update reason: The reason for this deletion \"\"\" await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" ), reason = reason ) async get_all_guild_emoji ( self , guild_id ) \u00b6 Get all the emoji from a guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query. required Returns: Type Description List[dict] List of emoji objects Source code in dis_snek/http_requests/emojis.py async def get_all_guild_emoji ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get all the emoji from a guild. parameters: guild_id: The ID of the guild to query. Returns: List of emoji objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /emojis\" )) async get_guild_emoji ( self , guild_id , emoji_id ) \u00b6 Get a specific guild emoji object Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required emoji_id Snowflake_Type The ID of the emoji to get required Returns: Type Description dict Emoji object Source code in dis_snek/http_requests/emojis.py async def get_guild_emoji ( self , guild_id : \"Snowflake_Type\" , emoji_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a specific guild emoji object parameters: guild_id: The ID of the guild to query emoji_id: The ID of the emoji to get Returns: Emoji object \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" )) async create_guild_emoji ( self , payload , guild_id , reason = MISSING ) \u00b6 Create a guild emoji. Parameters: Name Type Description Default payload dict The emoji's data required guild_id Snowflake_Type The ID of the guild required reason str The reason for this creation MISSING Returns: Type Description dict The created emoji object Source code in dis_snek/http_requests/emojis.py async def create_guild_emoji ( self , payload : dict , guild_id : \"Snowflake_Type\" , reason : str = MISSING ) -> dict : \"\"\" Create a guild emoji. parameters: payload: The emoji's data guild_id: The ID of the guild reason: The reason for this creation Returns: The created emoji object \"\"\" return await self . request ( Route ( \"POST\" , f \"/guilds/ { guild_id } /emojis\" ), data = payload , reason = reason ) async modify_guild_emoji ( self , payload , guild_id , emoji_id , reason = MISSING ) \u00b6 Modify an existing guild emoji. Parameters: Name Type Description Default payload dict The emoji's data required guild_id Snowflake_Type The ID of the guild required emoji_id Snowflake_Type The ID of the emoji to update required reason str The reason for this creation MISSING Returns: Type Description dict The updated emoji object Source code in dis_snek/http_requests/emojis.py async def modify_guild_emoji ( self , payload : dict , guild_id : \"Snowflake_Type\" , emoji_id : \"Snowflake_Type\" , reason : str = MISSING ) -> dict : \"\"\" Modify an existing guild emoji. parameters: payload: The emoji's data guild_id: The ID of the guild emoji_id: The ID of the emoji to update reason: The reason for this creation Returns: The updated emoji object \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" ), data = payload , reason = reason ) async delete_guild_emoji ( self , guild_id , emoji_id , reason = MISSING ) \u00b6 Delete a guild emoji. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required emoji_id Snowflake_Type The ID of the emoji to update required reason str The reason for this deletion MISSING Source code in dis_snek/http_requests/emojis.py async def delete_guild_emoji ( self , guild_id : \"Snowflake_Type\" , emoji_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Delete a guild emoji. Args: guild_id: The ID of the guild emoji_id: The ID of the emoji to update reason: The reason for this deletion \"\"\" await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /emojis/ { emoji_id } \" ), reason = reason ) guild \u00b6 GuildRequests \u00b6 Source code in dis_snek/http_requests/guild.py class GuildRequests : request : Any async def get_guilds ( self , limit : int = 200 , before : Optional [ \"Snowflake_Type\" ] = None , after : Optional [ \"Snowflake_Type\" ] = None ) -> List [ Dict ]: \"\"\" Get a list of partial guild objects the current user is a member of req. `guilds` scope. parameters: limit: max number of guilds to return (1-200) before: get guilds before this guild ID after: get guilds after this guild ID returns: List[guilds] \"\"\" params : Dict [ str , Union [ int , str ]] = { \"limit\" : limit } if before : params [ \"before\" ] = before if after : params [ \"after\" ] = after return await self . request ( Route ( \"GET\" , \"/users/@me/guilds\" , params = params )) async def get_guild ( self , guild_id : \"Snowflake_Type\" , with_counts : Optional [ bool ] = True ) -> dict : \"\"\" Get the guild object for the given ID. parameters: guild_id: the id of the guild with_counts: when `true`, will return approximate member and presence counts for the guild returns: a guild object \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } \" ), params = { \"with_counts\" : int ( with_counts )} # type: ignore ) async def get_guild_preview ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a guild's preview parameters: guild_id: the guilds ID returns: guild preview object # todo: make an object representing this \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /preview\" )) async def get_channels ( self , guild_id : \"Snowflake_Type\" ) -> List [ Dict ]: \"\"\" Get a guilds channels. parameters: guild_id: the id of the guild returns: List of channels \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /channels\" )) async def get_roles ( self , guild_id : \"Snowflake_Type\" ) -> List [ Dict ]: \"\"\" Get a guild's roles. parameters: guild_id: The ID of the guild returns: List of roles \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /roles\" )) async def modify_guild ( self , guild_id : \"Snowflake_Type\" , reason : str = MISSING , ** kwargs ) -> None : \"\"\" Modify a guild's attributes. parameters: guild_id: The ID of the guild we want to modify reason: The reason for this change kwargs: The params to change \"\"\" expected = [ \"name\" , \"region\" , \"verification_level\" , \"default_message_notifications\" , \"explicit_content_filter\" , \"afk_channel_id\" , \"afk_timeout\" , \"icon\" , \"owner_id\" , \"splash\" , \"discovery_splash\" , \"banner\" , \"system_channel_id\" , \"system_channel_flags\" , \"rules_channel_id\" , \"public_updates_channel_id\" , \"preferred_locale\" , \"features\" , \"description\" , ] kwargs_copy = kwargs . copy () for key , value in kwargs . items (): if key not in expected or value is MISSING : del kwargs_copy [ key ] # only do the request if there is something to modify if kwargs_copy : await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } \" ), data = kwargs_copy , reason = reason ) async def delete_guild ( self , guild_id : \"Snowflake_Type\" ) -> None : \"\"\" Delete the guild. parameters: guild_id: The ID of the guild that we want to delete \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } \" )) async def add_guild_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , access_token : str , nick : str = None , roles : List [ \"Snowflake_Type\" ] = None , mute : bool = False , deaf : bool = False , ) -> dict : \"\"\" Add a user to the guild. All parameters to this endpoint except for `access_token`, `guild_id` and `user_id` are optional. parameters: guild_id: The ID of the guild user_id: The ID of the user to add access_token: The access token of the user nick: value to set users nickname to roles: array of role ids the member is assigned mute: whether the user is muted in voice channels deaf: whether the user is deafened in voice channels returns: Guild Member Object \"\"\" return await self . request ( Route ( \"PUT\" , f \"/guilds/ { guild_id } /members/ { user_id } \" ), data = dict_filter_none ( { \"access_token\" : access_token , \"nick\" : nick , \"roles\" : roles , \"mute\" : mute , \"deaf\" : deaf } ), ) async def remove_guild_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Remove a member from a guild. parameters: guild_id: The ID of the guild user_id: The ID of the user to remove reason: The reason for this action \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /members/ { user_id } \" ), reaosn = reason ) async def get_guild_bans ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Return a list of ban objects for the users banned from this guild. parameters: guild_id: The ID of the guild to query returns: List of ban objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /bans\" )) async def get_guild_ban ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> Optional [ dict ]: \"\"\" Returns a ban object for the given user or a 404 not found if the ban cannot be found parameters: guild_id: The ID of the guild to query user_id: The ID of the user to query returns: Ban object if exists raises: Not found error if no ban exists \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /bans/ { user_id } \" )) async def create_guild_ban ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , delete_message_days : int = 0 , reason : str = MISSING ) -> None : \"\"\" Create a guild ban, and optionally delete previous messages sent by the banned user. parameters: guild_id: The ID of the guild to create the ban in user_id: The ID of the user to ban delete_message_days: number of days to delete messages for (0-7) reason: The reason for this action \"\"\" return await self . request ( Route ( \"PUT\" , f \"/guilds/ { guild_id } /bans/ { user_id } \" ), data = { \"delete_message_days\" : delete_message_days }, reason = reason , ) async def remove_guild_ban ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Remove a guild ban. parameters: guild_id: The ID of the guild to remove the ban in user_id: The ID of the user to unban reason: The reason for this action \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /bans/ { user_id } \" ), reason = reason ) async def get_guild_prune_count ( self , guild_id : \"Snowflake_Type\" , days : int = 7 , include_roles : List [ \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Returns an object with one 'pruned' key indicating the number of members that would be removed in a prune operation. parameters: guild_id: The ID of the guild to query days: number of days to count prune for (1-30) include_roles: role(s) to include returns: {\"pruned\": int} \"\"\" payload = { \"days\" : days } if include_roles : payload [ \"include_roles\" ] = \", \" . join ( include_roles ) return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /prune\" ), params = payload ) async def begin_guild_prune ( self , guild_id : \"Snowflake_Type\" , days : int = 7 , include_roles : List [ \"Snowflake_Type\" ] = None , compute_prune_count : bool = True , reason : str = MISSING , ) -> dict : \"\"\" Begin a prune operation. parameters: guild_id: The ID of the guild to query days: number of days to count prune for (1-30) include_roles: role(s) to include compute_prune_count: whether 'pruned' is returned, discouraged for large guilds reason: The reason for this action returns: {\"pruned\": int} \"\"\" payload = { \"days\" : days , \"compute_prune_count\" : compute_prune_count } if include_roles : payload [ \"include_roles\" ] = \", \" . join ( include_roles ) return await self . request ( Route ( \"POST\" , f \"/guilds/ { guild_id } /prune\" ), data = payload , reason = reason ) async def get_guild_invites ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Returns a list of invite objects (with invite metadata) for the guild parameters: guild_id: The ID of the guild to query returns: List of invite objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /invites\" )) async def create_guild_role ( self , guild_id : \"Snowflake_Type\" , payload : dict , reason : str = MISSING ) -> dict : \"\"\" Create a new role for the guild. parameters: guild_id: The ID of the guild payload: A dict representing the role to add reason: The reason for this action returns: Role object \"\"\" return await self . request ( Route ( \"POST\" , f \"/guilds/ { guild_id } /roles\" ), data = payload , reason = reason ) async def modify_guild_role_positions ( self , guild_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , position : int , reason : str = MISSING ) -> List [ dict ]: \"\"\" Modify the position of a role in the guild. parameters: guild_id: The ID of the guild role_id: The ID of the role to move position: The new position of this role in the hierarchy reason: The reason for this action returns: List of guild roles \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /roles\" ), data = { \"id\" : role_id , \"position\" : position }, reason = reason ) async def modify_guild_role ( self , guild_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , payload : dict , reason : str = MISSING ) -> dict : \"\"\" Modify an existing role for the guild. parameters: guild_id: The ID of the guild role_id: The ID of the role to move payload: A dict representing the role to add reason: The reason for this action returns: Role object \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /roles/ { role_id } \" ), data = payload , reason = reason ) async def delete_guild_role ( self , guild_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , reason : str = MISSING ): \"\"\" Delete a guild role. parameters: role_id: The ID of the role to delete reason: The reason for this action guild_id: The ID of the guild \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /roles/ { role_id } \" )) async def get_guild_voice_regions ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Returns a list of voice region objects for the guild. Unlike the similar /voice route, this returns VIP servers when the guild is VIP-enabled. parameters: guild_id: The ID of the guild to query returns: List of voice region objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /regions\" )) async def get_guild_integrations ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Returns a list of integration objects for the guild. parameters: guild_id: The ID of the guild to query returns: list of integration objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /integrations\" )) async def delete_guild_integration ( self , guild_id : \"Snowflake_Type\" , integration_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Delete an integration from the guild. parameters: guild_id: The ID of the guild integration_id: The ID of the integration to remove \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /integrations/ { integration_id } \" ), reason = reason ) async def get_guild_widget_settings ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get guild widget settings. parameters: guild_id: The ID of the guild to query returns: guild widget object \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /widget\" )) async def get_guild_widget ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Returns the widget for the guild. parameters: guild_id: The ID of the guild to query returns: Guild widget \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /widget.json\" )) async def get_guild_widget_image ( self , guild_id : \"Snowflake_Type\" , style : str = None ) -> str : \"\"\" Get a url representing a png image widget for the guild. For styles see: https://discord.com/developers/docs/resources/guild#get-guild-widget-image parameters: guild_id: The guild to query style: The style of widget required. returns: A url pointing to this image \"\"\" route = Route ( \"GET\" , f \"/guilds/ { guild_id } /widget.png { f '?style= { style } ' if style else '' } \" ) return route . url async def get_guild_welcome_screen ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get the welcome screen for this guild. parameters: guild_id: The ID of the guild to query returns: Welcome screen object \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /welcome-screen\" )) async def get_guild_vanity_url ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a partial invite object for the guilds vanity invite url. parameters: guild_id: The ID of the guild to query returns: `{\"code\": \"abc\", \"uses\": 420}` or `None` \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /vanity-url\" )) async def modify_guild_widget ( self , guild_id : \"Snowflake_Type\" , enabled : bool = None , channel_id : \"Snowflake_Type\" = None ) -> dict : \"\"\" Modify a guild widget. Args: guild_id: The ID of the guild to modify. enabled: Should the guild widget be enabled channel_id: The widget's channel ID returns: Updated guild widget. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /widget\" ), data = dict_filter_none ({ \"enabled\" : enabled , \"channel_id\" : channel_id }), ) async def modify_guild_welcome_screen ( self , guild_id : \"Snowflake_Type\" , enabled : bool , welcome_channels : List [ \"Snowflake_Type\" ], description : str ) -> dict : \"\"\" Modify the guild's welcome screen. parameters: guild_id: The ID of the guild. enabled: Whether the welcome screen is enabled welcome_channels: Channels linked in the welcome screen and their display options description: The server description to show in the welcome screen returns: Updated welcome screen object \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /welcome-screen\" ), data = { \"enabled\" : enabled , \"welcome_channels\" : welcome_channels , \"description\" : description }, ) async def modify_current_user_voice_state ( self , guild_id : \"Snowflake_Type\" , channel_id : \"Snowflake_Type\" , suppress : bool = None , request_to_speak_timestamp : str = None , ) -> None : \"\"\" Update the current user voice state. parameters: guild_id: The ID of the guild to update. channel_id: The id of the channel the user is currently in suppress: Toggle the user's suppress state. request_to_speak_timestamp: Sets the user's request to speak \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /voice-states/@me\" ), data = dict_filter_none ( { \"channel_id\" : channel_id , \"suppress\" : suppress , \"request_to_speak_timestamp\" : request_to_speak_timestamp , } ), ) async def modify_user_voice_state ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , channel_id : \"Snowflake_Type\" , suppress : bool = None ) -> None : \"\"\" Modify the voice state of a user. parameters: guild_id: The ID of the guild. user_id: The ID of the user to modify. channel_id: The ID of the channel the user is currently in. suppress: Toggles the user's suppress state. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /voice-states/ { user_id } \" ), data = dict_filter_none ({ \"channel_id\" : channel_id , \"suppress\" : suppress }), ) async def create_guild_from_guild_template ( self , template_code : str , name : str ) -> dict : \"\"\" Create a a new guild based on a template. note: This endpoint can only be used by bots in less than 10 guilds. parameters: template_code: The code of the template to use. name: The name o the guild (2-100 characters) returns: The newly created guild object \"\"\" # todo: add icon support return await self . request ( Route ( \"POST\" , f \"/guilds/templates/ { template_code } \" , data = { \"name\" : name })) async def get_guild_templates ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Returns an array of guild templates. parameters: guild_id: The ID of the guild to query. returns: An array of guild templates \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /templates\" )) async def create_guild_template ( self , guild_id : \"Snowflake_Type\" , name : str , description : str = None ) -> dict : \"\"\" Create a guild template for the guild. parameters: guild_id: The ID of the guild to create a template for. name: The name of the template description: The description of the template returns: The created guild template \"\"\" return await self . request ( Route ( \"POST\" , f \"/guilds/ { guild_id } /templates\" ), data = dict_filter_none ({ \"name\" : name , \"description\" : description }), ) async def sync_guild_template ( self , guild_id : \"Snowflake_Type\" , template_code : str ) -> dict : \"\"\" Sync the template to the guild's current state. parameters: guild_id: The ID of the guild template_code: The code for the template to sync returns: The updated guild template \"\"\" return await self . request ( Route ( \"PUT\" , f \"/guilds/ { guild_id } /templates/ { template_code } \" )) async def modify_guild_template ( self , guild_id : \"Snowflake_Type\" , template_code : str , name : str = None , description : str = None ) -> dict : \"\"\" Modifies the template's metadata parameters: guild_id: The ID of the guild template_code: The template code name: The name of the template description: The description of the template returns: The updated guild template \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /templates/ { template_code } \" ), data = dict_filter_none ({ \"name\" : name , \"description\" : description }), ) async def delete_guild_template ( self , guild_id : \"Snowflake_Type\" , template_code : str ) -> dict : \"\"\" Delete the guild template. parameters: guild_id: The ID of the guild template_code: The ID of the template returns: The deleted template object \"\"\" # why on earth does this return the deleted template object? return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /templates/ { template_code } \" )) async get_guilds ( self , limit = 200 , before = None , after = None ) \u00b6 Get a list of partial guild objects the current user is a member of req. guilds scope. Parameters: Name Type Description Default limit int max number of guilds to return (1-200) 200 before Optional[Snowflake_Type] get guilds before this guild ID None after Optional[Snowflake_Type] get guilds after this guild ID None Returns: Type Description List[Dict] List[guilds] Source code in dis_snek/http_requests/guild.py async def get_guilds ( self , limit : int = 200 , before : Optional [ \"Snowflake_Type\" ] = None , after : Optional [ \"Snowflake_Type\" ] = None ) -> List [ Dict ]: \"\"\" Get a list of partial guild objects the current user is a member of req. `guilds` scope. parameters: limit: max number of guilds to return (1-200) before: get guilds before this guild ID after: get guilds after this guild ID returns: List[guilds] \"\"\" params : Dict [ str , Union [ int , str ]] = { \"limit\" : limit } if before : params [ \"before\" ] = before if after : params [ \"after\" ] = after return await self . request ( Route ( \"GET\" , \"/users/@me/guilds\" , params = params )) async get_guild ( self , guild_id , with_counts = True ) \u00b6 Get the guild object for the given ID. Parameters: Name Type Description Default guild_id Snowflake_Type the id of the guild required with_counts Optional[bool] when true , will return approximate member and presence counts for the guild True Returns: Type Description dict a guild object Source code in dis_snek/http_requests/guild.py async def get_guild ( self , guild_id : \"Snowflake_Type\" , with_counts : Optional [ bool ] = True ) -> dict : \"\"\" Get the guild object for the given ID. parameters: guild_id: the id of the guild with_counts: when `true`, will return approximate member and presence counts for the guild returns: a guild object \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } \" ), params = { \"with_counts\" : int ( with_counts )} # type: ignore ) async get_guild_preview ( self , guild_id ) \u00b6 Get a guild's preview Parameters: Name Type Description Default guild_id Snowflake_Type the guilds ID required Returns: Type Description guild preview object # todo make an object representing this Source code in dis_snek/http_requests/guild.py async def get_guild_preview ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a guild's preview parameters: guild_id: the guilds ID returns: guild preview object # todo: make an object representing this \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /preview\" )) async get_channels ( self , guild_id ) \u00b6 Get a guilds channels. Parameters: Name Type Description Default guild_id Snowflake_Type the id of the guild required Returns: Type Description List[Dict] List of channels Source code in dis_snek/http_requests/guild.py async def get_channels ( self , guild_id : \"Snowflake_Type\" ) -> List [ Dict ]: \"\"\" Get a guilds channels. parameters: guild_id: the id of the guild returns: List of channels \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /channels\" )) async get_roles ( self , guild_id ) \u00b6 Get a guild's roles. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required Returns: Type Description List[Dict] List of roles Source code in dis_snek/http_requests/guild.py async def get_roles ( self , guild_id : \"Snowflake_Type\" ) -> List [ Dict ]: \"\"\" Get a guild's roles. parameters: guild_id: The ID of the guild returns: List of roles \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /roles\" )) async modify_guild ( self , guild_id , reason = MISSING , ** kwargs ) \u00b6 Modify a guild's attributes. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild we want to modify required reason str The reason for this change MISSING kwargs The params to change {} Source code in dis_snek/http_requests/guild.py async def modify_guild ( self , guild_id : \"Snowflake_Type\" , reason : str = MISSING , ** kwargs ) -> None : \"\"\" Modify a guild's attributes. parameters: guild_id: The ID of the guild we want to modify reason: The reason for this change kwargs: The params to change \"\"\" expected = [ \"name\" , \"region\" , \"verification_level\" , \"default_message_notifications\" , \"explicit_content_filter\" , \"afk_channel_id\" , \"afk_timeout\" , \"icon\" , \"owner_id\" , \"splash\" , \"discovery_splash\" , \"banner\" , \"system_channel_id\" , \"system_channel_flags\" , \"rules_channel_id\" , \"public_updates_channel_id\" , \"preferred_locale\" , \"features\" , \"description\" , ] kwargs_copy = kwargs . copy () for key , value in kwargs . items (): if key not in expected or value is MISSING : del kwargs_copy [ key ] # only do the request if there is something to modify if kwargs_copy : await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } \" ), data = kwargs_copy , reason = reason ) async delete_guild ( self , guild_id ) \u00b6 Delete the guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild that we want to delete required Source code in dis_snek/http_requests/guild.py async def delete_guild ( self , guild_id : \"Snowflake_Type\" ) -> None : \"\"\" Delete the guild. parameters: guild_id: The ID of the guild that we want to delete \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } \" )) async add_guild_member ( self , guild_id , user_id , access_token , nick = None , roles = None , mute = False , deaf = False ) \u00b6 Add a user to the guild. All parameters to this endpoint except for access_token , guild_id and user_id are optional. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required user_id Snowflake_Type The ID of the user to add required access_token str The access token of the user required nick str value to set users nickname to None roles List[Snowflake_Type] array of role ids the member is assigned None mute bool whether the user is muted in voice channels False deaf bool whether the user is deafened in voice channels False Returns: Type Description dict Guild Member Object Source code in dis_snek/http_requests/guild.py async def add_guild_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , access_token : str , nick : str = None , roles : List [ \"Snowflake_Type\" ] = None , mute : bool = False , deaf : bool = False , ) -> dict : \"\"\" Add a user to the guild. All parameters to this endpoint except for `access_token`, `guild_id` and `user_id` are optional. parameters: guild_id: The ID of the guild user_id: The ID of the user to add access_token: The access token of the user nick: value to set users nickname to roles: array of role ids the member is assigned mute: whether the user is muted in voice channels deaf: whether the user is deafened in voice channels returns: Guild Member Object \"\"\" return await self . request ( Route ( \"PUT\" , f \"/guilds/ { guild_id } /members/ { user_id } \" ), data = dict_filter_none ( { \"access_token\" : access_token , \"nick\" : nick , \"roles\" : roles , \"mute\" : mute , \"deaf\" : deaf } ), ) async remove_guild_member ( self , guild_id , user_id , reason = MISSING ) \u00b6 Remove a member from a guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required user_id Snowflake_Type The ID of the user to remove required reason str The reason for this action MISSING Source code in dis_snek/http_requests/guild.py async def remove_guild_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Remove a member from a guild. parameters: guild_id: The ID of the guild user_id: The ID of the user to remove reason: The reason for this action \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /members/ { user_id } \" ), reaosn = reason ) async get_guild_bans ( self , guild_id ) \u00b6 Return a list of ban objects for the users banned from this guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required Returns: Type Description List[dict] List of ban objects Source code in dis_snek/http_requests/guild.py async def get_guild_bans ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Return a list of ban objects for the users banned from this guild. parameters: guild_id: The ID of the guild to query returns: List of ban objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /bans\" )) async get_guild_ban ( self , guild_id , user_id ) \u00b6 Returns a ban object for the given user or a 404 not found if the ban cannot be found Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required user_id Snowflake_Type The ID of the user to query required Returns: Type Description Optional[dict] Ban object if exists Source code in dis_snek/http_requests/guild.py async def get_guild_ban ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> Optional [ dict ]: \"\"\" Returns a ban object for the given user or a 404 not found if the ban cannot be found parameters: guild_id: The ID of the guild to query user_id: The ID of the user to query returns: Ban object if exists raises: Not found error if no ban exists \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /bans/ { user_id } \" )) async create_guild_ban ( self , guild_id , user_id , delete_message_days = 0 , reason = MISSING ) \u00b6 Create a guild ban, and optionally delete previous messages sent by the banned user. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to create the ban in required user_id Snowflake_Type The ID of the user to ban required delete_message_days int number of days to delete messages for (0-7) 0 reason str The reason for this action MISSING Source code in dis_snek/http_requests/guild.py async def create_guild_ban ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , delete_message_days : int = 0 , reason : str = MISSING ) -> None : \"\"\" Create a guild ban, and optionally delete previous messages sent by the banned user. parameters: guild_id: The ID of the guild to create the ban in user_id: The ID of the user to ban delete_message_days: number of days to delete messages for (0-7) reason: The reason for this action \"\"\" return await self . request ( Route ( \"PUT\" , f \"/guilds/ { guild_id } /bans/ { user_id } \" ), data = { \"delete_message_days\" : delete_message_days }, reason = reason , ) async remove_guild_ban ( self , guild_id , user_id , reason = MISSING ) \u00b6 Remove a guild ban. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to remove the ban in required user_id Snowflake_Type The ID of the user to unban required reason str The reason for this action MISSING Source code in dis_snek/http_requests/guild.py async def remove_guild_ban ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Remove a guild ban. parameters: guild_id: The ID of the guild to remove the ban in user_id: The ID of the user to unban reason: The reason for this action \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /bans/ { user_id } \" ), reason = reason ) async get_guild_prune_count ( self , guild_id , days = 7 , include_roles = None ) \u00b6 Returns an object with one 'pruned' key indicating the number of members that would be removed in a prune operation. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required days int number of days to count prune for (1-30) 7 include_roles List[Snowflake_Type] role(s) to include None Returns: Type Description {\"pruned\" int} Source code in dis_snek/http_requests/guild.py async def get_guild_prune_count ( self , guild_id : \"Snowflake_Type\" , days : int = 7 , include_roles : List [ \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Returns an object with one 'pruned' key indicating the number of members that would be removed in a prune operation. parameters: guild_id: The ID of the guild to query days: number of days to count prune for (1-30) include_roles: role(s) to include returns: {\"pruned\": int} \"\"\" payload = { \"days\" : days } if include_roles : payload [ \"include_roles\" ] = \", \" . join ( include_roles ) return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /prune\" ), params = payload ) async begin_guild_prune ( self , guild_id , days = 7 , include_roles = None , compute_prune_count = True , reason = MISSING ) \u00b6 Begin a prune operation. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required days int number of days to count prune for (1-30) 7 include_roles List[Snowflake_Type] role(s) to include None compute_prune_count bool whether 'pruned' is returned, discouraged for large guilds True reason str The reason for this action MISSING Returns: Type Description {\"pruned\" int} Source code in dis_snek/http_requests/guild.py async def begin_guild_prune ( self , guild_id : \"Snowflake_Type\" , days : int = 7 , include_roles : List [ \"Snowflake_Type\" ] = None , compute_prune_count : bool = True , reason : str = MISSING , ) -> dict : \"\"\" Begin a prune operation. parameters: guild_id: The ID of the guild to query days: number of days to count prune for (1-30) include_roles: role(s) to include compute_prune_count: whether 'pruned' is returned, discouraged for large guilds reason: The reason for this action returns: {\"pruned\": int} \"\"\" payload = { \"days\" : days , \"compute_prune_count\" : compute_prune_count } if include_roles : payload [ \"include_roles\" ] = \", \" . join ( include_roles ) return await self . request ( Route ( \"POST\" , f \"/guilds/ { guild_id } /prune\" ), data = payload , reason = reason ) async get_guild_invites ( self , guild_id ) \u00b6 Returns a list of invite objects (with invite metadata) for the guild Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required Returns: Type Description List[dict] List of invite objects Source code in dis_snek/http_requests/guild.py async def get_guild_invites ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Returns a list of invite objects (with invite metadata) for the guild parameters: guild_id: The ID of the guild to query returns: List of invite objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /invites\" )) async create_guild_role ( self , guild_id , payload , reason = MISSING ) \u00b6 Create a new role for the guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required payload dict A dict representing the role to add required reason str The reason for this action MISSING Returns: Type Description dict Role object Source code in dis_snek/http_requests/guild.py async def create_guild_role ( self , guild_id : \"Snowflake_Type\" , payload : dict , reason : str = MISSING ) -> dict : \"\"\" Create a new role for the guild. parameters: guild_id: The ID of the guild payload: A dict representing the role to add reason: The reason for this action returns: Role object \"\"\" return await self . request ( Route ( \"POST\" , f \"/guilds/ { guild_id } /roles\" ), data = payload , reason = reason ) async modify_guild_role_positions ( self , guild_id , role_id , position , reason = MISSING ) \u00b6 Modify the position of a role in the guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required role_id Snowflake_Type The ID of the role to move required position int The new position of this role in the hierarchy required reason str The reason for this action MISSING Returns: Type Description List[dict] List of guild roles Source code in dis_snek/http_requests/guild.py async def modify_guild_role_positions ( self , guild_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , position : int , reason : str = MISSING ) -> List [ dict ]: \"\"\" Modify the position of a role in the guild. parameters: guild_id: The ID of the guild role_id: The ID of the role to move position: The new position of this role in the hierarchy reason: The reason for this action returns: List of guild roles \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /roles\" ), data = { \"id\" : role_id , \"position\" : position }, reason = reason ) async modify_guild_role ( self , guild_id , role_id , payload , reason = MISSING ) \u00b6 Modify an existing role for the guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required role_id Snowflake_Type The ID of the role to move required payload dict A dict representing the role to add required reason str The reason for this action MISSING Returns: Type Description dict Role object Source code in dis_snek/http_requests/guild.py async def modify_guild_role ( self , guild_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , payload : dict , reason : str = MISSING ) -> dict : \"\"\" Modify an existing role for the guild. parameters: guild_id: The ID of the guild role_id: The ID of the role to move payload: A dict representing the role to add reason: The reason for this action returns: Role object \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /roles/ { role_id } \" ), data = payload , reason = reason ) async delete_guild_role ( self , guild_id , role_id , reason = MISSING ) \u00b6 Delete a guild role. Parameters: Name Type Description Default role_id Snowflake_Type The ID of the role to delete required reason str The reason for this action MISSING guild_id Snowflake_Type The ID of the guild required Source code in dis_snek/http_requests/guild.py async def delete_guild_role ( self , guild_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , reason : str = MISSING ): \"\"\" Delete a guild role. parameters: role_id: The ID of the role to delete reason: The reason for this action guild_id: The ID of the guild \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /roles/ { role_id } \" )) async get_guild_voice_regions ( self , guild_id ) \u00b6 Returns a list of voice region objects for the guild. Unlike the similar /voice route, this returns VIP servers when the guild is VIP-enabled. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required Returns: Type Description List[dict] List of voice region objects Source code in dis_snek/http_requests/guild.py async def get_guild_voice_regions ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Returns a list of voice region objects for the guild. Unlike the similar /voice route, this returns VIP servers when the guild is VIP-enabled. parameters: guild_id: The ID of the guild to query returns: List of voice region objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /regions\" )) async get_guild_integrations ( self , guild_id ) \u00b6 Returns a list of integration objects for the guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required Returns: Type Description List[dict] list of integration objects Source code in dis_snek/http_requests/guild.py async def get_guild_integrations ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Returns a list of integration objects for the guild. parameters: guild_id: The ID of the guild to query returns: list of integration objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /integrations\" )) async delete_guild_integration ( self , guild_id , integration_id , reason = MISSING ) \u00b6 Delete an integration from the guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required integration_id Snowflake_Type The ID of the integration to remove required Source code in dis_snek/http_requests/guild.py async def delete_guild_integration ( self , guild_id : \"Snowflake_Type\" , integration_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Delete an integration from the guild. parameters: guild_id: The ID of the guild integration_id: The ID of the integration to remove \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /integrations/ { integration_id } \" ), reason = reason ) async get_guild_widget_settings ( self , guild_id ) \u00b6 Get guild widget settings. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required Returns: Type Description dict guild widget object Source code in dis_snek/http_requests/guild.py async def get_guild_widget_settings ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get guild widget settings. parameters: guild_id: The ID of the guild to query returns: guild widget object \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /widget\" )) async get_guild_widget ( self , guild_id ) \u00b6 Returns the widget for the guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required Returns: Type Description dict Guild widget Source code in dis_snek/http_requests/guild.py async def get_guild_widget ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Returns the widget for the guild. parameters: guild_id: The ID of the guild to query returns: Guild widget \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /widget.json\" )) async get_guild_widget_image ( self , guild_id , style = None ) \u00b6 Get a url representing a png image widget for the guild. For styles see: https://discord.com/developers/docs/resources/guild#get-guild-widget-image Parameters: Name Type Description Default guild_id Snowflake_Type The guild to query required style str The style of widget required. None Returns: Type Description str A url pointing to this image Source code in dis_snek/http_requests/guild.py async def get_guild_widget_image ( self , guild_id : \"Snowflake_Type\" , style : str = None ) -> str : \"\"\" Get a url representing a png image widget for the guild. For styles see: https://discord.com/developers/docs/resources/guild#get-guild-widget-image parameters: guild_id: The guild to query style: The style of widget required. returns: A url pointing to this image \"\"\" route = Route ( \"GET\" , f \"/guilds/ { guild_id } /widget.png { f '?style= { style } ' if style else '' } \" ) return route . url async get_guild_welcome_screen ( self , guild_id ) \u00b6 Get the welcome screen for this guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required Returns: Type Description dict Welcome screen object Source code in dis_snek/http_requests/guild.py async def get_guild_welcome_screen ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get the welcome screen for this guild. parameters: guild_id: The ID of the guild to query returns: Welcome screen object \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /welcome-screen\" )) async get_guild_vanity_url ( self , guild_id ) \u00b6 Get a partial invite object for the guilds vanity invite url. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query required Returns: Type Description `{\"code\" \"abc\", \"uses\": 420} or None` Source code in dis_snek/http_requests/guild.py async def get_guild_vanity_url ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a partial invite object for the guilds vanity invite url. parameters: guild_id: The ID of the guild to query returns: `{\"code\": \"abc\", \"uses\": 420}` or `None` \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /vanity-url\" )) async modify_guild_widget ( self , guild_id , enabled = None , channel_id = None ) \u00b6 Modify a guild widget. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to modify. required enabled bool Should the guild widget be enabled None channel_id Snowflake_Type The widget's channel ID None Returns: Type Description dict Updated guild widget. Source code in dis_snek/http_requests/guild.py async def modify_guild_widget ( self , guild_id : \"Snowflake_Type\" , enabled : bool = None , channel_id : \"Snowflake_Type\" = None ) -> dict : \"\"\" Modify a guild widget. Args: guild_id: The ID of the guild to modify. enabled: Should the guild widget be enabled channel_id: The widget's channel ID returns: Updated guild widget. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /widget\" ), data = dict_filter_none ({ \"enabled\" : enabled , \"channel_id\" : channel_id }), ) async modify_guild_welcome_screen ( self , guild_id , enabled , welcome_channels , description ) \u00b6 Modify the guild's welcome screen. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild. required enabled bool Whether the welcome screen is enabled required welcome_channels List[Snowflake_Type] Channels linked in the welcome screen and their display options required description str The server description to show in the welcome screen required Returns: Type Description dict Updated welcome screen object Source code in dis_snek/http_requests/guild.py async def modify_guild_welcome_screen ( self , guild_id : \"Snowflake_Type\" , enabled : bool , welcome_channels : List [ \"Snowflake_Type\" ], description : str ) -> dict : \"\"\" Modify the guild's welcome screen. parameters: guild_id: The ID of the guild. enabled: Whether the welcome screen is enabled welcome_channels: Channels linked in the welcome screen and their display options description: The server description to show in the welcome screen returns: Updated welcome screen object \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /welcome-screen\" ), data = { \"enabled\" : enabled , \"welcome_channels\" : welcome_channels , \"description\" : description }, ) async modify_current_user_voice_state ( self , guild_id , channel_id , suppress = None , request_to_speak_timestamp = None ) \u00b6 Update the current user voice state. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to update. required channel_id Snowflake_Type The id of the channel the user is currently in required suppress bool Toggle the user's suppress state. None request_to_speak_timestamp str Sets the user's request to speak None Source code in dis_snek/http_requests/guild.py async def modify_current_user_voice_state ( self , guild_id : \"Snowflake_Type\" , channel_id : \"Snowflake_Type\" , suppress : bool = None , request_to_speak_timestamp : str = None , ) -> None : \"\"\" Update the current user voice state. parameters: guild_id: The ID of the guild to update. channel_id: The id of the channel the user is currently in suppress: Toggle the user's suppress state. request_to_speak_timestamp: Sets the user's request to speak \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /voice-states/@me\" ), data = dict_filter_none ( { \"channel_id\" : channel_id , \"suppress\" : suppress , \"request_to_speak_timestamp\" : request_to_speak_timestamp , } ), ) async modify_user_voice_state ( self , guild_id , user_id , channel_id , suppress = None ) \u00b6 Modify the voice state of a user. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild. required user_id Snowflake_Type The ID of the user to modify. required channel_id Snowflake_Type The ID of the channel the user is currently in. required suppress bool Toggles the user's suppress state. None Source code in dis_snek/http_requests/guild.py async def modify_user_voice_state ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , channel_id : \"Snowflake_Type\" , suppress : bool = None ) -> None : \"\"\" Modify the voice state of a user. parameters: guild_id: The ID of the guild. user_id: The ID of the user to modify. channel_id: The ID of the channel the user is currently in. suppress: Toggles the user's suppress state. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /voice-states/ { user_id } \" ), data = dict_filter_none ({ \"channel_id\" : channel_id , \"suppress\" : suppress }), ) async create_guild_from_guild_template ( self , template_code , name ) \u00b6 Create a a new guild based on a template. Note This endpoint can only be used by bots in less than 10 guilds. Parameters: Name Type Description Default template_code str The code of the template to use. required name str The name o the guild (2-100 characters) required Returns: Type Description dict The newly created guild object Source code in dis_snek/http_requests/guild.py async def create_guild_from_guild_template ( self , template_code : str , name : str ) -> dict : \"\"\" Create a a new guild based on a template. note: This endpoint can only be used by bots in less than 10 guilds. parameters: template_code: The code of the template to use. name: The name o the guild (2-100 characters) returns: The newly created guild object \"\"\" # todo: add icon support return await self . request ( Route ( \"POST\" , f \"/guilds/templates/ { template_code } \" , data = { \"name\" : name })) async get_guild_templates ( self , guild_id ) \u00b6 Returns an array of guild templates. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to query. required Returns: Type Description List[dict] An array of guild templates Source code in dis_snek/http_requests/guild.py async def get_guild_templates ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Returns an array of guild templates. parameters: guild_id: The ID of the guild to query. returns: An array of guild templates \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /templates\" )) async create_guild_template ( self , guild_id , name , description = None ) \u00b6 Create a guild template for the guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to create a template for. required name str The name of the template required description str The description of the template None Returns: Type Description dict The created guild template Source code in dis_snek/http_requests/guild.py async def create_guild_template ( self , guild_id : \"Snowflake_Type\" , name : str , description : str = None ) -> dict : \"\"\" Create a guild template for the guild. parameters: guild_id: The ID of the guild to create a template for. name: The name of the template description: The description of the template returns: The created guild template \"\"\" return await self . request ( Route ( \"POST\" , f \"/guilds/ { guild_id } /templates\" ), data = dict_filter_none ({ \"name\" : name , \"description\" : description }), ) async sync_guild_template ( self , guild_id , template_code ) \u00b6 Sync the template to the guild's current state. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required template_code str The code for the template to sync required Returns: Type Description dict The updated guild template Source code in dis_snek/http_requests/guild.py async def sync_guild_template ( self , guild_id : \"Snowflake_Type\" , template_code : str ) -> dict : \"\"\" Sync the template to the guild's current state. parameters: guild_id: The ID of the guild template_code: The code for the template to sync returns: The updated guild template \"\"\" return await self . request ( Route ( \"PUT\" , f \"/guilds/ { guild_id } /templates/ { template_code } \" )) async modify_guild_template ( self , guild_id , template_code , name = None , description = None ) \u00b6 Modifies the template's metadata Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required template_code str The template code required name str The name of the template None description str The description of the template None Returns: Type Description dict The updated guild template Source code in dis_snek/http_requests/guild.py async def modify_guild_template ( self , guild_id : \"Snowflake_Type\" , template_code : str , name : str = None , description : str = None ) -> dict : \"\"\" Modifies the template's metadata parameters: guild_id: The ID of the guild template_code: The template code name: The name of the template description: The description of the template returns: The updated guild template \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /templates/ { template_code } \" ), data = dict_filter_none ({ \"name\" : name , \"description\" : description }), ) async delete_guild_template ( self , guild_id , template_code ) \u00b6 Delete the guild template. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required template_code str The ID of the template required Returns: Type Description dict The deleted template object Source code in dis_snek/http_requests/guild.py async def delete_guild_template ( self , guild_id : \"Snowflake_Type\" , template_code : str ) -> dict : \"\"\" Delete the guild template. parameters: guild_id: The ID of the guild template_code: The ID of the template returns: The deleted template object \"\"\" # why on earth does this return the deleted template object? return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /templates/ { template_code } \" )) interactions \u00b6 InteractionRequests \u00b6 Source code in dis_snek/http_requests/interactions.py class InteractionRequests : request : Any async def delete_interaction_element ( self , application_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" , command_id : \"Snowflake_Type\" ) -> None : \"\"\" Delete an existing interaction element for this application. Attributes: application_id: the what application to delete for guild_id: specify a guild to delete commands from command_id The command to delete \"\"\" if guild_id == GLOBAL_SCOPE : return await self . request ( Route ( \"DELETE\" , f \"/applications/ { application_id } /commands/ { command_id } \" )) return await self . request ( Route ( \"DELETE\" , f \"/applications/ { application_id } /guilds/ { guild_id } /commands/ { command_id } \" ) ) async def get_interaction_element ( self , application_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" ) -> List [ Dict ]: \"\"\" Get all interaction elements for this application from discord. parameters: application_id: the what application to query guild_id: specify a guild to get commands from returns: InteractionCommand \"\"\" if guild_id == GLOBAL_SCOPE : return await self . request ( Route ( \"GET\" , f \"/applications/ { application_id } /commands\" )) return await self . request ( Route ( \"GET\" , f \"/applications/ { application_id } /guilds/ { guild_id } /commands\" )) async def post_interaction_element ( self , app_id : \"Snowflake_Type\" , data : List [ Dict ], guild_id : \"Snowflake_Type\" = None ): \"\"\" Register an interaction element. parameters: app_id: The application ID of this bot guild_id: The ID of the guild this command is for, if this is a guild command data: List of your interaction data \"\"\" if guild_id == GLOBAL_SCOPE : return await self . request ( Route ( \"PUT\" , f \"/applications/ { app_id } /commands\" ), data = data ) return await self . request ( Route ( \"PUT\" , f \"/applications/ { app_id } /guilds/ { guild_id } /commands\" ), data = data ) async def post_initial_response ( self , payload : dict , interaction_id : str , token : str ) -> None : \"\"\" Post an initial response to an interaction. parameters: payload: the payload to send interaction_id: the id of the interaction token: the token of the interaction \"\"\" return await self . request ( Route ( \"POST\" , f \"/interactions/ { interaction_id } / { token } /callback\" ), data = payload ) async def post_followup ( self , payload : dict , application_id : \"Snowflake_Type\" , token : str ) -> None : \"\"\" Send a followup to an interaction. parameters: payload: the payload to send application_id: the id of the application token: the token of the interaction \"\"\" return await self . request ( Route ( \"POST\" , f \"/webhooks/ { application_id } / { token } \" ), data = payload ) async def edit_interaction_message ( self , payload : dict , application_id : \"Snowflake_Type\" , token : str , message_id : str = \"@original\" ) -> dict : \"\"\" Edits an existing interaction message. parameters: payload: The payload to send. application_id: The id of the application. token: The token of the interaction. message_id: The target message to edit. Defaults to @original which represents the initial response message. returns: The edited message data. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/webhooks/ { application_id } / { token } /messages/ { message_id } \" ), data = payload ) async def get_interaction_message ( self , application_id : str , token : str , message_id : str = \"@original\" ) -> dict : \"\"\" Gets an existing interaction message. parameters: payload: The payload to send. application_id: The id of the application. token: The token of the interaction. message_id: The target message to get. Defaults to @original which represents the initial response message. returns: The message data. \"\"\" return await self . request ( Route ( \"GET\" , f \"/webhooks/ { application_id } / { token } /messages/ { message_id } \" )) async def edit_application_command_permissions ( self , application_id : \"Snowflake_Type\" , scope : \"Snowflake_Type\" , cmd_id : \"Snowflake_Type\" , permissions : List [ dict ], ) -> dict : \"\"\" Edits command permissions for a specific command. parameters: application_id: the id of the application scope: The scope this command is in cmd_id: The command id to edit permissions: The permissions to set to this command returns: Guild Application Command Permissions \"\"\" return await self . request ( Route ( \"PUT\" , f \"/applications/ { application_id } /guilds/ { scope } /commands/ { cmd_id } /permissions\" ), data = permissions , ) async def batch_edit_application_command_permissions ( self , application_id : \"Snowflake_Type\" , scope : \"Snowflake_Type\" , data : List [ dict ] ) -> dict : \"\"\" Edit multiple command permissions within a single scope. parameters: application_id: the id of the application scope: The scope this command is in data: The permissions to be set returns: array of GuildApplicationCommandPermissions objects \"\"\" return await self . request ( Route ( \"PUT\" , f \"/applications/ { application_id } /guilds/ { scope } /commands/permissions\" ), data = data , ) async def get_application_command_permissions ( self , application_id : \"Snowflake_Type\" , scope : \"Snowflake_Type\" , cmd_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get permission data for a command. parameters: application_id: the id of the application scope: The scope this command is in cmd_id: The command id to edit returns: guild application command permissions \"\"\" return await self . request ( Route ( \"GET\" , f \"/applications/ { application_id } /guilds/ { scope } /commands/ { cmd_id } /permissions\" ) ) async def batch_get_application_command_permissions ( self , application_id : \"Snowflake_Type\" , scope : \"Snowflake_Type\" ) -> dict : \"\"\" Get permission data for all commands in a scope parameters: application_id: the id of the application scope: The scope this command is in returns: list of guild application command permissions \"\"\" return await self . request ( Route ( \"GET\" , f \"/applications/ { application_id } /guilds/ { scope } /commands/permissions\" )) async delete_interaction_element ( self , application_id , guild_id , command_id ) \u00b6 Delete an existing interaction element for this application. Attributes: Name Type Description application_id the what application to delete for guild_id specify a guild to delete commands from Source code in dis_snek/http_requests/interactions.py async def delete_interaction_element ( self , application_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" , command_id : \"Snowflake_Type\" ) -> None : \"\"\" Delete an existing interaction element for this application. Attributes: application_id: the what application to delete for guild_id: specify a guild to delete commands from command_id The command to delete \"\"\" if guild_id == GLOBAL_SCOPE : return await self . request ( Route ( \"DELETE\" , f \"/applications/ { application_id } /commands/ { command_id } \" )) return await self . request ( Route ( \"DELETE\" , f \"/applications/ { application_id } /guilds/ { guild_id } /commands/ { command_id } \" ) ) async get_interaction_element ( self , application_id , guild_id ) \u00b6 Get all interaction elements for this application from discord. Parameters: Name Type Description Default application_id Snowflake_Type the what application to query required guild_id Snowflake_Type specify a guild to get commands from required Returns: Type Description List[Dict] InteractionCommand Source code in dis_snek/http_requests/interactions.py async def get_interaction_element ( self , application_id : \"Snowflake_Type\" , guild_id : \"Snowflake_Type\" ) -> List [ Dict ]: \"\"\" Get all interaction elements for this application from discord. parameters: application_id: the what application to query guild_id: specify a guild to get commands from returns: InteractionCommand \"\"\" if guild_id == GLOBAL_SCOPE : return await self . request ( Route ( \"GET\" , f \"/applications/ { application_id } /commands\" )) return await self . request ( Route ( \"GET\" , f \"/applications/ { application_id } /guilds/ { guild_id } /commands\" )) async post_interaction_element ( self , app_id , data , guild_id = None ) \u00b6 Register an interaction element. Parameters: Name Type Description Default app_id Snowflake_Type The application ID of this bot required guild_id Snowflake_Type The ID of the guild this command is for, if this is a guild command None data List[Dict] List of your interaction data required Source code in dis_snek/http_requests/interactions.py async def post_interaction_element ( self , app_id : \"Snowflake_Type\" , data : List [ Dict ], guild_id : \"Snowflake_Type\" = None ): \"\"\" Register an interaction element. parameters: app_id: The application ID of this bot guild_id: The ID of the guild this command is for, if this is a guild command data: List of your interaction data \"\"\" if guild_id == GLOBAL_SCOPE : return await self . request ( Route ( \"PUT\" , f \"/applications/ { app_id } /commands\" ), data = data ) return await self . request ( Route ( \"PUT\" , f \"/applications/ { app_id } /guilds/ { guild_id } /commands\" ), data = data ) async post_initial_response ( self , payload , interaction_id , token ) \u00b6 Post an initial response to an interaction. Parameters: Name Type Description Default payload dict the payload to send required interaction_id str the id of the interaction required token str the token of the interaction required Source code in dis_snek/http_requests/interactions.py async def post_initial_response ( self , payload : dict , interaction_id : str , token : str ) -> None : \"\"\" Post an initial response to an interaction. parameters: payload: the payload to send interaction_id: the id of the interaction token: the token of the interaction \"\"\" return await self . request ( Route ( \"POST\" , f \"/interactions/ { interaction_id } / { token } /callback\" ), data = payload ) async post_followup ( self , payload , application_id , token ) \u00b6 Send a followup to an interaction. Parameters: Name Type Description Default payload dict the payload to send required application_id Snowflake_Type the id of the application required token str the token of the interaction required Source code in dis_snek/http_requests/interactions.py async def post_followup ( self , payload : dict , application_id : \"Snowflake_Type\" , token : str ) -> None : \"\"\" Send a followup to an interaction. parameters: payload: the payload to send application_id: the id of the application token: the token of the interaction \"\"\" return await self . request ( Route ( \"POST\" , f \"/webhooks/ { application_id } / { token } \" ), data = payload ) async edit_interaction_message ( self , payload , application_id , token , message_id = '@original' ) \u00b6 Edits an existing interaction message. Parameters: Name Type Description Default payload dict The payload to send. required application_id Snowflake_Type The id of the application. required token str The token of the interaction. required message_id str The target message to edit. Defaults to @original which represents the initial response message. '@original' Returns: Type Description dict The edited message data. Source code in dis_snek/http_requests/interactions.py async def edit_interaction_message ( self , payload : dict , application_id : \"Snowflake_Type\" , token : str , message_id : str = \"@original\" ) -> dict : \"\"\" Edits an existing interaction message. parameters: payload: The payload to send. application_id: The id of the application. token: The token of the interaction. message_id: The target message to edit. Defaults to @original which represents the initial response message. returns: The edited message data. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/webhooks/ { application_id } / { token } /messages/ { message_id } \" ), data = payload ) async get_interaction_message ( self , application_id , token , message_id = '@original' ) \u00b6 Gets an existing interaction message. Parameters: Name Type Description Default payload The payload to send. required application_id str The id of the application. required token str The token of the interaction. required message_id str The target message to get. Defaults to @original which represents the initial response message. '@original' Returns: Type Description dict The message data. Source code in dis_snek/http_requests/interactions.py async def get_interaction_message ( self , application_id : str , token : str , message_id : str = \"@original\" ) -> dict : \"\"\" Gets an existing interaction message. parameters: payload: The payload to send. application_id: The id of the application. token: The token of the interaction. message_id: The target message to get. Defaults to @original which represents the initial response message. returns: The message data. \"\"\" return await self . request ( Route ( \"GET\" , f \"/webhooks/ { application_id } / { token } /messages/ { message_id } \" )) async edit_application_command_permissions ( self , application_id , scope , cmd_id , permissions ) \u00b6 Edits command permissions for a specific command. Parameters: Name Type Description Default application_id Snowflake_Type the id of the application required scope Snowflake_Type The scope this command is in required cmd_id Snowflake_Type The command id to edit required permissions List[dict] The permissions to set to this command required Returns: Type Description dict Guild Application Command Permissions Source code in dis_snek/http_requests/interactions.py async def edit_application_command_permissions ( self , application_id : \"Snowflake_Type\" , scope : \"Snowflake_Type\" , cmd_id : \"Snowflake_Type\" , permissions : List [ dict ], ) -> dict : \"\"\" Edits command permissions for a specific command. parameters: application_id: the id of the application scope: The scope this command is in cmd_id: The command id to edit permissions: The permissions to set to this command returns: Guild Application Command Permissions \"\"\" return await self . request ( Route ( \"PUT\" , f \"/applications/ { application_id } /guilds/ { scope } /commands/ { cmd_id } /permissions\" ), data = permissions , ) async batch_edit_application_command_permissions ( self , application_id , scope , data ) \u00b6 Edit multiple command permissions within a single scope. Parameters: Name Type Description Default application_id Snowflake_Type the id of the application required scope Snowflake_Type The scope this command is in required data List[dict] The permissions to be set required Returns: Type Description dict array of GuildApplicationCommandPermissions objects Source code in dis_snek/http_requests/interactions.py async def batch_edit_application_command_permissions ( self , application_id : \"Snowflake_Type\" , scope : \"Snowflake_Type\" , data : List [ dict ] ) -> dict : \"\"\" Edit multiple command permissions within a single scope. parameters: application_id: the id of the application scope: The scope this command is in data: The permissions to be set returns: array of GuildApplicationCommandPermissions objects \"\"\" return await self . request ( Route ( \"PUT\" , f \"/applications/ { application_id } /guilds/ { scope } /commands/permissions\" ), data = data , ) async get_application_command_permissions ( self , application_id , scope , cmd_id ) \u00b6 Get permission data for a command. Parameters: Name Type Description Default application_id Snowflake_Type the id of the application required scope Snowflake_Type The scope this command is in required cmd_id Snowflake_Type The command id to edit required Returns: Type Description dict guild application command permissions Source code in dis_snek/http_requests/interactions.py async def get_application_command_permissions ( self , application_id : \"Snowflake_Type\" , scope : \"Snowflake_Type\" , cmd_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get permission data for a command. parameters: application_id: the id of the application scope: The scope this command is in cmd_id: The command id to edit returns: guild application command permissions \"\"\" return await self . request ( Route ( \"GET\" , f \"/applications/ { application_id } /guilds/ { scope } /commands/ { cmd_id } /permissions\" ) ) async batch_get_application_command_permissions ( self , application_id , scope ) \u00b6 Get permission data for all commands in a scope Parameters: Name Type Description Default application_id Snowflake_Type the id of the application required scope Snowflake_Type The scope this command is in required Returns: Type Description dict list of guild application command permissions Source code in dis_snek/http_requests/interactions.py async def batch_get_application_command_permissions ( self , application_id : \"Snowflake_Type\" , scope : \"Snowflake_Type\" ) -> dict : \"\"\" Get permission data for all commands in a scope parameters: application_id: the id of the application scope: The scope this command is in returns: list of guild application command permissions \"\"\" return await self . request ( Route ( \"GET\" , f \"/applications/ { application_id } /guilds/ { scope } /commands/permissions\" )) members \u00b6 MemberRequests \u00b6 Source code in dis_snek/http_requests/members.py class MemberRequests : request : Any async def get_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> Dict : \"\"\" Get a member of a guild by ID. parameters: guild_id: The id of the guild user_id: The user id to grab \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /members/ { user_id } \" )) async def list_members ( self , guild_id : \"Snowflake_Type\" , limit : int = 1 , after : \"Snowflake_Type\" = MISSING ) -> List [ Dict ]: \"\"\" List the members of a guild. parameters: guild_id: The ID of the guild limit: How many members to get (max 1000) after: Get IDs after this snowflake \"\"\" payload = dict ( limit = limit ) if after is not MISSING : payload [ \"after\" ] = after return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /members\" ), params = payload ) async def search_guild_members ( self , guild_id : \"Snowflake_Type\" , query : str , limit : int = 1 ) -> List [ Dict ]: \"\"\" Search a guild for members who's username or nickname starts with provided string. parameters: guild_id: The ID of the guild to search query: The string to search for limit: The number of members to return \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /members/search\" ), params = dict ( query = query , limit = limit ) ) async def modify_guild_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , nickname : str = MISSING , roles : List [ \"Snowflake_Type\" ] = MISSING , mute : bool = MISSING , deaf : bool = MISSING , channel_id : \"Snowflake_Type\" = MISSING , reason : str = MISSING , ) -> Dict : \"\"\" Modify attributes of a guild member. parameters: guild_id: The ID of the guild user_id: The ID of the user we're modifying nickname: Value to set users nickname to roles: Array of role ids the member is assigned mute: Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel deaf: Whether the user is deafened in voice channels channel_id: id of channel to move user to (if they are connected to voice) reason: An optional reason for the audit log returns: The updated member object \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /members/ { user_id } \" ), data = dict_filter_missing ( dict ( nick = nickname , roles = roles , mute = mute , deaf = deaf , channel_id = channel_id )), reason = reason , ) async def add_guild_member_role ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Adds a role to a guild member. parameters: guild_id: The ID of the guild user_id: The ID of the user role_id: The ID of the role to add reason: The reason for this action \"\"\" return await self . request ( Route ( \"PUT\" , f \"/guilds/ { guild_id } /members/ { user_id } /roles/ { role_id } \" )) async def remove_guild_member_role ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Remove a role from a guild member. parameters: guild_id: The ID of the guild user_id: The ID of the user role_id: The ID of the role to remove reason: The reason for this action \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /members/ { user_id } /roles/ { role_id } \" ), reason = reason ) async get_member ( self , guild_id , user_id ) \u00b6 Get a member of a guild by ID. Parameters: Name Type Description Default guild_id Snowflake_Type The id of the guild required user_id Snowflake_Type The user id to grab required Source code in dis_snek/http_requests/members.py async def get_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> Dict : \"\"\" Get a member of a guild by ID. parameters: guild_id: The id of the guild user_id: The user id to grab \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /members/ { user_id } \" )) async list_members ( self , guild_id , limit = 1 , after = MISSING ) \u00b6 List the members of a guild. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required limit int How many members to get (max 1000) 1 after Snowflake_Type Get IDs after this snowflake MISSING Source code in dis_snek/http_requests/members.py async def list_members ( self , guild_id : \"Snowflake_Type\" , limit : int = 1 , after : \"Snowflake_Type\" = MISSING ) -> List [ Dict ]: \"\"\" List the members of a guild. parameters: guild_id: The ID of the guild limit: How many members to get (max 1000) after: Get IDs after this snowflake \"\"\" payload = dict ( limit = limit ) if after is not MISSING : payload [ \"after\" ] = after return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /members\" ), params = payload ) async search_guild_members ( self , guild_id , query , limit = 1 ) \u00b6 Search a guild for members who's username or nickname starts with provided string. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild to search required query str The string to search for required limit int The number of members to return 1 Source code in dis_snek/http_requests/members.py async def search_guild_members ( self , guild_id : \"Snowflake_Type\" , query : str , limit : int = 1 ) -> List [ Dict ]: \"\"\" Search a guild for members who's username or nickname starts with provided string. parameters: guild_id: The ID of the guild to search query: The string to search for limit: The number of members to return \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /members/search\" ), params = dict ( query = query , limit = limit ) ) async modify_guild_member ( self , guild_id , user_id , nickname = MISSING , roles = MISSING , mute = MISSING , deaf = MISSING , channel_id = MISSING , reason = MISSING ) \u00b6 Modify attributes of a guild member. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required user_id Snowflake_Type The ID of the user we're modifying required nickname str Value to set users nickname to MISSING roles List[Snowflake_Type] Array of role ids the member is assigned MISSING mute bool Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel MISSING deaf bool Whether the user is deafened in voice channels MISSING channel_id Snowflake_Type id of channel to move user to (if they are connected to voice) MISSING reason str An optional reason for the audit log MISSING Returns: Type Description Dict The updated member object Source code in dis_snek/http_requests/members.py async def modify_guild_member ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , nickname : str = MISSING , roles : List [ \"Snowflake_Type\" ] = MISSING , mute : bool = MISSING , deaf : bool = MISSING , channel_id : \"Snowflake_Type\" = MISSING , reason : str = MISSING , ) -> Dict : \"\"\" Modify attributes of a guild member. parameters: guild_id: The ID of the guild user_id: The ID of the user we're modifying nickname: Value to set users nickname to roles: Array of role ids the member is assigned mute: Whether the user is muted in voice channels. Will throw a 400 if the user is not in a voice channel deaf: Whether the user is deafened in voice channels channel_id: id of channel to move user to (if they are connected to voice) reason: An optional reason for the audit log returns: The updated member object \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /members/ { user_id } \" ), data = dict_filter_missing ( dict ( nick = nickname , roles = roles , mute = mute , deaf = deaf , channel_id = channel_id )), reason = reason , ) async add_guild_member_role ( self , guild_id , user_id , role_id , reason = MISSING ) \u00b6 Adds a role to a guild member. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required user_id Snowflake_Type The ID of the user required role_id Snowflake_Type The ID of the role to add required reason str The reason for this action MISSING Source code in dis_snek/http_requests/members.py async def add_guild_member_role ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Adds a role to a guild member. parameters: guild_id: The ID of the guild user_id: The ID of the user role_id: The ID of the role to add reason: The reason for this action \"\"\" return await self . request ( Route ( \"PUT\" , f \"/guilds/ { guild_id } /members/ { user_id } /roles/ { role_id } \" )) async remove_guild_member_role ( self , guild_id , user_id , role_id , reason = MISSING ) \u00b6 Remove a role from a guild member. Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required user_id Snowflake_Type The ID of the user required role_id Snowflake_Type The ID of the role to remove required reason str The reason for this action MISSING Source code in dis_snek/http_requests/members.py async def remove_guild_member_role ( self , guild_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , role_id : \"Snowflake_Type\" , reason : str = MISSING ) -> None : \"\"\" Remove a role from a guild member. parameters: guild_id: The ID of the guild user_id: The ID of the user role_id: The ID of the role to remove reason: The reason for this action \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guilds/ { guild_id } /members/ { user_id } /roles/ { role_id } \" ), reason = reason ) messages \u00b6 MessageRequests \u00b6 Source code in dis_snek/http_requests/messages.py class MessageRequests : request : Any async def create_message ( self , payload : dict , channel_id : \"Snowflake_Type\" ) -> dict : \"\"\"Send a message to the specified channel.\"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /messages\" ), data = payload ) async def delete_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , reason : str = MISSING ) -> Any : \"\"\"Deletes a message from the specified channel. Incomplete.\"\"\" await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } /messages/ { message_id } \" ), reason = reason ) async def bulk_delete_messages ( self , channel_id : \"Snowflake_Type\" , message_ids : List [ \"Snowflake_Type\" ], reason : str = MISSING ) -> None : \"\"\" Delete multiple messages in a single request. parameters: channel_id: The id of the channel these messages are in message_ids: A list of message ids to delete reason: The reason for this action \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /messages/bulk-delete\" ), data = { \"messages\" : message_ids }, reason = reason ) async def get_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a specific message in the channel. Returns a message object on success. parameters: channel_id: the channel this message belongs to message_id: the id of the message returns: message or None \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /messages/ { message_id } \" )) async def pin_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> None : \"\"\"Pin a message to a channel parameters: channel_id: Channel to pin message to message_id: Message to pin \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { channel_id } /pins/ { message_id } \" )) async def unpin_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> None : \"\"\"Unpin a message to a channel parameters: channel_id: Channel to unpin message to message_id: Message to unpin \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } /pins/ { message_id } \" )) async def edit_message ( self , payload : dict , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , ) -> dict : \"\"\"Edit an existing message parameters: payload: channel_id: Channel of message to edit. message_id: Message to edit. returns: Message object of edited message \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/channels/ { channel_id } /messages/ { message_id } \" ), data = payload ) async def crosspost_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> dict : \"\"\" Crosspost a message in a News Channel to following channels. parameters: channel_id: Channel the message is in message_id: The id of the message to crosspost returns: message object \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /messages/ { message_id } /crosspost\" )) async create_message ( self , payload , channel_id ) \u00b6 Send a message to the specified channel. Source code in dis_snek/http_requests/messages.py async def create_message ( self , payload : dict , channel_id : \"Snowflake_Type\" ) -> dict : \"\"\"Send a message to the specified channel.\"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /messages\" ), data = payload ) async delete_message ( self , channel_id , message_id , reason = MISSING ) \u00b6 Deletes a message from the specified channel. Incomplete. Source code in dis_snek/http_requests/messages.py async def delete_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , reason : str = MISSING ) -> Any : \"\"\"Deletes a message from the specified channel. Incomplete.\"\"\" await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } /messages/ { message_id } \" ), reason = reason ) async bulk_delete_messages ( self , channel_id , message_ids , reason = MISSING ) \u00b6 Delete multiple messages in a single request. Parameters: Name Type Description Default channel_id Snowflake_Type The id of the channel these messages are in required message_ids List[Snowflake_Type] A list of message ids to delete required reason str The reason for this action MISSING Source code in dis_snek/http_requests/messages.py async def bulk_delete_messages ( self , channel_id : \"Snowflake_Type\" , message_ids : List [ \"Snowflake_Type\" ], reason : str = MISSING ) -> None : \"\"\" Delete multiple messages in a single request. parameters: channel_id: The id of the channel these messages are in message_ids: A list of message ids to delete reason: The reason for this action \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /messages/bulk-delete\" ), data = { \"messages\" : message_ids }, reason = reason ) async get_message ( self , channel_id , message_id ) \u00b6 Get a specific message in the channel. Returns a message object on success. Parameters: Name Type Description Default channel_id Snowflake_Type the channel this message belongs to required message_id Snowflake_Type the id of the message required Returns: Type Description dict message or None Source code in dis_snek/http_requests/messages.py async def get_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a specific message in the channel. Returns a message object on success. parameters: channel_id: the channel this message belongs to message_id: the id of the message returns: message or None \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /messages/ { message_id } \" )) async pin_message ( self , channel_id , message_id ) \u00b6 Pin a message to a channel Parameters: Name Type Description Default channel_id Snowflake_Type Channel to pin message to required message_id Snowflake_Type Message to pin required Source code in dis_snek/http_requests/messages.py async def pin_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> None : \"\"\"Pin a message to a channel parameters: channel_id: Channel to pin message to message_id: Message to pin \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { channel_id } /pins/ { message_id } \" )) async unpin_message ( self , channel_id , message_id ) \u00b6 Unpin a message to a channel Parameters: Name Type Description Default channel_id Snowflake_Type Channel to unpin message to required message_id Snowflake_Type Message to unpin required Source code in dis_snek/http_requests/messages.py async def unpin_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> None : \"\"\"Unpin a message to a channel parameters: channel_id: Channel to unpin message to message_id: Message to unpin \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } /pins/ { message_id } \" )) async edit_message ( self , payload , channel_id , message_id ) \u00b6 Edit an existing message Parameters: Name Type Description Default payload dict required channel_id Snowflake_Type Channel of message to edit. required message_id Snowflake_Type Message to edit. required Returns: Type Description dict Message object of edited message Source code in dis_snek/http_requests/messages.py async def edit_message ( self , payload : dict , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , ) -> dict : \"\"\"Edit an existing message parameters: payload: channel_id: Channel of message to edit. message_id: Message to edit. returns: Message object of edited message \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/channels/ { channel_id } /messages/ { message_id } \" ), data = payload ) async crosspost_message ( self , channel_id , message_id ) \u00b6 Crosspost a message in a News Channel to following channels. Parameters: Name Type Description Default channel_id Snowflake_Type Channel the message is in required message_id Snowflake_Type The id of the message to crosspost required Returns: Type Description dict message object Source code in dis_snek/http_requests/messages.py async def crosspost_message ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> dict : \"\"\" Crosspost a message in a News Channel to following channels. parameters: channel_id: Channel the message is in message_id: The id of the message to crosspost returns: message object \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /messages/ { message_id } /crosspost\" )) reactions \u00b6 ReactionRequests \u00b6 Source code in dis_snek/http_requests/reactions.py class ReactionRequests : request : Any async def create_reaction ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str ) -> None : \"\"\" Create a reaction for a message. parameters: channel_id: The channel this is taking place in message_id: The message to create a a reaction on emoji: The emoji to use (format: `name:id`) \"\"\" return await self . request ( Route ( \"PUT\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} /@me\" , channel_id = channel_id , message_id = message_id , emoji = emoji , ) ) async def remove_self_reaction ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str ) -> None : \"\"\" Remove client's reaction from a message parameters: channel_id: The channel this is taking place in. message_id: The message to remove the reaction on. emoji: The emoji to remove. (format: `name:id`) \"\"\" return await self . request ( Route ( \"DELETE\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} /@me\" , channel_id = channel_id , message_id = message_id , emoji = emoji , ) ) async def remove_user_reaction ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str , user_id : \"Snowflake_Type\" ) -> None : \"\"\" Remove user's reaction from a message parameters: channel_id: The channel this is taking place in message_id: The message to remove the reaction on. emoji: The emoji to remove. (format: `name:id`) user_id: The user to remove reaction of. \"\"\" return await self . request ( Route ( \"DELETE\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} / {user_id} \" , channel_id = channel_id , message_id = message_id , emoji = emoji , user_id = user_id , ) ) async def clear_reaction ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str ) -> None : \"\"\" Remove specific reaction from a message parameters: channel_id: The channel this is taking place in. message_id: The message to remove the reaction on. emoji: The emoji to remove. (format: `name:id`) \"\"\" return await self . request ( Route ( \"DELETE\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} \" , channel_id = channel_id , message_id = message_id , emoji = emoji , ) ) async def clear_reactions ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> None : \"\"\" Remove reactions from a message. parameters: channel_id: The channel this is taking place in. message_id: The message to clear reactions from. \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } /messages/ { message_id } /reactions\" )) async def get_reactions ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str , limit : int = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> list : \"\"\" Gets specific reaction from a message parameters: channel_id: The channel this is taking place in. message_id: The message to get the reaction. emoji: The emoji to get. (format: `name:id`) \"\"\" return await self . request ( Route ( \"GET\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} \" , channel_id = channel_id , message_id = message_id , emoji = emoji , ), params = dict_filter_missing ( dict ( limit = limit , after = after )), ) async create_reaction ( self , channel_id , message_id , emoji ) \u00b6 Create a reaction for a message. Parameters: Name Type Description Default channel_id Snowflake_Type The channel this is taking place in required message_id Snowflake_Type The message to create a a reaction on required emoji str The emoji to use (format: name:id ) required Source code in dis_snek/http_requests/reactions.py async def create_reaction ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str ) -> None : \"\"\" Create a reaction for a message. parameters: channel_id: The channel this is taking place in message_id: The message to create a a reaction on emoji: The emoji to use (format: `name:id`) \"\"\" return await self . request ( Route ( \"PUT\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} /@me\" , channel_id = channel_id , message_id = message_id , emoji = emoji , ) ) async remove_self_reaction ( self , channel_id , message_id , emoji ) \u00b6 Remove client's reaction from a message Parameters: Name Type Description Default channel_id Snowflake_Type The channel this is taking place in. required message_id Snowflake_Type The message to remove the reaction on. required emoji str The emoji to remove. (format: name:id ) required Source code in dis_snek/http_requests/reactions.py async def remove_self_reaction ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str ) -> None : \"\"\" Remove client's reaction from a message parameters: channel_id: The channel this is taking place in. message_id: The message to remove the reaction on. emoji: The emoji to remove. (format: `name:id`) \"\"\" return await self . request ( Route ( \"DELETE\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} /@me\" , channel_id = channel_id , message_id = message_id , emoji = emoji , ) ) async remove_user_reaction ( self , channel_id , message_id , emoji , user_id ) \u00b6 Remove user's reaction from a message Parameters: Name Type Description Default channel_id Snowflake_Type The channel this is taking place in required message_id Snowflake_Type The message to remove the reaction on. required emoji str The emoji to remove. (format: name:id ) required user_id Snowflake_Type The user to remove reaction of. required Source code in dis_snek/http_requests/reactions.py async def remove_user_reaction ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str , user_id : \"Snowflake_Type\" ) -> None : \"\"\" Remove user's reaction from a message parameters: channel_id: The channel this is taking place in message_id: The message to remove the reaction on. emoji: The emoji to remove. (format: `name:id`) user_id: The user to remove reaction of. \"\"\" return await self . request ( Route ( \"DELETE\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} / {user_id} \" , channel_id = channel_id , message_id = message_id , emoji = emoji , user_id = user_id , ) ) async clear_reaction ( self , channel_id , message_id , emoji ) \u00b6 Remove specific reaction from a message Parameters: Name Type Description Default channel_id Snowflake_Type The channel this is taking place in. required message_id Snowflake_Type The message to remove the reaction on. required emoji str The emoji to remove. (format: name:id ) required Source code in dis_snek/http_requests/reactions.py async def clear_reaction ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str ) -> None : \"\"\" Remove specific reaction from a message parameters: channel_id: The channel this is taking place in. message_id: The message to remove the reaction on. emoji: The emoji to remove. (format: `name:id`) \"\"\" return await self . request ( Route ( \"DELETE\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} \" , channel_id = channel_id , message_id = message_id , emoji = emoji , ) ) async clear_reactions ( self , channel_id , message_id ) \u00b6 Remove reactions from a message. Parameters: Name Type Description Default channel_id Snowflake_Type The channel this is taking place in. required message_id Snowflake_Type The message to clear reactions from. required Source code in dis_snek/http_requests/reactions.py async def clear_reactions ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" ) -> None : \"\"\" Remove reactions from a message. parameters: channel_id: The channel this is taking place in. message_id: The message to clear reactions from. \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } /messages/ { message_id } /reactions\" )) async get_reactions ( self , channel_id , message_id , emoji , limit = MISSING , after = MISSING ) \u00b6 Gets specific reaction from a message Parameters: Name Type Description Default channel_id Snowflake_Type The channel this is taking place in. required message_id Snowflake_Type The message to get the reaction. required emoji str The emoji to get. (format: name:id ) required Source code in dis_snek/http_requests/reactions.py async def get_reactions ( self , channel_id : \"Snowflake_Type\" , message_id : \"Snowflake_Type\" , emoji : str , limit : int = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> list : \"\"\" Gets specific reaction from a message parameters: channel_id: The channel this is taking place in. message_id: The message to get the reaction. emoji: The emoji to get. (format: `name:id`) \"\"\" return await self . request ( Route ( \"GET\" , \"/channels/ {channel_id} /messages/ {message_id} /reactions/ {emoji} \" , channel_id = channel_id , message_id = message_id , emoji = emoji , ), params = dict_filter_missing ( dict ( limit = limit , after = after )), ) stickers \u00b6 StickerRequests \u00b6 Source code in dis_snek/http_requests/stickers.py class StickerRequests : request : Any async def get_sticker ( self , sticker_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a specific sticker. parameters: sticker_id: The id of the sticker returns: Sticker or None \"\"\" return await self . request ( Route ( \"GET\" , f \"/stickers/ { sticker_id } \" )) async def list_nitro_sticker_packs ( self ) -> list : \"\"\" Gets the list of sticker packs available to Nitro subscribers. returns: List of sticker packs \"\"\" return await self . request ( Route ( \"GET\" , \"/sticker-packs\" )) async def list_guild_stickers ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get the stickers for a guild. parameters: guild_id: The guild to get stickers from returns: List of Stickers or None \"\"\" return await self . request ( Route ( \"GET\" , f \"/guild/ { guild_id } /stickers\" )) async def get_guild_sticker ( self , guild_id : \"Snowflake_Type\" , sticker_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a sticker from a guild. parameters: guild_id: The guild to get stickers from sticker_id: The sticker to get from the guild returns: Sticker or None \"\"\" return await self . request ( Route ( \"GET\" , f \"/guild/ { guild_id } /stickers/ { sticker_id } \" )) async def create_guild_sticker ( self , payload : \"FormData\" , guild_id : \"Snowflake_Type\" , reason : Optional [ str ] = MISSING ): \"\"\" Create a new sticker for the guild. Requires the MANAGE_EMOJIS_AND_STICKERS permission. parameters: payload: the payload to send. guild_id: The guild to create sticker at. reason: The reason for this action. returns: The new sticker data on success. \"\"\" return await self . request ( Route ( \"POST\" , f \"/guild/ { guild_id } /stickers\" ), data = payload , reason = reason ) async def modify_guild_sticker ( self , payload : dict , guild_id : \"Snowflake_Type\" , sticker_id : \"Snowflake_Type\" , reason : Optional [ str ] = MISSING ): \"\"\" Modify the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission. parameters: payload: the payload to send. guild_id: The guild of the target sticker. sticker_id: The sticker to modify. reason: The reason for this action. returns: The updated sticker data on success. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guild/ { guild_id } /stickers/ { sticker_id } \" ), data = payload , reason = reason ) async def delete_guild_sticker ( self , guild_id : \"Snowflake_Type\" , sticker_id : \"Snowflake_Type\" , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission. parameters: guild_id: The guild of the target sticker. sticker_id: The sticker to delete. reason: The reason for this action. returns: Returns 204 No Content on success. \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guild/ { guild_id } /stickers/ { sticker_id } \" ), reason = reason ) async get_sticker ( self , sticker_id ) \u00b6 Get a specific sticker. Parameters: Name Type Description Default sticker_id Snowflake_Type The id of the sticker required Returns: Type Description dict Sticker or None Source code in dis_snek/http_requests/stickers.py async def get_sticker ( self , sticker_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a specific sticker. parameters: sticker_id: The id of the sticker returns: Sticker or None \"\"\" return await self . request ( Route ( \"GET\" , f \"/stickers/ { sticker_id } \" )) async list_nitro_sticker_packs ( self ) \u00b6 Gets the list of sticker packs available to Nitro subscribers. Returns: Type Description list List of sticker packs Source code in dis_snek/http_requests/stickers.py async def list_nitro_sticker_packs ( self ) -> list : \"\"\" Gets the list of sticker packs available to Nitro subscribers. returns: List of sticker packs \"\"\" return await self . request ( Route ( \"GET\" , \"/sticker-packs\" )) async list_guild_stickers ( self , guild_id ) \u00b6 Get the stickers for a guild. Parameters: Name Type Description Default guild_id Snowflake_Type The guild to get stickers from required Returns: Type Description List[dict] List of Stickers or None Source code in dis_snek/http_requests/stickers.py async def list_guild_stickers ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get the stickers for a guild. parameters: guild_id: The guild to get stickers from returns: List of Stickers or None \"\"\" return await self . request ( Route ( \"GET\" , f \"/guild/ { guild_id } /stickers\" )) async get_guild_sticker ( self , guild_id , sticker_id ) \u00b6 Get a sticker from a guild. Parameters: Name Type Description Default guild_id Snowflake_Type The guild to get stickers from required sticker_id Snowflake_Type The sticker to get from the guild required Returns: Type Description dict Sticker or None Source code in dis_snek/http_requests/stickers.py async def get_guild_sticker ( self , guild_id : \"Snowflake_Type\" , sticker_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a sticker from a guild. parameters: guild_id: The guild to get stickers from sticker_id: The sticker to get from the guild returns: Sticker or None \"\"\" return await self . request ( Route ( \"GET\" , f \"/guild/ { guild_id } /stickers/ { sticker_id } \" )) async create_guild_sticker ( self , payload , guild_id , reason = MISSING ) \u00b6 Create a new sticker for the guild. Requires the MANAGE_EMOJIS_AND_STICKERS permission. Parameters: Name Type Description Default payload FormData the payload to send. required guild_id Snowflake_Type The guild to create sticker at. required reason Optional[str] The reason for this action. MISSING Returns: Type Description The new sticker data on success. Source code in dis_snek/http_requests/stickers.py async def create_guild_sticker ( self , payload : \"FormData\" , guild_id : \"Snowflake_Type\" , reason : Optional [ str ] = MISSING ): \"\"\" Create a new sticker for the guild. Requires the MANAGE_EMOJIS_AND_STICKERS permission. parameters: payload: the payload to send. guild_id: The guild to create sticker at. reason: The reason for this action. returns: The new sticker data on success. \"\"\" return await self . request ( Route ( \"POST\" , f \"/guild/ { guild_id } /stickers\" ), data = payload , reason = reason ) async modify_guild_sticker ( self , payload , guild_id , sticker_id , reason = MISSING ) \u00b6 Modify the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission. Parameters: Name Type Description Default payload dict the payload to send. required guild_id Snowflake_Type The guild of the target sticker. required sticker_id Snowflake_Type The sticker to modify. required reason Optional[str] The reason for this action. MISSING Returns: Type Description The updated sticker data on success. Source code in dis_snek/http_requests/stickers.py async def modify_guild_sticker ( self , payload : dict , guild_id : \"Snowflake_Type\" , sticker_id : \"Snowflake_Type\" , reason : Optional [ str ] = MISSING ): \"\"\" Modify the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission. parameters: payload: the payload to send. guild_id: The guild of the target sticker. sticker_id: The sticker to modify. reason: The reason for this action. returns: The updated sticker data on success. \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guild/ { guild_id } /stickers/ { sticker_id } \" ), data = payload , reason = reason ) async delete_guild_sticker ( self , guild_id , sticker_id , reason = MISSING ) \u00b6 Delete the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission. Parameters: Name Type Description Default guild_id Snowflake_Type The guild of the target sticker. required sticker_id Snowflake_Type The sticker to delete. required reason Optional[str] The reason for this action. MISSING Returns: Type Description None Returns 204 No Content on success. Source code in dis_snek/http_requests/stickers.py async def delete_guild_sticker ( self , guild_id : \"Snowflake_Type\" , sticker_id : \"Snowflake_Type\" , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete the given sticker. Requires the MANAGE_EMOJIS_AND_STICKERS permission. parameters: guild_id: The guild of the target sticker. sticker_id: The sticker to delete. reason: The reason for this action. returns: Returns 204 No Content on success. \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/guild/ { guild_id } /stickers/ { sticker_id } \" ), reason = reason ) threads \u00b6 ThreadRequests \u00b6 Source code in dis_snek/http_requests/threads.py class ThreadRequests : request : Any async def join_thread ( self , thread_id : \"Snowflake_Type\" ) -> None : \"\"\" Join a thread. parameters: thread_id: The thread to join. \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { thread_id } /thread-members/@me\" )) async def leave_thread ( self , thread_id : \"Snowflake_Type\" ) -> None : \"\"\" Leave a thread. parameters: thread_id: The thread to leave. \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { thread_id } /thread-members/@me\" )) async def add_thread_member ( self , thread_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> None : \"\"\" Add another user to a thread. parameters: thread_id: The ID of the thread user_id: The ID of the user to add \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { thread_id } /thread-members/ { user_id } \" )) async def remove_thread_member ( self , thread_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> None : \"\"\" Remove another user from a thread. parameters: thread_id: The ID of the thread user_id: The ID of the user to remove \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { thread_id } /thread-members/ { user_id } \" )) async def list_thread_members ( self , thread_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get a list of members in the thread. parameters: thread_id: the id of the thread returns: a list of member objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { thread_id } /thread-members\" )) async def list_public_archived_threads ( self , channel_id : \"Snowflake_Type\" , limit : int = None , before : Optional [ \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Get a list of archived public threads in a channel. parameters: channel_id: The channel to get threads from limit: Optional limit of threads to before: Get threads before this snowflake returns: a list of threads \"\"\" payload = {} if limit : payload [ \"limit\" ] = limit if before : payload [ \"before\" ] = timestamp_converter ( before ) return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /threads/archived/public\" ), params = payload ) async def list_private_archived_threads ( self , channel_id : \"Snowflake_Type\" , limit : int = None , before : Optional [ \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Get a list of archived private threads in a channel. parameters: channel_id: The channel to get threads from limit: Optional limit of threads to before: Get threads before this snowflake returns: a list of threads \"\"\" payload = {} if limit : payload [ \"limit\" ] = limit if before : payload [ \"before\" ] = before return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /threads/archived/private\" ), params = payload ) async def list_joined_private_archived_threads ( self , channel_id : \"Snowflake_Type\" , limit : int = None , before : Optional [ \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Get a list of archived private threads in a channel that you have joined. parameters: channel_id: The channel to get threads from limit: Optional limit of threads to before: Get threads before this snowflake returns: a list of threads \"\"\" payload = {} if limit : payload [ \"limit\" ] = limit if before : payload [ \"before\" ] = before return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /users/@me/threads/archived/private\" ), params = payload ) async def list_active_threads ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" List active threads within a guild. parameters: guild_id: the guild id to get threads from returns: A list of active threads \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /threads/active\" )) async def create_thread ( self , channel_id : \"Snowflake_Type\" , name : str , auto_archive_duration : int , thread_type : int = None , invitable : Optional [ bool ] = None , message_id : Optional [ \"Snowflake_Type\" ] = None , reason : str = MISSING , ) -> dict : \"\"\" Create a thread in the given channel. Can either create a thread with or without a message parameters: channel_id: The ID of the channel to create this thread in name: The name of the thread auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080 thread_type: The type of thread, defaults to public. ignored if creating thread from a message invitable: message_id: An optional message to create a thread from. reason: An optional reason for the audit log returns: The created thread \"\"\" payload = dict ( name = name , auto_archive_duration = auto_archive_duration ) if message_id : return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /messages/ { message_id } /threads\" ), data = payload , reason = reason ) else : payload [ \"type\" ] = thread_type payload [ \"invitable\" ] = invitable return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /threads\" ), data = payload , reason = reason ) async join_thread ( self , thread_id ) \u00b6 Join a thread. Parameters: Name Type Description Default thread_id Snowflake_Type The thread to join. required Source code in dis_snek/http_requests/threads.py async def join_thread ( self , thread_id : \"Snowflake_Type\" ) -> None : \"\"\" Join a thread. parameters: thread_id: The thread to join. \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { thread_id } /thread-members/@me\" )) async leave_thread ( self , thread_id ) \u00b6 Leave a thread. Parameters: Name Type Description Default thread_id Snowflake_Type The thread to leave. required Source code in dis_snek/http_requests/threads.py async def leave_thread ( self , thread_id : \"Snowflake_Type\" ) -> None : \"\"\" Leave a thread. parameters: thread_id: The thread to leave. \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { thread_id } /thread-members/@me\" )) async add_thread_member ( self , thread_id , user_id ) \u00b6 Add another user to a thread. Parameters: Name Type Description Default thread_id Snowflake_Type The ID of the thread required user_id Snowflake_Type The ID of the user to add required Source code in dis_snek/http_requests/threads.py async def add_thread_member ( self , thread_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> None : \"\"\" Add another user to a thread. parameters: thread_id: The ID of the thread user_id: The ID of the user to add \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { thread_id } /thread-members/ { user_id } \" )) async remove_thread_member ( self , thread_id , user_id ) \u00b6 Remove another user from a thread. Parameters: Name Type Description Default thread_id Snowflake_Type The ID of the thread required user_id Snowflake_Type The ID of the user to remove required Source code in dis_snek/http_requests/threads.py async def remove_thread_member ( self , thread_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> None : \"\"\" Remove another user from a thread. parameters: thread_id: The ID of the thread user_id: The ID of the user to remove \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { thread_id } /thread-members/ { user_id } \" )) async list_thread_members ( self , thread_id ) \u00b6 Get a list of members in the thread. Parameters: Name Type Description Default thread_id Snowflake_Type the id of the thread required Returns: Type Description List[dict] a list of member objects Source code in dis_snek/http_requests/threads.py async def list_thread_members ( self , thread_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Get a list of members in the thread. parameters: thread_id: the id of the thread returns: a list of member objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { thread_id } /thread-members\" )) async list_public_archived_threads ( self , channel_id , limit = None , before = None ) \u00b6 Get a list of archived public threads in a channel. Parameters: Name Type Description Default channel_id Snowflake_Type The channel to get threads from required limit int Optional limit of threads to None before Optional[Snowflake_Type] Get threads before this snowflake None Returns: Type Description dict a list of threads Source code in dis_snek/http_requests/threads.py async def list_public_archived_threads ( self , channel_id : \"Snowflake_Type\" , limit : int = None , before : Optional [ \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Get a list of archived public threads in a channel. parameters: channel_id: The channel to get threads from limit: Optional limit of threads to before: Get threads before this snowflake returns: a list of threads \"\"\" payload = {} if limit : payload [ \"limit\" ] = limit if before : payload [ \"before\" ] = timestamp_converter ( before ) return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /threads/archived/public\" ), params = payload ) async list_private_archived_threads ( self , channel_id , limit = None , before = None ) \u00b6 Get a list of archived private threads in a channel. Parameters: Name Type Description Default channel_id Snowflake_Type The channel to get threads from required limit int Optional limit of threads to None before Optional[Snowflake_Type] Get threads before this snowflake None Returns: Type Description dict a list of threads Source code in dis_snek/http_requests/threads.py async def list_private_archived_threads ( self , channel_id : \"Snowflake_Type\" , limit : int = None , before : Optional [ \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Get a list of archived private threads in a channel. parameters: channel_id: The channel to get threads from limit: Optional limit of threads to before: Get threads before this snowflake returns: a list of threads \"\"\" payload = {} if limit : payload [ \"limit\" ] = limit if before : payload [ \"before\" ] = before return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /threads/archived/private\" ), params = payload ) async list_joined_private_archived_threads ( self , channel_id , limit = None , before = None ) \u00b6 Get a list of archived private threads in a channel that you have joined. Parameters: Name Type Description Default channel_id Snowflake_Type The channel to get threads from required limit int Optional limit of threads to None before Optional[Snowflake_Type] Get threads before this snowflake None Returns: Type Description dict a list of threads Source code in dis_snek/http_requests/threads.py async def list_joined_private_archived_threads ( self , channel_id : \"Snowflake_Type\" , limit : int = None , before : Optional [ \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Get a list of archived private threads in a channel that you have joined. parameters: channel_id: The channel to get threads from limit: Optional limit of threads to before: Get threads before this snowflake returns: a list of threads \"\"\" payload = {} if limit : payload [ \"limit\" ] = limit if before : payload [ \"before\" ] = before return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /users/@me/threads/archived/private\" ), params = payload ) async list_active_threads ( self , guild_id ) \u00b6 List active threads within a guild. Parameters: Name Type Description Default guild_id Snowflake_Type the guild id to get threads from required Returns: Type Description dict A list of active threads Source code in dis_snek/http_requests/threads.py async def list_active_threads ( self , guild_id : \"Snowflake_Type\" ) -> dict : \"\"\" List active threads within a guild. parameters: guild_id: the guild id to get threads from returns: A list of active threads \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /threads/active\" )) async create_thread ( self , channel_id , name , auto_archive_duration , thread_type = None , invitable = None , message_id = None , reason = MISSING ) \u00b6 Create a thread in the given channel. Can either create a thread with or without a message Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to create this thread in required name str The name of the thread required auto_archive_duration int duration in minutes to automatically archive the thread after recent activity, required can be set to 60, 1440, 4320, 10080 required thread_type int The type of thread, defaults to public. ignored if creating thread from a message None invitable Optional[bool] None message_id Optional[Snowflake_Type] An optional message to create a thread from. None reason str An optional reason for the audit log MISSING Returns: Type Description dict The created thread Source code in dis_snek/http_requests/threads.py async def create_thread ( self , channel_id : \"Snowflake_Type\" , name : str , auto_archive_duration : int , thread_type : int = None , invitable : Optional [ bool ] = None , message_id : Optional [ \"Snowflake_Type\" ] = None , reason : str = MISSING , ) -> dict : \"\"\" Create a thread in the given channel. Can either create a thread with or without a message parameters: channel_id: The ID of the channel to create this thread in name: The name of the thread auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080 thread_type: The type of thread, defaults to public. ignored if creating thread from a message invitable: message_id: An optional message to create a thread from. reason: An optional reason for the audit log returns: The created thread \"\"\" payload = dict ( name = name , auto_archive_duration = auto_archive_duration ) if message_id : return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /messages/ { message_id } /threads\" ), data = payload , reason = reason ) else : payload [ \"type\" ] = thread_type payload [ \"invitable\" ] = invitable return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /threads\" ), data = payload , reason = reason ) users \u00b6 UserRequests \u00b6 Source code in dis_snek/http_requests/users.py class UserRequests : request : Any async def get_current_user ( self ): \"\"\" Shortcut to get requester's user. \"\"\" return self . get_user ( \"@me\" ) async def get_user ( self , user_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a user object for a given user ID. parameters: user_id: The user to get. returns: user \"\"\" return await self . request ( Route ( \"GET\" , f \"/users/ { user_id } \" )) async def modify_client_user ( self , payload : dict ) -> dict : \"\"\" Modify the user account settings. parameters: payload: The data to send. \"\"\" return await self . request ( Route ( \"PATCH\" , \"/users/@me\" ), data = payload ) async def get_user_guilds ( self ) -> list : \"\"\" Returns a list of partial guild objects the current user is a member of. Requires the guilds OAuth2 scope. \"\"\" return await self . request ( Route ( \"GET\" , \"/users/@me/guilds\" )) async def leave_guild ( self , guild_id ) -> dict : \"\"\" Leave a guild. Returns a 204 empty response on success. parameters: guild_id: The guild to leave from. \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/users/@me/guilds/ { guild_id } \" )) async def create_dm ( self , recipient_id ) -> dict : \"\"\" Create a new DM channel with a user. Returns a DM channel object. parameters: recipient_id: The recipient to open a DM channel with. \"\"\" return await self . request ( Route ( \"POST\" , \"/users/@me/channels\" ), data = dict ( recipient_id = recipient_id )) async def create_group_dm ( self , payload : dict ) -> dict : \"\"\" Create a new group DM channel with multiple users. parameters: payload: The data to send. \"\"\" return await self . request ( Route ( \"POST\" , \"/users/@me/channels\" ), data = payload ) async def get_user_connections ( self ) -> list : \"\"\" Returns a list of connection objects. Requires the connections OAuth2 scope. \"\"\" return await self . request ( Route ( \"GET\" , \"/users/@me/connections\" )) async def group_dm_add_recipient ( self , channel_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , access_token : str , nick : str = None ) -> None : \"\"\" Adds a recipient to a Group DM using their access token. parameters: channel_id: The ID of the group dm user_id: The ID of the user to add access_token: Access token of a user that has granted your app the gdm.join scope nick: Nickname of the user being added \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { channel_id } /recipients/ { user_id } \" ), data = { \"access_token\" : access_token , \"nick\" : nick }, ) async def group_dm_remove_recipient ( self , channel_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> None : \"\"\" Remove a recipient from the group dm. parameters: channel_id: The ID of the group dm user_id: The ID of the user to remove \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } /recipients/ { user_id } \" )) async def modify_current_user_nick ( self , guild_id : \"Snowflake_Type\" , nickname : str = None ) -> None : \"\"\" Modifies the nickname of the current user in a guild parameters: guild_id: The ID of the guild nickname: The new nickname to use \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /members/@me/nick\" ), data = { \"nick\" : nickname }) async get_current_user ( self ) \u00b6 Shortcut to get requester's user. Source code in dis_snek/http_requests/users.py async def get_current_user ( self ): \"\"\" Shortcut to get requester's user. \"\"\" return self . get_user ( \"@me\" ) async get_user ( self , user_id ) \u00b6 Get a user object for a given user ID. Parameters: Name Type Description Default user_id Snowflake_Type The user to get. required Returns: Type Description dict user Source code in dis_snek/http_requests/users.py async def get_user ( self , user_id : \"Snowflake_Type\" ) -> dict : \"\"\" Get a user object for a given user ID. parameters: user_id: The user to get. returns: user \"\"\" return await self . request ( Route ( \"GET\" , f \"/users/ { user_id } \" )) async modify_client_user ( self , payload ) \u00b6 Modify the user account settings. Parameters: Name Type Description Default payload dict The data to send. required Source code in dis_snek/http_requests/users.py async def modify_client_user ( self , payload : dict ) -> dict : \"\"\" Modify the user account settings. parameters: payload: The data to send. \"\"\" return await self . request ( Route ( \"PATCH\" , \"/users/@me\" ), data = payload ) async get_user_guilds ( self ) \u00b6 Returns a list of partial guild objects the current user is a member of. Requires the guilds OAuth2 scope. Source code in dis_snek/http_requests/users.py async def get_user_guilds ( self ) -> list : \"\"\" Returns a list of partial guild objects the current user is a member of. Requires the guilds OAuth2 scope. \"\"\" return await self . request ( Route ( \"GET\" , \"/users/@me/guilds\" )) async leave_guild ( self , guild_id ) \u00b6 Leave a guild. Returns a 204 empty response on success. Parameters: Name Type Description Default guild_id The guild to leave from. required Source code in dis_snek/http_requests/users.py async def leave_guild ( self , guild_id ) -> dict : \"\"\" Leave a guild. Returns a 204 empty response on success. parameters: guild_id: The guild to leave from. \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/users/@me/guilds/ { guild_id } \" )) async create_dm ( self , recipient_id ) \u00b6 Create a new DM channel with a user. Returns a DM channel object. Parameters: Name Type Description Default recipient_id The recipient to open a DM channel with. required Source code in dis_snek/http_requests/users.py async def create_dm ( self , recipient_id ) -> dict : \"\"\" Create a new DM channel with a user. Returns a DM channel object. parameters: recipient_id: The recipient to open a DM channel with. \"\"\" return await self . request ( Route ( \"POST\" , \"/users/@me/channels\" ), data = dict ( recipient_id = recipient_id )) async create_group_dm ( self , payload ) \u00b6 Create a new group DM channel with multiple users. Parameters: Name Type Description Default payload dict The data to send. required Source code in dis_snek/http_requests/users.py async def create_group_dm ( self , payload : dict ) -> dict : \"\"\" Create a new group DM channel with multiple users. parameters: payload: The data to send. \"\"\" return await self . request ( Route ( \"POST\" , \"/users/@me/channels\" ), data = payload ) async get_user_connections ( self ) \u00b6 Returns a list of connection objects. Requires the connections OAuth2 scope. Source code in dis_snek/http_requests/users.py async def get_user_connections ( self ) -> list : \"\"\" Returns a list of connection objects. Requires the connections OAuth2 scope. \"\"\" return await self . request ( Route ( \"GET\" , \"/users/@me/connections\" )) async group_dm_add_recipient ( self , channel_id , user_id , access_token , nick = None ) \u00b6 Adds a recipient to a Group DM using their access token. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the group dm required user_id Snowflake_Type The ID of the user to add required access_token str Access token of a user that has granted your app the gdm.join scope required nick str Nickname of the user being added None Source code in dis_snek/http_requests/users.py async def group_dm_add_recipient ( self , channel_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" , access_token : str , nick : str = None ) -> None : \"\"\" Adds a recipient to a Group DM using their access token. parameters: channel_id: The ID of the group dm user_id: The ID of the user to add access_token: Access token of a user that has granted your app the gdm.join scope nick: Nickname of the user being added \"\"\" return await self . request ( Route ( \"PUT\" , f \"/channels/ { channel_id } /recipients/ { user_id } \" ), data = { \"access_token\" : access_token , \"nick\" : nick }, ) async group_dm_remove_recipient ( self , channel_id , user_id ) \u00b6 Remove a recipient from the group dm. Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the group dm required user_id Snowflake_Type The ID of the user to remove required Source code in dis_snek/http_requests/users.py async def group_dm_remove_recipient ( self , channel_id : \"Snowflake_Type\" , user_id : \"Snowflake_Type\" ) -> None : \"\"\" Remove a recipient from the group dm. parameters: channel_id: The ID of the group dm user_id: The ID of the user to remove \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/channels/ { channel_id } /recipients/ { user_id } \" )) async modify_current_user_nick ( self , guild_id , nickname = None ) \u00b6 Modifies the nickname of the current user in a guild Parameters: Name Type Description Default guild_id Snowflake_Type The ID of the guild required nickname str The new nickname to use None Source code in dis_snek/http_requests/users.py async def modify_current_user_nick ( self , guild_id : \"Snowflake_Type\" , nickname : str = None ) -> None : \"\"\" Modifies the nickname of the current user in a guild parameters: guild_id: The ID of the guild nickname: The new nickname to use \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/guilds/ { guild_id } /members/@me/nick\" ), data = { \"nick\" : nickname }) webhooks \u00b6 WebhookRequests \u00b6 Source code in dis_snek/http_requests/webhooks.py class WebhookRequests : request : Any async def create_webhook ( self , channel_id : \"Snowflake_Type\" , name : str , avatar : Any = None ) -> dict : \"\"\" Create a new webhook. parameters: channel_id: The id of the channel to add this webhook to name: name of the webhook (1-80 characters) avatar: The image for the default webhook avatar \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /webhooks\" ), data = { \"name\" : name , \"avatar\" : avatar } ) async def get_channel_webhooks ( self , channel_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Return a list of channel webhook objects. parameters: channel_id: The id of the channel to query returns: List of webhook objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /webhooks\" )) async def get_guild_webhooks ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Return a list of guild webhook objects. parameters: guild_id: The id of the guild to query returns: List of webhook objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /webhooks\" )) async def get_webhook ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str = None ) -> dict : \"\"\" Return the new webhook object for the given id. parameters: webhook_id: The ID of the webhook to get webhook_token: The token for the webhook returns: Webhook object \"\"\" endpoint = f \"/webhooks/ { webhook_id }{ f '/ { webhook_token } ' if webhook_token else '' } \" return await self . request ( Route ( \"GET\" , endpoint )) async def modify_webhook ( self , webhook_id : \"Snowflake_Type\" , name : str , avatar : Any , channel_id : \"Snowflake_Type\" , webhook_token : str = None , ) -> dict : \"\"\" Modify a webhook. parameters: name: the default name of the webhook avatar: image for the default webhook avatar channel_id: the new channel id this webhook should be moved to webhook_id: The ID of the webhook to modify webhook_token: The token for the webhook \"\"\" endpoint = f \"/webhooks/ { webhook_id }{ f '/ { webhook_token } ' if webhook_token else '' } \" return await self . request ( Route ( \"PATCH\" , endpoint ), data = { \"name\" : name , \"avatar\" : avatar , \"channel_id\" : channel_id } ) async def delete_webhook ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str = None ) -> dict : \"\"\" Delete a webhook parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook returns: Webhook object \"\"\" endpoint = f \"/webhooks/ { webhook_id }{ f '/ { webhook_token } ' if webhook_token else '' } \" return await self . request ( Route ( \"DELETE\" , endpoint )) async def execute_webhook ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str , payload : dict , wait = False , thread_id : \"Snowflake_Type\" = None , ) -> dict : \"\"\" Execute a webhook. Basically send a message as the webhook. parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook payload: The JSON payload for the message wait: Waits for server confirmation of message send before response thread_id: Send a message to the specified thread suffix: An optional suffix to add to the end of the endpoint address returns: The sent `message`, if `wait` is True else None \"\"\" return await self . request ( Route ( \"POST\" , f \"/webhooks/ { webhook_id } / { webhook_token } \" ), params = dict_filter_none ({ \"wait\" : \"true\" if wait else \"false\" , \"thread_id\" : thread_id }), data = payload , ) async def get_webhook_message ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str , message_id : \"Snowflake_Type\" ) -> dict : \"\"\" Returns a previously-sent webhook message from the same token. Returns a message object on success. parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook message_id: The ID of a message sent by this webhook returns: A message object on success \"\"\" return await self . request ( Route ( \"GET\" , f \"/webhooks/ { webhook_id } / { webhook_token } /messages/ { message_id } \" )) async def edit_webhook_message ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str , message_id : \"Snowflake_Type\" , payload : dict ) -> dict : \"\"\" Edits a previously-sent webhook message from the same token. parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook message_id: The ID of a message sent by this webhook payload: The JSON payload for the message returns: The updated message on success \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/webhooks/ { webhook_id } / { webhook_token } /messages/ { message_id } \" ), data = payload ) async def delete_webhook_message ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str , message_id : \"Snowflake_Type\" ) -> None : \"\"\" Delete a message that was created by the same token. parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook message_id: The ID of a message sent by this webhook \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/webhooks/ { webhook_id } / { webhook_token } /messages/ { message_id } \" )) async create_webhook ( self , channel_id , name , avatar = None ) \u00b6 Create a new webhook. Parameters: Name Type Description Default channel_id Snowflake_Type The id of the channel to add this webhook to required name str name of the webhook (1-80 characters) required avatar Any The image for the default webhook avatar None Source code in dis_snek/http_requests/webhooks.py async def create_webhook ( self , channel_id : \"Snowflake_Type\" , name : str , avatar : Any = None ) -> dict : \"\"\" Create a new webhook. parameters: channel_id: The id of the channel to add this webhook to name: name of the webhook (1-80 characters) avatar: The image for the default webhook avatar \"\"\" return await self . request ( Route ( \"POST\" , f \"/channels/ { channel_id } /webhooks\" ), data = { \"name\" : name , \"avatar\" : avatar } ) async get_channel_webhooks ( self , channel_id ) \u00b6 Return a list of channel webhook objects. Parameters: Name Type Description Default channel_id Snowflake_Type The id of the channel to query required Returns: Type Description List[dict] List of webhook objects Source code in dis_snek/http_requests/webhooks.py async def get_channel_webhooks ( self , channel_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Return a list of channel webhook objects. parameters: channel_id: The id of the channel to query returns: List of webhook objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/channels/ { channel_id } /webhooks\" )) async get_guild_webhooks ( self , guild_id ) \u00b6 Return a list of guild webhook objects. Parameters: Name Type Description Default guild_id Snowflake_Type The id of the guild to query required Returns: Type Description List[dict] List of webhook objects Source code in dis_snek/http_requests/webhooks.py async def get_guild_webhooks ( self , guild_id : \"Snowflake_Type\" ) -> List [ dict ]: \"\"\" Return a list of guild webhook objects. parameters: guild_id: The id of the guild to query returns: List of webhook objects \"\"\" return await self . request ( Route ( \"GET\" , f \"/guilds/ { guild_id } /webhooks\" )) async get_webhook ( self , webhook_id , webhook_token = None ) \u00b6 Return the new webhook object for the given id. Parameters: Name Type Description Default webhook_id Snowflake_Type The ID of the webhook to get required webhook_token str The token for the webhook None Returns: Type Description dict Webhook object Source code in dis_snek/http_requests/webhooks.py async def get_webhook ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str = None ) -> dict : \"\"\" Return the new webhook object for the given id. parameters: webhook_id: The ID of the webhook to get webhook_token: The token for the webhook returns: Webhook object \"\"\" endpoint = f \"/webhooks/ { webhook_id }{ f '/ { webhook_token } ' if webhook_token else '' } \" return await self . request ( Route ( \"GET\" , endpoint )) async modify_webhook ( self , webhook_id , name , avatar , channel_id , webhook_token = None ) \u00b6 Modify a webhook. Parameters: Name Type Description Default name str the default name of the webhook required avatar Any image for the default webhook avatar required channel_id Snowflake_Type the new channel id this webhook should be moved to required webhook_id Snowflake_Type The ID of the webhook to modify required webhook_token str The token for the webhook None Source code in dis_snek/http_requests/webhooks.py async def modify_webhook ( self , webhook_id : \"Snowflake_Type\" , name : str , avatar : Any , channel_id : \"Snowflake_Type\" , webhook_token : str = None , ) -> dict : \"\"\" Modify a webhook. parameters: name: the default name of the webhook avatar: image for the default webhook avatar channel_id: the new channel id this webhook should be moved to webhook_id: The ID of the webhook to modify webhook_token: The token for the webhook \"\"\" endpoint = f \"/webhooks/ { webhook_id }{ f '/ { webhook_token } ' if webhook_token else '' } \" return await self . request ( Route ( \"PATCH\" , endpoint ), data = { \"name\" : name , \"avatar\" : avatar , \"channel_id\" : channel_id } ) async delete_webhook ( self , webhook_id , webhook_token = None ) \u00b6 Delete a webhook Parameters: Name Type Description Default webhook_id Snowflake_Type The ID of the webhook to delete required webhook_token str The token for the webhook None Returns: Type Description dict Webhook object Source code in dis_snek/http_requests/webhooks.py async def delete_webhook ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str = None ) -> dict : \"\"\" Delete a webhook parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook returns: Webhook object \"\"\" endpoint = f \"/webhooks/ { webhook_id }{ f '/ { webhook_token } ' if webhook_token else '' } \" return await self . request ( Route ( \"DELETE\" , endpoint )) async execute_webhook ( self , webhook_id , webhook_token , payload , wait = False , thread_id = None ) \u00b6 Execute a webhook. Basically send a message as the webhook. Parameters: Name Type Description Default webhook_id Snowflake_Type The ID of the webhook to delete required webhook_token str The token for the webhook required payload dict The JSON payload for the message required wait Waits for server confirmation of message send before response False thread_id Snowflake_Type Send a message to the specified thread None suffix An optional suffix to add to the end of the endpoint address required Returns: Type Description dict The sent message , if wait is True else None Source code in dis_snek/http_requests/webhooks.py async def execute_webhook ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str , payload : dict , wait = False , thread_id : \"Snowflake_Type\" = None , ) -> dict : \"\"\" Execute a webhook. Basically send a message as the webhook. parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook payload: The JSON payload for the message wait: Waits for server confirmation of message send before response thread_id: Send a message to the specified thread suffix: An optional suffix to add to the end of the endpoint address returns: The sent `message`, if `wait` is True else None \"\"\" return await self . request ( Route ( \"POST\" , f \"/webhooks/ { webhook_id } / { webhook_token } \" ), params = dict_filter_none ({ \"wait\" : \"true\" if wait else \"false\" , \"thread_id\" : thread_id }), data = payload , ) async get_webhook_message ( self , webhook_id , webhook_token , message_id ) \u00b6 Returns a previously-sent webhook message from the same token. Returns a message object on success. Parameters: Name Type Description Default webhook_id Snowflake_Type The ID of the webhook to delete required webhook_token str The token for the webhook required message_id Snowflake_Type The ID of a message sent by this webhook required Returns: Type Description dict A message object on success Source code in dis_snek/http_requests/webhooks.py async def get_webhook_message ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str , message_id : \"Snowflake_Type\" ) -> dict : \"\"\" Returns a previously-sent webhook message from the same token. Returns a message object on success. parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook message_id: The ID of a message sent by this webhook returns: A message object on success \"\"\" return await self . request ( Route ( \"GET\" , f \"/webhooks/ { webhook_id } / { webhook_token } /messages/ { message_id } \" )) async edit_webhook_message ( self , webhook_id , webhook_token , message_id , payload ) \u00b6 Edits a previously-sent webhook message from the same token. Parameters: Name Type Description Default webhook_id Snowflake_Type The ID of the webhook to delete required webhook_token str The token for the webhook required message_id Snowflake_Type The ID of a message sent by this webhook required payload dict The JSON payload for the message required Returns: Type Description dict The updated message on success Source code in dis_snek/http_requests/webhooks.py async def edit_webhook_message ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str , message_id : \"Snowflake_Type\" , payload : dict ) -> dict : \"\"\" Edits a previously-sent webhook message from the same token. parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook message_id: The ID of a message sent by this webhook payload: The JSON payload for the message returns: The updated message on success \"\"\" return await self . request ( Route ( \"PATCH\" , f \"/webhooks/ { webhook_id } / { webhook_token } /messages/ { message_id } \" ), data = payload ) async delete_webhook_message ( self , webhook_id , webhook_token , message_id ) \u00b6 Delete a message that was created by the same token. Parameters: Name Type Description Default webhook_id Snowflake_Type The ID of the webhook to delete required webhook_token str The token for the webhook required message_id Snowflake_Type The ID of a message sent by this webhook required Source code in dis_snek/http_requests/webhooks.py async def delete_webhook_message ( self , webhook_id : \"Snowflake_Type\" , webhook_token : str , message_id : \"Snowflake_Type\" ) -> None : \"\"\" Delete a message that was created by the same token. parameters: webhook_id: The ID of the webhook to delete webhook_token: The token for the webhook message_id: The ID of a message sent by this webhook \"\"\" return await self . request ( Route ( \"DELETE\" , f \"/webhooks/ { webhook_id } / { webhook_token } /messages/ { message_id } \" ))","title":"Suported Endpoints"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.bot","text":"","title":"bot"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.channels","text":"","title":"channels"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.emojis","text":"","title":"emojis"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.guild","text":"","title":"guild"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.interactions","text":"","title":"interactions"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.members","text":"","title":"members"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.messages","text":"","title":"messages"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.reactions","text":"","title":"reactions"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.stickers","text":"","title":"stickers"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.threads","text":"","title":"threads"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.users","text":"","title":"users"},{"location":"API%20Reference/HTTP/Suported%20Endpoints/#dis_snek.http_requests.webhooks","text":"","title":"webhooks"},{"location":"API%20Reference/mixins/send/","text":"SendMixin \u00b6 Source code in dis_snek/mixins/send.py class SendMixin : _client : \"Snake\" async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : raise NotImplementedError async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) async send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/mixins/send.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data )","title":"Send"},{"location":"API%20Reference/mixins/send/#dis_snek.mixins.send.SendMixin","text":"Source code in dis_snek/mixins/send.py class SendMixin : _client : \"Snake\" async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : raise NotImplementedError async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data )","title":"SendMixin"},{"location":"API%20Reference/mixins/serialization/","text":"DictSerializationMixin attrs \u00b6 Source code in dis_snek/mixins/serialization.py @attr . s () class DictSerializationMixin : @classmethod def _get_keys ( cls ) -> frozenset : if ( keys := getattr ( cls , \"_keys\" , None )) is None : keys = frozenset ( field . name for field in attr . fields ( cls )) setattr ( cls , \"_keys\" , keys ) return keys @classmethod def _get_init_keys ( cls ) -> frozenset : if ( init_keys := getattr ( cls , \"_init_keys\" , None )) is None : init_keys = frozenset ( field . name . removeprefix ( \"_\" ) for field in attr . fields ( cls ) if field . init ) setattr ( cls , \"_init_keys\" , init_keys ) return init_keys @classmethod def _filter_kwargs ( cls , kwargs_dict : dict , keys : frozenset ) -> dict : unused = { k : v for k , v in kwargs_dict . items () if k not in keys } if unused and kwarg_spam : print ( \"Unused kwargs:\" , cls . __name__ , unused ) # for debug return { k : v for k , v in kwargs_dict . items () if k in keys } @classmethod def _process_dict ( cls , data : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\" Process dictionary data received from discord api. Does cleanup and other checks to data. parameters: data: The dictionary data received from discord api. returns: The processed dictionary. Ready to be converted into object class. \"\"\" return data @classmethod def from_dict ( cls , data : Dict [ str , Any ]): \"\"\" Process and converts dictionary data received from discord api to object class instance. parameters: data: The json data received from discord api. \"\"\" data = cls . _process_dict ( data ) return cls ( ** cls . _filter_kwargs ( data , cls . _get_init_keys ())) @classmethod def from_list ( cls , datas : List [ Dict [ str , Any ]]): \"\"\" Process and converts list data received from discord api to object class instances. parameters: data: The json data received from discord api. \"\"\" return [ cls . from_dict ( data ) for data in datas ] def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self def _check_object ( self ): \"\"\" Logic to check object properties just before export to json data for sending to discord api. \"\"\" pass def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) classmethod from_dict ( data ) \u00b6 Process and converts dictionary data received from discord api to object class instance. Parameters: Name Type Description Default data Dict[str, Any] The json data received from discord api. required Source code in dis_snek/mixins/serialization.py @classmethod def from_dict ( cls , data : Dict [ str , Any ]): \"\"\" Process and converts dictionary data received from discord api to object class instance. parameters: data: The json data received from discord api. \"\"\" data = cls . _process_dict ( data ) return cls ( ** cls . _filter_kwargs ( data , cls . _get_init_keys ())) classmethod from_list ( datas ) \u00b6 Process and converts list data received from discord api to object class instances. Parameters: Name Type Description Default data The json data received from discord api. required Source code in dis_snek/mixins/serialization.py @classmethod def from_list ( cls , datas : List [ Dict [ str , Any ]]): \"\"\" Process and converts list data received from discord api to object class instances. parameters: data: The json data received from discord api. \"\"\" return [ cls . from_dict ( data ) for data in datas ] update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/mixins/serialization.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/mixins/serialization.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self )","title":"Serialization"},{"location":"API%20Reference/mixins/serialization/#dis_snek.mixins.serialization.DictSerializationMixin","text":"Source code in dis_snek/mixins/serialization.py @attr . s () class DictSerializationMixin : @classmethod def _get_keys ( cls ) -> frozenset : if ( keys := getattr ( cls , \"_keys\" , None )) is None : keys = frozenset ( field . name for field in attr . fields ( cls )) setattr ( cls , \"_keys\" , keys ) return keys @classmethod def _get_init_keys ( cls ) -> frozenset : if ( init_keys := getattr ( cls , \"_init_keys\" , None )) is None : init_keys = frozenset ( field . name . removeprefix ( \"_\" ) for field in attr . fields ( cls ) if field . init ) setattr ( cls , \"_init_keys\" , init_keys ) return init_keys @classmethod def _filter_kwargs ( cls , kwargs_dict : dict , keys : frozenset ) -> dict : unused = { k : v for k , v in kwargs_dict . items () if k not in keys } if unused and kwarg_spam : print ( \"Unused kwargs:\" , cls . __name__ , unused ) # for debug return { k : v for k , v in kwargs_dict . items () if k in keys } @classmethod def _process_dict ( cls , data : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\" Process dictionary data received from discord api. Does cleanup and other checks to data. parameters: data: The dictionary data received from discord api. returns: The processed dictionary. Ready to be converted into object class. \"\"\" return data @classmethod def from_dict ( cls , data : Dict [ str , Any ]): \"\"\" Process and converts dictionary data received from discord api to object class instance. parameters: data: The json data received from discord api. \"\"\" data = cls . _process_dict ( data ) return cls ( ** cls . _filter_kwargs ( data , cls . _get_init_keys ())) @classmethod def from_list ( cls , datas : List [ Dict [ str , Any ]]): \"\"\" Process and converts list data received from discord api to object class instances. parameters: data: The json data received from discord api. \"\"\" return [ cls . from_dict ( data ) for data in datas ] def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self def _check_object ( self ): \"\"\" Logic to check object properties just before export to json data for sending to discord api. \"\"\" pass def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self )","title":"DictSerializationMixin"},{"location":"API%20Reference/models/Discord%20Models/","text":"This is a reference for all models Snek uses to represent Discord Objects. Application ( DiscordObject ) attrs \u00b6 Represents a discord application. Attributes: Name Type Description name str The name of the application. icon str The icon of the application description str The description of the application rpc_origins List[str] an array of rpc origin urls, if rpc is enabled bot_public bool when false only app owner can join the app's bot to guilds bot_require_code_grant bool when true the app's bot will only join upon completion of the full oauth2 code grant flow terms_of_service_url str the url of the app's terms of service privacy_policy_url str the url of the app's privacy policy owner User partial user object containing info on the owner of the application summary str if this application is a game sold on Discord, this field will be the summary field for the store page of its primary sku verify_key str the hex encoded key for verification in interactions and the GameSDK's GetTicket team Team if the application belongs to a team, this will be a list of the members of that team guild_id Snowflake_Type if this application is a game sold on Discord, this field will be the guild to which it has been linked primary_sku_id Snowflake_Type if this application is a game sold on Discord, this field will be the id of the \"Game SKU\" that is created, if exists slug str if this application is a game sold on Discord, this field will be the URL slug that links to the store page cover_image str the application's default rich presence invite cover image hash flags int the application's public flags Source code in dis_snek/models/discord_objects/application.py @attr . s ( slots = True , kw_only = True ) class Application ( DiscordObject ): \"\"\" Represents a discord application. Attributes: name str: The name of the application. icon str: The icon of the application description str: The description of the application rpc_origins List[str]: an array of rpc origin urls, if rpc is enabled bot_public bool: when false only app owner can join the app's bot to guilds bot_require_code_grant bool: when true the app's bot will only join upon completion of the full oauth2 code grant flow terms_of_service_url str: the url of the app's terms of service privacy_policy_url str: the url of the app's privacy policy owner User : partial user object containing info on the owner of the application summary str: if this application is a game sold on Discord, this field will be the summary field for the store page of its primary sku verify_key str: the hex encoded key for verification in interactions and the GameSDK's GetTicket team Team: if the application belongs to a team, this will be a list of the members of that team guild_id Snowflake_Type: if this application is a game sold on Discord, this field will be the guild to which it has been linked primary_sku_id Snowflake_Type: if this application is a game sold on Discord, this field will be the id of the \"Game SKU\" that is created, if exists slug str: if this application is a game sold on Discord, this field will be the URL slug that links to the store page cover_image str: the application's default rich presence invite cover image hash flags int: the application's public flags \"\"\" name : str = attr . ib () icon : Optional [ Asset ] = attr . ib ( default = None ) description : Optional [ str ] = attr . ib () rpc_origins : Optional [ List [ str ]] = attr . ib ( default = None ) bot_public : bool = attr . ib ( default = True ) bot_require_code_grant : bool = attr . ib ( default = False ) terms_of_service_url : Optional [ str ] = attr . ib ( default = None ) privacy_policy_url : Optional [ str ] = attr . ib ( default = None ) owner_id : Optional [ Snowflake_Type ] = attr . ib ( default = None , converter = optional ( to_snowflake )) summary : str = attr . ib () verify_key : Optional [ str ] = attr . ib ( default = MISSING ) team : Optional [ \"Team\" ] = attr . ib ( default = None ) guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) primary_sku_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) slug : Optional [ str ] = attr . ib ( default = None ) cover_image : Optional [ str ] = attr . ib ( default = None ) flags : Optional [ \"ApplicationFlags\" ] = attr . ib ( default = None , converter = optional ( ApplicationFlags )) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: if data . get ( \"team\" ): data [ \"team\" ] = Team . from_dict ( data [ \"team\" ], client ) data [ \"owner_id\" ] = data [ \"team\" ] . owner_user_id else : if \"owner\" in data : owner = client . cache . place_user_data ( data . pop ( \"owner\" )) data [ \"owner_id\" ] = owner . id if data [ \"icon\" ]: data [ \"icon\" ] = Asset . from_path_hash ( client , f \"app-icons/ { data [ 'id' ] } / {{}} .png\" , data [ \"icon\" ]) return data @property def owner ( self ): return self . _client . cache . user_cache . get ( self . owner_id ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/application.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/application.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) Asset attrs \u00b6 Represents a discord asset. Attributes: Name Type Description BASE str The cdn address for assets url str The URL of this asset hash Optional[str] The hash of this asset Source code in dis_snek/models/discord_objects/asset.py @attr . s ( slots = True ) class Asset : \"\"\" Represents a discord asset. Attributes: BASE str: The `cdn` address for assets url str: The URL of this asset hash Optional[str]: The hash of this asset \"\"\" BASE = \"https://cdn.discordapp.com\" _client : \"Snake\" = attr . field () url : str = attr . field () hash : Optional [ str ] = attr . field ( default = None ) @classmethod def from_path_hash ( cls , client : \"Snake\" , path : str , asset_hash : str ) -> \"Asset\" : url = f \" { cls . BASE } / { path . format ( asset_hash ) } \" return cls ( client = client , url = url , hash = asset_hash ) @property def animated ( self ) -> bool : \"\"\"True if this asset is animated\"\"\" if not self . hash : return None return self . hash . startswith ( \"a_\" ) async def get ( self , extension : Optional [ str ] = None , size : Optional [ int ] = None ) -> bytes : \"\"\" Get the asset from the Discord CDN Args: extension: File extension size: File size Returns: Raw byte array of the file Raises: ValueError: Incorrect file size if not power of 2 between 16 and 4096 \"\"\" if not extension : extension = \".gif\" if self . animated else \".png\" url = self . url if size : if not (( size != 0 ) and ( size & ( size - 1 ) == 0 )): # if not power of 2 raise ValueError ( \"Size should be a power of 2\" ) if not 16 <= size <= 4096 : raise ValueError ( \"Size should be between 16 and 4096\" ) url = f \" { url } ?size= { size } \" url = url + extension return await self . _client . http . request_cdn ( url , self ) async def save ( self , fd : Union [ str , bytes , \"PathLike\" , int ], extension : Optional [ str ] = None , size : Optional [ int ] = None ) -> int : \"\"\" Save the asset to a file Args: fd: File destination extention: File extension size: File size Return: Status code \"\"\" content = await self . get ( extension = extension , size = size ) with open ( fd , \"wb\" ) as f : return f . write ( content ) property readonly animated : bool \u00b6 True if this asset is animated async get ( self , extension = None , size = None ) \u00b6 Get the asset from the Discord CDN Parameters: Name Type Description Default extension Optional[str] File extension None size Optional[int] File size None Returns: Type Description bytes Raw byte array of the file Exceptions: Type Description ValueError Incorrect file size if not power of 2 between 16 and 4096 Source code in dis_snek/models/discord_objects/asset.py async def get ( self , extension : Optional [ str ] = None , size : Optional [ int ] = None ) -> bytes : \"\"\" Get the asset from the Discord CDN Args: extension: File extension size: File size Returns: Raw byte array of the file Raises: ValueError: Incorrect file size if not power of 2 between 16 and 4096 \"\"\" if not extension : extension = \".gif\" if self . animated else \".png\" url = self . url if size : if not (( size != 0 ) and ( size & ( size - 1 ) == 0 )): # if not power of 2 raise ValueError ( \"Size should be a power of 2\" ) if not 16 <= size <= 4096 : raise ValueError ( \"Size should be between 16 and 4096\" ) url = f \" { url } ?size= { size } \" url = url + extension return await self . _client . http . request_cdn ( url , self ) async save ( self , fd , extension = None , size = None ) \u00b6 Save the asset to a file Parameters: Name Type Description Default fd Union[str, bytes, PathLike, int] File destination required extention File extension required size Optional[int] File size None Returns: Type Description int Status code Source code in dis_snek/models/discord_objects/asset.py async def save ( self , fd : Union [ str , bytes , \"PathLike\" , int ], extension : Optional [ str ] = None , size : Optional [ int ] = None ) -> int : \"\"\" Save the asset to a file Args: fd: File destination extention: File extension size: File size Return: Status code \"\"\" content = await self . get ( extension = extension , size = size ) with open ( fd , \"wb\" ) as f : return f . write ( content ) ChannelHistory ( AsyncIterator ) \u00b6 An async iterator for searching through a channel's history Parameters: Name Type Description Default channel BaseChannel The channel to search through required limit The maximum number of messages to return (set to 0 for no limit) 50 before get messages before this message ID None after get messages after this message ID None around get messages \"around\" this message ID None Source code in dis_snek/models/discord_objects/channel.py class ChannelHistory ( AsyncIterator ): \"\"\" An async iterator for searching through a channel's history Args: channel: The channel to search through limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID \"\"\" def __init__ ( self , channel : \"BaseChannel\" , limit = 50 , before = None , after = None , around = None ): self . channel : \"BaseChannel\" = channel self . before : \"Snowflake_Type\" = before self . after : \"Snowflake_Type\" = after self . around : \"Snowflake_Type\" = around super () . __init__ ( limit ) async def fetch ( self ): if self . after : if not self . last : self . last = namedtuple ( \"temp\" , \"id\" ) self . last . id = self . after messages = await self . channel . get_messages ( limit = self . get_limit , after = self . last . id ) messages . sort ( key = lambda x : x . id ) elif self . around : messages = await self . channel . get_messages ( limit = self . get_limit , around = self . around ) # todo: decide how getting *more* messages from `around` would work self . _limit = 1 # stops history from getting more messages else : if self . before and not self . last : self . last = namedtuple ( \"temp\" , \"id\" ) self . last . id = self . before messages = await self . channel . get_messages ( limit = self . get_limit , before = self . last . id ) messages . sort ( key = lambda x : x . id , reverse = True ) return messages inherited property readonly get_limit \u00b6 Get how the maximum number of items that should be retrieved async inherited add_object ( self , obj ) \u00b6 Add an object to iterator's queue Source code in dis_snek/models/discord_objects/channel.py async def add_object ( self , obj ): \"\"\"Add an object to iterator's queue\"\"\" return await self . _queue . put ( obj ) async fetch ( self ) \u00b6 Fetch additional objects. Your implementation of this method must return a list of objects. If no more objects are available, raise QueueEmpty Returns: Type Description List of objects Source code in dis_snek/models/discord_objects/channel.py async def fetch ( self ): if self . after : if not self . last : self . last = namedtuple ( \"temp\" , \"id\" ) self . last . id = self . after messages = await self . channel . get_messages ( limit = self . get_limit , after = self . last . id ) messages . sort ( key = lambda x : x . id ) elif self . around : messages = await self . channel . get_messages ( limit = self . get_limit , around = self . around ) # todo: decide how getting *more* messages from `around` would work self . _limit = 1 # stops history from getting more messages else : if self . before and not self . last : self . last = namedtuple ( \"temp\" , \"id\" ) self . last . id = self . before messages = await self . channel . get_messages ( limit = self . get_limit , before = self . last . id ) messages . sort ( key = lambda x : x . id , reverse = True ) return messages async inherited flatten ( self ) \u00b6 Flatten this iterator into a list of objects Source code in dis_snek/models/discord_objects/channel.py async def flatten ( self ) -> List : \"\"\"Flatten this iterator into a list of objects\"\"\" return [ elem async for elem in self ] async inherited search ( self , target_id ) \u00b6 Search the iterator for an object with the given ID Source code in dis_snek/models/discord_objects/channel.py async def search ( self , target_id : \"Snowflake_Type\" ) -> bool : \"\"\"Search the iterator for an object with the given ID\"\"\" target_id = to_snowflake ( target_id ) if target_id in [ o . id for o in self . _retrieved_objects ]: return True async for o in self : if o . id == target_id : return True return False PermissionOverwrite ( SnowflakeObject ) attrs \u00b6 Channel Permissions Overwrite object Attributes: Name Type Description type OverwriteTypes Permission overwrite type (role or member) allow Permissions Permissions to allow deny Permissions Permissions to deny Source code in dis_snek/models/discord_objects/channel.py @define () class PermissionOverwrite ( SnowflakeObject ): \"\"\" Channel Permissions Overwrite object Attributes: type: Permission overwrite type (role or member) allow: Permissions to allow deny: Permissions to deny \"\"\" type : \"OverwriteTypes\" = field ( repr = True , converter = OverwriteTypes ) allow : \"Permissions\" = field ( repr = True , converter = Permissions ) deny : \"Permissions\" = field ( repr = True , converter = Permissions ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: MessageableMixin ( SendMixin ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class MessageableMixin ( SendMixin ): last_message_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) # TODO May need to think of dynamically updating this. default_auto_archive_duration : int = attr . ib ( default = AutoArchiveDuration . ONE_DAY ) last_pin_timestamp : Optional [ Timestamp ] = attr . ib ( default = None , converter = optional_c ( timestamp_converter )) async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : return await self . _client . http . create_message ( message_payload , self . id ) async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count async def trigger_typing ( self ) -> None : await self . _client . http . trigger_typing_indicator ( self . id ) async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) async get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count InvitableMixin attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class InvitableMixin : async def create_invite ( self , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : Optional [ \"InviteTargetTypes\" ] = None , target_user : Optional [ Union [ \"Snowflake_Type\" , \"User\" ]] = None , target_application : Optional [ Union [ \"Snowflake_Type\" , \"Application\" ]] = None , reason : Optional [ str ] = None , ) -> \"Invite\" : \"\"\" Create channel invite. Args: max_age: Max age of invite in seconds, default 86400 (24 hours). max_uses: Max uses of invite, default 0. temporary: Grants temporary membership, default False. unique: Invite is unique, default false. target_type: Target type for streams and embedded applications. target_user_id: Target User ID for Stream target type. target_application_id: Target Application ID for Embedded App target type. reason: The reason for creating this invite. Returns: Newly created Invite object. \"\"\" if target_type : if target_type == InviteTargetTypes . STREAM and not target_user : raise ValueError ( \"Stream target must include target user id.\" ) elif target_type == InviteTargetTypes . EMBEDDED_APPLICATION and not target_application : raise ValueError ( \"Embedded Application target must include target application id.\" ) if target_user and target_application : raise ValueError ( \"Invite target must be either User or Embedded Application, not both.\" ) elif target_user : target_user = to_snowflake ( target_user ) target_type = InviteTargetTypes . STREAM elif target_application : target_application = to_snowflake ( target_application ) target_type = InviteTargetTypes . EMBEDDED_APPLICATION invite_data = await self . _client . http . create_channel_invite ( self . id , max_age , max_uses , temporary , unique , target_type , target_user , target_application , reason ) return Invite . from_dict ( invite_data , self . _client ) async def get_invites ( self ) -> List [ \"Invite\" ]: \"\"\" Gets all invites (with invite metadata) for the channel. \"\"\" invites_data = await self . _client . http . get_channel_invites ( self . id ) return Invite . from_list ( invites_data , self . _client ) async create_invite ( self , max_age = 86400 , max_uses = 0 , temporary = False , unique = False , target_type = None , target_user = None , target_application = None , reason = None ) \u00b6 Create channel invite. Parameters: Name Type Description Default max_age int Max age of invite in seconds, default 86400 (24 hours). 86400 max_uses int Max uses of invite, default 0. 0 temporary bool Grants temporary membership, default False. False unique bool Invite is unique, default false. False target_type Optional[InviteTargetTypes] Target type for streams and embedded applications. None target_user_id Target User ID for Stream target type. required target_application_id Target Application ID for Embedded App target type. required reason Optional[str] The reason for creating this invite. None Returns: Type Description Invite Newly created Invite object. Source code in dis_snek/models/discord_objects/channel.py async def create_invite ( self , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : Optional [ \"InviteTargetTypes\" ] = None , target_user : Optional [ Union [ \"Snowflake_Type\" , \"User\" ]] = None , target_application : Optional [ Union [ \"Snowflake_Type\" , \"Application\" ]] = None , reason : Optional [ str ] = None , ) -> \"Invite\" : \"\"\" Create channel invite. Args: max_age: Max age of invite in seconds, default 86400 (24 hours). max_uses: Max uses of invite, default 0. temporary: Grants temporary membership, default False. unique: Invite is unique, default false. target_type: Target type for streams and embedded applications. target_user_id: Target User ID for Stream target type. target_application_id: Target Application ID for Embedded App target type. reason: The reason for creating this invite. Returns: Newly created Invite object. \"\"\" if target_type : if target_type == InviteTargetTypes . STREAM and not target_user : raise ValueError ( \"Stream target must include target user id.\" ) elif target_type == InviteTargetTypes . EMBEDDED_APPLICATION and not target_application : raise ValueError ( \"Embedded Application target must include target application id.\" ) if target_user and target_application : raise ValueError ( \"Invite target must be either User or Embedded Application, not both.\" ) elif target_user : target_user = to_snowflake ( target_user ) target_type = InviteTargetTypes . STREAM elif target_application : target_application = to_snowflake ( target_application ) target_type = InviteTargetTypes . EMBEDDED_APPLICATION invite_data = await self . _client . http . create_channel_invite ( self . id , max_age , max_uses , temporary , unique , target_type , target_user , target_application , reason ) return Invite . from_dict ( invite_data , self . _client ) async get_invites ( self ) \u00b6 Gets all invites (with invite metadata) for the channel. Source code in dis_snek/models/discord_objects/channel.py async def get_invites ( self ) -> List [ \"Invite\" ]: \"\"\" Gets all invites (with invite metadata) for the channel. \"\"\" invites_data = await self . _client . http . get_channel_invites ( self . id ) return Invite . from_list ( invites_data , self . _client ) ThreadableMixin attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class ThreadableMixin : async def create_thread_with_message ( self , name : str , message : Union [ \"Snowflake_Type\" , \"Message\" ], auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildNewsThread\" , \"GuildPublicThread\" ]: \"\"\" Create a thread connected to a message Args: name: 1-100 character thread name message: The message to connect this thread to auto_archive_duration: Time before the thread will be automatically archived reason: The reason for creating this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , auto_archive_duration = auto_archive_duration , message_id = to_snowflake ( message ), reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async def create_thread_without_message ( self , name : str , thread_type : Union [ ChannelTypes , int ], invitable : Optional [ bool ] = None , auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildPrivateThread\" , \"GuildPublicThread\" ]: \"\"\" Creates a thread without a message source. Args: name: 1-100 character thread name thread_type: Is the thread private or public invitable: whether non-moderators can add other non-moderators to a thread; only available when creating a private thread auto_archive_duration: Time before the thread will be automatically archived reason: The reason to create this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , thread_type = thread_type , auto_archive_duration = auto_archive_duration , invitable = invitable , reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async def get_public_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **public** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_public_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async def get_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **private** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async def get_joined_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of threads the bot is a participant of in this channel Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_joined_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async def get_active_threads ( self ) -> List [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\"Returns all active threads in the channel, including public and private threads\"\"\" raw_threads = await self . guild . get_active_threads () if hasattr ( raw_threads , \"threads\" ): return [ t for t in raw_threads . threads if t . parent_channel . id == self . id ] return [] async create_thread_with_message ( self , name , message , auto_archive_duration =< AutoArchiveDuration . ONE_DAY : 1440 > , reason = None ) \u00b6 Create a thread connected to a message Parameters: Name Type Description Default name str 1-100 character thread name required message Union[Snowflake_Type, Message] The message to connect this thread to required auto_archive_duration Union[dis_snek.models.enums.AutoArchiveDuration, int] Time before the thread will be automatically archived <AutoArchiveDuration.ONE_DAY: 1440> reason Optional[str] The reason for creating this thread None Returns: Type Description Union[GuildNewsThread, GuildPublicThread] The created thread, if successful Source code in dis_snek/models/discord_objects/channel.py async def create_thread_with_message ( self , name : str , message : Union [ \"Snowflake_Type\" , \"Message\" ], auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildNewsThread\" , \"GuildPublicThread\" ]: \"\"\" Create a thread connected to a message Args: name: 1-100 character thread name message: The message to connect this thread to auto_archive_duration: Time before the thread will be automatically archived reason: The reason for creating this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , auto_archive_duration = auto_archive_duration , message_id = to_snowflake ( message ), reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async create_thread_without_message ( self , name , thread_type , invitable = None , auto_archive_duration =< AutoArchiveDuration . ONE_DAY : 1440 > , reason = None ) \u00b6 Creates a thread without a message source. Parameters: Name Type Description Default name str 1-100 character thread name required thread_type Union[dis_snek.models.enums.ChannelTypes, int] Is the thread private or public required invitable Optional[bool] whether non-moderators can add other non-moderators to a thread; only available when creating a private thread None auto_archive_duration Union[dis_snek.models.enums.AutoArchiveDuration, int] Time before the thread will be automatically archived <AutoArchiveDuration.ONE_DAY: 1440> reason Optional[str] The reason to create this thread None Returns: Type Description Union[GuildPrivateThread, GuildPublicThread] The created thread, if successful Source code in dis_snek/models/discord_objects/channel.py async def create_thread_without_message ( self , name : str , thread_type : Union [ ChannelTypes , int ], invitable : Optional [ bool ] = None , auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildPrivateThread\" , \"GuildPublicThread\" ]: \"\"\" Creates a thread without a message source. Args: name: 1-100 character thread name thread_type: Is the thread private or public invitable: whether non-moderators can add other non-moderators to a thread; only available when creating a private thread auto_archive_duration: Time before the thread will be automatically archived reason: The reason to create this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , thread_type = thread_type , auto_archive_duration = auto_archive_duration , invitable = invitable , reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async get_public_archived_threads ( self , limit = None , before = None ) \u00b6 Get a ThreadList of public threads available in this channel. Parameters: Name Type Description Default limit int optional maximum number of threads to return None before Timestamp Returns threads before this timestamp None Source code in dis_snek/models/discord_objects/channel.py async def get_public_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **public** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_public_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async get_private_archived_threads ( self , limit = None , before = None ) \u00b6 Get a ThreadList of private threads available in this channel. Parameters: Name Type Description Default limit int optional maximum number of threads to return None before Timestamp Returns threads before this timestamp None Source code in dis_snek/models/discord_objects/channel.py async def get_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **private** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async get_joined_private_archived_threads ( self , limit = None , before = None ) \u00b6 Get a ThreadList of threads the bot is a participant of in this channel Parameters: Name Type Description Default limit int optional maximum number of threads to return None before Timestamp Returns threads before this timestamp None Source code in dis_snek/models/discord_objects/channel.py async def get_joined_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of threads the bot is a participant of in this channel Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_joined_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async get_active_threads ( self ) \u00b6 Returns all active threads in the channel, including public and private threads Source code in dis_snek/models/discord_objects/channel.py async def get_active_threads ( self ) -> List [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\"Returns all active threads in the channel, including public and private threads\"\"\" raw_threads = await self . guild . get_active_threads () if hasattr ( raw_threads , \"threads\" ): return [ t for t in raw_threads . threads if t . parent_channel . id == self . id ] return [] WebhookMixin attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class WebhookMixin : async def create_webhook ( self , name : str , avatar : Optional [ bytes ] = MISSING ) -> Webhook : \"\"\" Create a webhook in this channel Args: name: The name of the webhook avatar: An optional default avatar to use Returns: The created webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" return await Webhook . create ( self . _client , self , name , avatar ) # type: ignore async def delete_webhook ( self , webhook : Webhook ) -> None : \"\"\" Delete a given webhook in this channel Args: webhook: The webhook to delete \"\"\" return await webhook . delete () async create_webhook ( self , name , avatar = MISSING ) \u00b6 Create a webhook in this channel Parameters: Name Type Description Default name str The name of the webhook required avatar Optional[bytes] An optional default avatar to use MISSING Returns: Type Description Webhook The created webhook Exceptions: Type Description ValueError If you try to name the webhook \"Clyde\" Source code in dis_snek/models/discord_objects/channel.py async def create_webhook ( self , name : str , avatar : Optional [ bytes ] = MISSING ) -> Webhook : \"\"\" Create a webhook in this channel Args: name: The name of the webhook avatar: An optional default avatar to use Returns: The created webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" return await Webhook . create ( self . _client , self , name , avatar ) # type: ignore async delete_webhook ( self , webhook ) \u00b6 Delete a given webhook in this channel Parameters: Name Type Description Default webhook Webhook The webhook to delete required Source code in dis_snek/models/discord_objects/channel.py async def delete_webhook ( self , webhook : Webhook ) -> None : \"\"\" Delete a given webhook in this channel Args: webhook: The webhook to delete \"\"\" return await webhook . delete () BaseChannel ( DiscordObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class BaseChannel ( DiscordObject ): name : Optional [ str ] = field ( default = None ) type : Union [ ChannelTypes , int ] = field ( converter = ChannelTypes ) @classmethod def from_dict_factory ( cls , data : dict , client : \"Snake\" ) -> \"TYPE_ALL_CHANNEL\" : \"\"\" Creates a channel object of the appropriate type Args: data: The channel data. client: The bot. Returns: The new channel object. \"\"\" channel_type = data . get ( \"type\" , None ) channel_class = TYPE_CHANNEL_MAPPING . get ( channel_type , None ) if not channel_class : raise TypeError ( f \"Unsupported channel type for { data } ( { channel_type } ), please consult the docs.\" ) return channel_class . from_dict ( data , client ) @property def mention ( self ) -> str : \"\"\"Returns a string that would mention the channel\"\"\" return f \"<# { self . id } >\" async def _edit ( self , payload : dict , reason : Optional [ str ] = MISSING ) -> None : \"\"\" # TODO Args: payload: reason: Returns: \"\"\" channel_data = self . _client . http . modify_channel ( self . id , payload , reason ) self . update_from_dict ( channel_data ) async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) classmethod from_dict_factory ( data , client ) \u00b6 Creates a channel object of the appropriate type Parameters: Name Type Description Default data dict The channel data. required client Snake The bot. required Returns: Type Description TYPE_ALL_CHANNEL The new channel object. Source code in dis_snek/models/discord_objects/channel.py @classmethod def from_dict_factory ( cls , data : dict , client : \"Snake\" ) -> \"TYPE_ALL_CHANNEL\" : \"\"\" Creates a channel object of the appropriate type Args: data: The channel data. client: The bot. Returns: The new channel object. \"\"\" channel_type = data . get ( \"type\" , None ) channel_class = TYPE_CHANNEL_MAPPING . get ( channel_type , None ) if not channel_class : raise TypeError ( f \"Unsupported channel type for { data } ( { channel_type } ), please consult the docs.\" ) return channel_class . from_dict ( data , client ) property readonly mention : str \u00b6 Returns a string that would mention the channel async delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) DMChannel ( BaseChannel , MessageableMixin ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class DMChannel ( BaseChannel , MessageableMixin ): @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data = super () . _process_dict ( data , client ) data [ \"recipients\" ] = [ client . cache . place_user_data ( recipient ) for recipient in data [ \"recipients\" ]] return data async def edit ( self , name : Optional [ str ] = MISSING , icon : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , reason : Optional [ str ] = MISSING , ): payload = dict ( name = name , icon = to_image_data ( icon )) await self . _edit ( payload = payload , reason = reason ) async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message inherited history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async inherited get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async inherited delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async inherited purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) DM ( DMChannel ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class DM ( DMChannel ): recipient : \"User\" = field () @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data = super () . _process_dict ( data , client ) data [ \"recipient\" ] = data . pop ( \"recipients\" )[ 0 ] client . cache . place_dm_channel_id ( data [ \"recipient\" ], data [ \"id\" ]) return data async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message inherited history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async inherited get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async inherited delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async inherited purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) DMGroup ( DMChannel ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class DMGroup ( DMChannel ): owner_id : \"Snowflake_Type\" = attr . ib () application_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) recipients : List [ \"User\" ] = field ( factory = list ) async def get_owner ( self ) -> \"User\" : return await self . _client . cache . get_user ( self . owner_id ) async def add_recipient ( self , user : Union [ \"User\" , \"Snowflake_Type\" ], access_token : str , nickname : Optional [ str ] = MISSING ): user = await self . _client . cache . get_user ( user ) await self . _client . http . group_dm_add_recipient ( self . id , user . id , access_token , nickname ) self . recipients . append ( user ) async def remove_recipient ( self , user : Union [ \"User\" , \"Snowflake_Type\" ]): user = await self . _client . cache . get_user ( user ) await self . _client . http . group_dm_remove_recipient ( self . id , user . id ) self . recipients . remove ( user ) async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message inherited history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async inherited get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async inherited delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async inherited purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) GuildChannel ( BaseChannel ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildChannel ( BaseChannel ): position : Optional [ int ] = attr . ib ( default = 0 ) nsfw : bool = attr . ib ( default = False ) parent_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) _guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) _permission_overwrites : Dict [ \"Snowflake_Type\" , \"PermissionOverwrite\" ] = attr . ib ( factory = list ) @property def guild ( self ): return self . _client . cache . guild_cache . get ( self . _guild_id ) @property def category ( self ): return self . _client . cache . channel_cache . get ( self . parent_id ) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: permission_overwrites = data . get ( \"permission_overwrites\" , []) data [ \"permission_overwrites\" ] = { obj . id : obj for obj in ( PermissionOverwrite ( ** permission ) for permission in permission_overwrites ) } return data async def edit_permission ( self , overwrite : PermissionOverwrite , reason : Optional [ str ] = None ) -> None : await self . _client . http . edit_channel_permission ( self . id , overwrite . id , overwrite . allow , overwrite . deny , overwrite . type , reason # TODO Convert to str...? ) async def delete_permission ( self , target : Union [ \"PermissionOverwrite\" , \"Role\" , \"User\" ], reason : Optional [ str ] = MISSING ): target = to_snowflake ( target ) await self . _client . http . delete_channel_permission ( self . id , target , reason ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) GuildCategory ( GuildChannel ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildCategory ( GuildChannel ): async def edit ( self , name , position , permission_overwrites , reason ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , ) await self . _edit ( payload = payload , reason = reason ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) GuildStore ( GuildChannel ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildStore ( GuildChannel ): async def edit ( self , name , position , permission_overwrites , parent_id , nsfw , reason ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , parent_id = parent_id , nsfw = nsfw , ) await self . _edit ( payload = payload , reason = reason ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) GuildNews ( GuildChannel , MessageableMixin , InvitableMixin , ThreadableMixin , WebhookMixin ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildNews ( GuildChannel , MessageableMixin , InvitableMixin , ThreadableMixin , WebhookMixin ): topic : Optional [ str ] = attr . ib ( default = None ) async def edit ( self , name , position , permission_overwrites , parent_id , nsfw , topic , channel_type , default_auto_archive_duration , reason , ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , parent_id = parent_id , nsfw = nsfw , topic = topic , channel_type = channel_type , default_auto_archive_duration = default_auto_archive_duration , ) await self . _edit ( payload = payload , reason = reason ) async def follow ( self , webhook_channel_id : \"Snowflake_Type\" ): await self . _client . http . follow_news_channel ( self . id , webhook_channel_id ) async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message inherited history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async inherited get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async inherited delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async inherited purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count async inherited create_invite ( self , max_age = 86400 , max_uses = 0 , temporary = False , unique = False , target_type = None , target_user = None , target_application = None , reason = None ) \u00b6 Create channel invite. Parameters: Name Type Description Default max_age int Max age of invite in seconds, default 86400 (24 hours). 86400 max_uses int Max uses of invite, default 0. 0 temporary bool Grants temporary membership, default False. False unique bool Invite is unique, default false. False target_type Optional[InviteTargetTypes] Target type for streams and embedded applications. None target_user_id Target User ID for Stream target type. required target_application_id Target Application ID for Embedded App target type. required reason Optional[str] The reason for creating this invite. None Returns: Type Description Invite Newly created Invite object. Source code in dis_snek/models/discord_objects/channel.py async def create_invite ( self , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : Optional [ \"InviteTargetTypes\" ] = None , target_user : Optional [ Union [ \"Snowflake_Type\" , \"User\" ]] = None , target_application : Optional [ Union [ \"Snowflake_Type\" , \"Application\" ]] = None , reason : Optional [ str ] = None , ) -> \"Invite\" : \"\"\" Create channel invite. Args: max_age: Max age of invite in seconds, default 86400 (24 hours). max_uses: Max uses of invite, default 0. temporary: Grants temporary membership, default False. unique: Invite is unique, default false. target_type: Target type for streams and embedded applications. target_user_id: Target User ID for Stream target type. target_application_id: Target Application ID for Embedded App target type. reason: The reason for creating this invite. Returns: Newly created Invite object. \"\"\" if target_type : if target_type == InviteTargetTypes . STREAM and not target_user : raise ValueError ( \"Stream target must include target user id.\" ) elif target_type == InviteTargetTypes . EMBEDDED_APPLICATION and not target_application : raise ValueError ( \"Embedded Application target must include target application id.\" ) if target_user and target_application : raise ValueError ( \"Invite target must be either User or Embedded Application, not both.\" ) elif target_user : target_user = to_snowflake ( target_user ) target_type = InviteTargetTypes . STREAM elif target_application : target_application = to_snowflake ( target_application ) target_type = InviteTargetTypes . EMBEDDED_APPLICATION invite_data = await self . _client . http . create_channel_invite ( self . id , max_age , max_uses , temporary , unique , target_type , target_user , target_application , reason ) return Invite . from_dict ( invite_data , self . _client ) async inherited get_invites ( self ) \u00b6 Gets all invites (with invite metadata) for the channel. Source code in dis_snek/models/discord_objects/channel.py async def get_invites ( self ) -> List [ \"Invite\" ]: \"\"\" Gets all invites (with invite metadata) for the channel. \"\"\" invites_data = await self . _client . http . get_channel_invites ( self . id ) return Invite . from_list ( invites_data , self . _client ) async inherited create_thread_with_message ( self , name , message , auto_archive_duration =< AutoArchiveDuration . ONE_DAY : 1440 > , reason = None ) \u00b6 Create a thread connected to a message Parameters: Name Type Description Default name str 1-100 character thread name required message Union[Snowflake_Type, Message] The message to connect this thread to required auto_archive_duration Union[dis_snek.models.enums.AutoArchiveDuration, int] Time before the thread will be automatically archived <AutoArchiveDuration.ONE_DAY: 1440> reason Optional[str] The reason for creating this thread None Returns: Type Description Union[GuildNewsThread, GuildPublicThread] The created thread, if successful Source code in dis_snek/models/discord_objects/channel.py async def create_thread_with_message ( self , name : str , message : Union [ \"Snowflake_Type\" , \"Message\" ], auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildNewsThread\" , \"GuildPublicThread\" ]: \"\"\" Create a thread connected to a message Args: name: 1-100 character thread name message: The message to connect this thread to auto_archive_duration: Time before the thread will be automatically archived reason: The reason for creating this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , auto_archive_duration = auto_archive_duration , message_id = to_snowflake ( message ), reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async inherited create_thread_without_message ( self , name , thread_type , invitable = None , auto_archive_duration =< AutoArchiveDuration . ONE_DAY : 1440 > , reason = None ) \u00b6 Creates a thread without a message source. Parameters: Name Type Description Default name str 1-100 character thread name required thread_type Union[dis_snek.models.enums.ChannelTypes, int] Is the thread private or public required invitable Optional[bool] whether non-moderators can add other non-moderators to a thread; only available when creating a private thread None auto_archive_duration Union[dis_snek.models.enums.AutoArchiveDuration, int] Time before the thread will be automatically archived <AutoArchiveDuration.ONE_DAY: 1440> reason Optional[str] The reason to create this thread None Returns: Type Description Union[GuildPrivateThread, GuildPublicThread] The created thread, if successful Source code in dis_snek/models/discord_objects/channel.py async def create_thread_without_message ( self , name : str , thread_type : Union [ ChannelTypes , int ], invitable : Optional [ bool ] = None , auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildPrivateThread\" , \"GuildPublicThread\" ]: \"\"\" Creates a thread without a message source. Args: name: 1-100 character thread name thread_type: Is the thread private or public invitable: whether non-moderators can add other non-moderators to a thread; only available when creating a private thread auto_archive_duration: Time before the thread will be automatically archived reason: The reason to create this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , thread_type = thread_type , auto_archive_duration = auto_archive_duration , invitable = invitable , reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async inherited get_public_archived_threads ( self , limit = None , before = None ) \u00b6 Get a ThreadList of public threads available in this channel. Parameters: Name Type Description Default limit int optional maximum number of threads to return None before Timestamp Returns threads before this timestamp None Source code in dis_snek/models/discord_objects/channel.py async def get_public_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **public** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_public_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async inherited get_private_archived_threads ( self , limit = None , before = None ) \u00b6 Get a ThreadList of private threads available in this channel. Parameters: Name Type Description Default limit int optional maximum number of threads to return None before Timestamp Returns threads before this timestamp None Source code in dis_snek/models/discord_objects/channel.py async def get_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **private** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async inherited get_joined_private_archived_threads ( self , limit = None , before = None ) \u00b6 Get a ThreadList of threads the bot is a participant of in this channel Parameters: Name Type Description Default limit int optional maximum number of threads to return None before Timestamp Returns threads before this timestamp None Source code in dis_snek/models/discord_objects/channel.py async def get_joined_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of threads the bot is a participant of in this channel Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_joined_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async inherited get_active_threads ( self ) \u00b6 Returns all active threads in the channel, including public and private threads Source code in dis_snek/models/discord_objects/channel.py async def get_active_threads ( self ) -> List [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\"Returns all active threads in the channel, including public and private threads\"\"\" raw_threads = await self . guild . get_active_threads () if hasattr ( raw_threads , \"threads\" ): return [ t for t in raw_threads . threads if t . parent_channel . id == self . id ] return [] async inherited create_webhook ( self , name , avatar = MISSING ) \u00b6 Create a webhook in this channel Parameters: Name Type Description Default name str The name of the webhook required avatar Optional[bytes] An optional default avatar to use MISSING Returns: Type Description Webhook The created webhook Exceptions: Type Description ValueError If you try to name the webhook \"Clyde\" Source code in dis_snek/models/discord_objects/channel.py async def create_webhook ( self , name : str , avatar : Optional [ bytes ] = MISSING ) -> Webhook : \"\"\" Create a webhook in this channel Args: name: The name of the webhook avatar: An optional default avatar to use Returns: The created webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" return await Webhook . create ( self . _client , self , name , avatar ) # type: ignore async inherited delete_webhook ( self , webhook ) \u00b6 Delete a given webhook in this channel Parameters: Name Type Description Default webhook Webhook The webhook to delete required Source code in dis_snek/models/discord_objects/channel.py async def delete_webhook ( self , webhook : Webhook ) -> None : \"\"\" Delete a given webhook in this channel Args: webhook: The webhook to delete \"\"\" return await webhook . delete () inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) GuildText ( GuildChannel , MessageableMixin , InvitableMixin , ThreadableMixin , WebhookMixin ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildText ( GuildChannel , MessageableMixin , InvitableMixin , ThreadableMixin , WebhookMixin ): topic : Optional [ str ] = attr . ib ( default = None ) rate_limit_per_user : int = attr . ib ( default = 0 ) async def edit ( self , name , position , permission_overwrites , parent_id , nsfw , topic , channel_type , default_auto_archive_duration , rate_limit_per_user , reason , ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , parent_id = parent_id , nsfw = nsfw , topic = topic , channel_type = channel_type , rate_limit_per_user = rate_limit_per_user , default_auto_archive_duration = default_auto_archive_duration , ) await self . _edit ( payload = payload , reason = reason ) async def follow ( self , webhook_channel_id : \"Snowflake_Type\" ): await self . _client . http . follow_news_channel ( self . id , webhook_channel_id ) async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message inherited history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async inherited get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async inherited delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async inherited purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count async inherited create_invite ( self , max_age = 86400 , max_uses = 0 , temporary = False , unique = False , target_type = None , target_user = None , target_application = None , reason = None ) \u00b6 Create channel invite. Parameters: Name Type Description Default max_age int Max age of invite in seconds, default 86400 (24 hours). 86400 max_uses int Max uses of invite, default 0. 0 temporary bool Grants temporary membership, default False. False unique bool Invite is unique, default false. False target_type Optional[InviteTargetTypes] Target type for streams and embedded applications. None target_user_id Target User ID for Stream target type. required target_application_id Target Application ID for Embedded App target type. required reason Optional[str] The reason for creating this invite. None Returns: Type Description Invite Newly created Invite object. Source code in dis_snek/models/discord_objects/channel.py async def create_invite ( self , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : Optional [ \"InviteTargetTypes\" ] = None , target_user : Optional [ Union [ \"Snowflake_Type\" , \"User\" ]] = None , target_application : Optional [ Union [ \"Snowflake_Type\" , \"Application\" ]] = None , reason : Optional [ str ] = None , ) -> \"Invite\" : \"\"\" Create channel invite. Args: max_age: Max age of invite in seconds, default 86400 (24 hours). max_uses: Max uses of invite, default 0. temporary: Grants temporary membership, default False. unique: Invite is unique, default false. target_type: Target type for streams and embedded applications. target_user_id: Target User ID for Stream target type. target_application_id: Target Application ID for Embedded App target type. reason: The reason for creating this invite. Returns: Newly created Invite object. \"\"\" if target_type : if target_type == InviteTargetTypes . STREAM and not target_user : raise ValueError ( \"Stream target must include target user id.\" ) elif target_type == InviteTargetTypes . EMBEDDED_APPLICATION and not target_application : raise ValueError ( \"Embedded Application target must include target application id.\" ) if target_user and target_application : raise ValueError ( \"Invite target must be either User or Embedded Application, not both.\" ) elif target_user : target_user = to_snowflake ( target_user ) target_type = InviteTargetTypes . STREAM elif target_application : target_application = to_snowflake ( target_application ) target_type = InviteTargetTypes . EMBEDDED_APPLICATION invite_data = await self . _client . http . create_channel_invite ( self . id , max_age , max_uses , temporary , unique , target_type , target_user , target_application , reason ) return Invite . from_dict ( invite_data , self . _client ) async inherited get_invites ( self ) \u00b6 Gets all invites (with invite metadata) for the channel. Source code in dis_snek/models/discord_objects/channel.py async def get_invites ( self ) -> List [ \"Invite\" ]: \"\"\" Gets all invites (with invite metadata) for the channel. \"\"\" invites_data = await self . _client . http . get_channel_invites ( self . id ) return Invite . from_list ( invites_data , self . _client ) async inherited create_thread_with_message ( self , name , message , auto_archive_duration =< AutoArchiveDuration . ONE_DAY : 1440 > , reason = None ) \u00b6 Create a thread connected to a message Parameters: Name Type Description Default name str 1-100 character thread name required message Union[Snowflake_Type, Message] The message to connect this thread to required auto_archive_duration Union[dis_snek.models.enums.AutoArchiveDuration, int] Time before the thread will be automatically archived <AutoArchiveDuration.ONE_DAY: 1440> reason Optional[str] The reason for creating this thread None Returns: Type Description Union[GuildNewsThread, GuildPublicThread] The created thread, if successful Source code in dis_snek/models/discord_objects/channel.py async def create_thread_with_message ( self , name : str , message : Union [ \"Snowflake_Type\" , \"Message\" ], auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildNewsThread\" , \"GuildPublicThread\" ]: \"\"\" Create a thread connected to a message Args: name: 1-100 character thread name message: The message to connect this thread to auto_archive_duration: Time before the thread will be automatically archived reason: The reason for creating this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , auto_archive_duration = auto_archive_duration , message_id = to_snowflake ( message ), reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async inherited create_thread_without_message ( self , name , thread_type , invitable = None , auto_archive_duration =< AutoArchiveDuration . ONE_DAY : 1440 > , reason = None ) \u00b6 Creates a thread without a message source. Parameters: Name Type Description Default name str 1-100 character thread name required thread_type Union[dis_snek.models.enums.ChannelTypes, int] Is the thread private or public required invitable Optional[bool] whether non-moderators can add other non-moderators to a thread; only available when creating a private thread None auto_archive_duration Union[dis_snek.models.enums.AutoArchiveDuration, int] Time before the thread will be automatically archived <AutoArchiveDuration.ONE_DAY: 1440> reason Optional[str] The reason to create this thread None Returns: Type Description Union[GuildPrivateThread, GuildPublicThread] The created thread, if successful Source code in dis_snek/models/discord_objects/channel.py async def create_thread_without_message ( self , name : str , thread_type : Union [ ChannelTypes , int ], invitable : Optional [ bool ] = None , auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildPrivateThread\" , \"GuildPublicThread\" ]: \"\"\" Creates a thread without a message source. Args: name: 1-100 character thread name thread_type: Is the thread private or public invitable: whether non-moderators can add other non-moderators to a thread; only available when creating a private thread auto_archive_duration: Time before the thread will be automatically archived reason: The reason to create this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , thread_type = thread_type , auto_archive_duration = auto_archive_duration , invitable = invitable , reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async inherited get_public_archived_threads ( self , limit = None , before = None ) \u00b6 Get a ThreadList of public threads available in this channel. Parameters: Name Type Description Default limit int optional maximum number of threads to return None before Timestamp Returns threads before this timestamp None Source code in dis_snek/models/discord_objects/channel.py async def get_public_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **public** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_public_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async inherited get_private_archived_threads ( self , limit = None , before = None ) \u00b6 Get a ThreadList of private threads available in this channel. Parameters: Name Type Description Default limit int optional maximum number of threads to return None before Timestamp Returns threads before this timestamp None Source code in dis_snek/models/discord_objects/channel.py async def get_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **private** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async inherited get_joined_private_archived_threads ( self , limit = None , before = None ) \u00b6 Get a ThreadList of threads the bot is a participant of in this channel Parameters: Name Type Description Default limit int optional maximum number of threads to return None before Timestamp Returns threads before this timestamp None Source code in dis_snek/models/discord_objects/channel.py async def get_joined_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of threads the bot is a participant of in this channel Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_joined_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async inherited get_active_threads ( self ) \u00b6 Returns all active threads in the channel, including public and private threads Source code in dis_snek/models/discord_objects/channel.py async def get_active_threads ( self ) -> List [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\"Returns all active threads in the channel, including public and private threads\"\"\" raw_threads = await self . guild . get_active_threads () if hasattr ( raw_threads , \"threads\" ): return [ t for t in raw_threads . threads if t . parent_channel . id == self . id ] return [] async inherited create_webhook ( self , name , avatar = MISSING ) \u00b6 Create a webhook in this channel Parameters: Name Type Description Default name str The name of the webhook required avatar Optional[bytes] An optional default avatar to use MISSING Returns: Type Description Webhook The created webhook Exceptions: Type Description ValueError If you try to name the webhook \"Clyde\" Source code in dis_snek/models/discord_objects/channel.py async def create_webhook ( self , name : str , avatar : Optional [ bytes ] = MISSING ) -> Webhook : \"\"\" Create a webhook in this channel Args: name: The name of the webhook avatar: An optional default avatar to use Returns: The created webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" return await Webhook . create ( self . _client , self , name , avatar ) # type: ignore async inherited delete_webhook ( self , webhook ) \u00b6 Delete a given webhook in this channel Parameters: Name Type Description Default webhook Webhook The webhook to delete required Source code in dis_snek/models/discord_objects/channel.py async def delete_webhook ( self , webhook : Webhook ) -> None : \"\"\" Delete a given webhook in this channel Args: webhook: The webhook to delete \"\"\" return await webhook . delete () inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) ThreadChannel ( GuildChannel , MessageableMixin , WebhookMixin ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class ThreadChannel ( GuildChannel , MessageableMixin , WebhookMixin ): owner_id : \"Snowflake_Type\" = attr . ib ( default = None ) topic : Optional [ str ] = attr . ib ( default = None ) message_count : int = attr . ib ( default = 0 ) member_count : int = attr . ib ( default = 0 ) archived : bool = attr . ib ( default = False ) auto_archive_duration : int = attr . ib ( default = attr . Factory ( lambda self : self . default_auto_archive_duration , takes_self = True ) ) locked : bool = attr . ib ( default = False ) archive_timestamp : Optional [ Timestamp ] = attr . ib ( default = None , converter = optional_c ( timestamp_converter )) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data = super () . _process_dict ( data , client ) thread_metadata : dict = data . get ( \"thread_metadata\" , {}) data . update ( thread_metadata ) return data @property def is_private ( self ) -> bool : return self . type == ChannelTypes . GUILD_PRIVATE_THREAD @property def parent_channel ( self ) -> GuildText : \"\"\"The channel this thread is a child of\"\"\" return self . _client . cache . channel_cache . get ( self . parent_id ) @property def mention ( self ) -> str : return f \"<# { self . id } >\" async def get_members ( self ) -> List [ \"ThreadMember\" ]: members_data = await self . _client . http . list_thread_members ( self . id ) members = [] for member_data in members_data : members . append ( ThreadMember . from_dict ( member_data , self . _client )) return members async def add_member ( self , member : Union [ \"Member\" , \"Snowflake_Type\" ]) -> None : await self . _client . http . add_thread_member ( self . id , to_snowflake ( member )) async def remove_member ( self , member : Union [ \"Member\" , \"Snowflake_Type\" ]) -> None : await self . _client . http . remove_thread_member ( self . id , to_snowflake ( member )) async def join ( self ): await self . _client . http . join_thread ( self . id ) async def leave ( self ): await self . _client . http . leave_thread ( self . id ) async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message inherited history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async inherited get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async inherited delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async inherited purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count async inherited create_webhook ( self , name , avatar = MISSING ) \u00b6 Create a webhook in this channel Parameters: Name Type Description Default name str The name of the webhook required avatar Optional[bytes] An optional default avatar to use MISSING Returns: Type Description Webhook The created webhook Exceptions: Type Description ValueError If you try to name the webhook \"Clyde\" Source code in dis_snek/models/discord_objects/channel.py async def create_webhook ( self , name : str , avatar : Optional [ bytes ] = MISSING ) -> Webhook : \"\"\" Create a webhook in this channel Args: name: The name of the webhook avatar: An optional default avatar to use Returns: The created webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" return await Webhook . create ( self . _client , self , name , avatar ) # type: ignore async inherited delete_webhook ( self , webhook ) \u00b6 Delete a given webhook in this channel Parameters: Name Type Description Default webhook Webhook The webhook to delete required Source code in dis_snek/models/discord_objects/channel.py async def delete_webhook ( self , webhook : Webhook ) -> None : \"\"\" Delete a given webhook in this channel Args: webhook: The webhook to delete \"\"\" return await webhook . delete () async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) property readonly parent_channel : GuildText \u00b6 The channel this thread is a child of property readonly mention : str \u00b6 Returns a string that would mention the channel GuildNewsThread ( ThreadChannel ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildNewsThread ( ThreadChannel ): async def edit ( self , name , archived , auto_archive_duration , locked , rate_limit_per_user , reason ): payload = dict ( # TODO Proper processing name = name , archived = archived , auto_archive_duration = auto_archive_duration , locked = locked , rate_limit_per_user = rate_limit_per_user , ) await self . _edit ( payload = payload , reason = reason ) async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message inherited history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async inherited get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async inherited delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async inherited purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count async inherited create_webhook ( self , name , avatar = MISSING ) \u00b6 Create a webhook in this channel Parameters: Name Type Description Default name str The name of the webhook required avatar Optional[bytes] An optional default avatar to use MISSING Returns: Type Description Webhook The created webhook Exceptions: Type Description ValueError If you try to name the webhook \"Clyde\" Source code in dis_snek/models/discord_objects/channel.py async def create_webhook ( self , name : str , avatar : Optional [ bytes ] = MISSING ) -> Webhook : \"\"\" Create a webhook in this channel Args: name: The name of the webhook avatar: An optional default avatar to use Returns: The created webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" return await Webhook . create ( self . _client , self , name , avatar ) # type: ignore async inherited delete_webhook ( self , webhook ) \u00b6 Delete a given webhook in this channel Parameters: Name Type Description Default webhook Webhook The webhook to delete required Source code in dis_snek/models/discord_objects/channel.py async def delete_webhook ( self , webhook : Webhook ) -> None : \"\"\" Delete a given webhook in this channel Args: webhook: The webhook to delete \"\"\" return await webhook . delete () async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) inherited property readonly parent_channel : GuildText \u00b6 The channel this thread is a child of inherited property readonly mention : str \u00b6 Returns a string that would mention the channel GuildPublicThread ( ThreadChannel ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildPublicThread ( ThreadChannel ): async def edit ( self , name , archived , auto_archive_duration , locked , rate_limit_per_user , reason ): payload = dict ( # TODO Proper processing name = name , archived = archived , auto_archive_duration = auto_archive_duration , locked = locked , rate_limit_per_user = rate_limit_per_user , ) await self . _edit ( payload = payload , reason = reason ) async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message inherited history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async inherited get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async inherited delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async inherited purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count async inherited create_webhook ( self , name , avatar = MISSING ) \u00b6 Create a webhook in this channel Parameters: Name Type Description Default name str The name of the webhook required avatar Optional[bytes] An optional default avatar to use MISSING Returns: Type Description Webhook The created webhook Exceptions: Type Description ValueError If you try to name the webhook \"Clyde\" Source code in dis_snek/models/discord_objects/channel.py async def create_webhook ( self , name : str , avatar : Optional [ bytes ] = MISSING ) -> Webhook : \"\"\" Create a webhook in this channel Args: name: The name of the webhook avatar: An optional default avatar to use Returns: The created webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" return await Webhook . create ( self . _client , self , name , avatar ) # type: ignore async inherited delete_webhook ( self , webhook ) \u00b6 Delete a given webhook in this channel Parameters: Name Type Description Default webhook Webhook The webhook to delete required Source code in dis_snek/models/discord_objects/channel.py async def delete_webhook ( self , webhook : Webhook ) -> None : \"\"\" Delete a given webhook in this channel Args: webhook: The webhook to delete \"\"\" return await webhook . delete () async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) inherited property readonly parent_channel : GuildText \u00b6 The channel this thread is a child of inherited property readonly mention : str \u00b6 Returns a string that would mention the channel GuildPrivateThread ( ThreadChannel ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildPrivateThread ( ThreadChannel ): invitable : bool = field ( default = False ) async def edit ( self , name , archived , auto_archive_duration , locked , rate_limit_per_user , invitable , reason ): payload = dict ( # TODO Proper processing name = name , archived = archived , auto_archive_duration = auto_archive_duration , locked = locked , rate_limit_per_user = rate_limit_per_user , invitable = invitable , ) await self . _edit ( payload = payload , reason = reason ) async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/channel.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited get_message ( self , message_id ) \u00b6 Fetch a message from the channel. Parameters: Name Type Description Default message_id Snowflake_Type ID of message to retrieve. required Returns: Type Description Message The message object fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message inherited history ( self , limit = 100 , before = None , after = None , around = None ) \u00b6 Get an async iterator for the history of this channel Paramters limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID Example Usage: 1 2 3 4 5 async for message in channel . history ( limit = 0 ): if message . author . id == 174918559539920897 : print ( \"Found author's message\" ) # ... break or 1 2 3 history = channel . history ( limit = 250 ) # Flatten the async iterator into a list messages = await history . flatten () Returns: Type Description ChannelHistory (AsyncIterator) Source code in dis_snek/models/discord_objects/channel.py def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async inherited get_messages ( self , limit = 50 , around = MISSING , before = MISSING , after = MISSING ) \u00b6 Fetch multiple messages from the channel. Parameters: Name Type Description Default limit int Max number of messages to return, default 50 , max 100 50 around Snowflake_Type Message to get messages around MISSING before Snowflake_Type Message to get messages before MISSING after Snowflake_Type Message to get messages after MISSING Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited get_pinned_messages ( self ) \u00b6 Fetch pinned messages from the channel. Returns: Type Description List[Message] A list of messages fetched. Source code in dis_snek/models/discord_objects/channel.py async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async inherited delete_messages ( self , messages , reason = MISSING ) \u00b6 Bulk delete messages from channel. Parameters: Name Type Description Default messages List[Union[Snowflake_Type, Message]] List of messages or message IDs to delete. required reason Optional[str] The reason for this action. Used for audit logs. MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async inherited delete_message ( self , message , reason = None ) \u00b6 Delete a single message from a channel. Parameters: Name Type Description Default message Union[Snowflake_Type, Message] The message to delete required reason str The reason for this action None Source code in dis_snek/models/discord_objects/channel.py async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async inherited purge ( self , deletion_limit = 50 , search_limit = 100 , predicate = MISSING , before = MISSING , after = MISSING , around = MISSING , reason = MISSING ) \u00b6 Bulk delete messages within a channel. If a predicate is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the deletion_limit Example Usage: 1 2 3 # this will delete the last 20 messages sent by a user with the given ID deleted = await channel . purge ( deletion_limit = 20 , predicate = lambda m : m . author . id == 174918559539920897 ) await channel . send ( f \" { deleted } messages deleted\" ) Parameters: Name Type Description Default deletion_limit int The target amount of messages to delete 50 search_limit int How many messages to search through 100 predicate Callable[[Message], bool] A function that returns True or False, and takes a message as an argument MISSING before Optional[Snowflake_Type] Search messages before this ID MISSING after Optional[Snowflake_Type] Search messages after this ID MISSING around Optional[Snowflake_Type] Search messages around this ID MISSING reason Optional[str] The reason for this deletion MISSING Returns: Type Description int The total amount of messages deleted Source code in dis_snek/models/discord_objects/channel.py async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count async inherited create_webhook ( self , name , avatar = MISSING ) \u00b6 Create a webhook in this channel Parameters: Name Type Description Default name str The name of the webhook required avatar Optional[bytes] An optional default avatar to use MISSING Returns: Type Description Webhook The created webhook Exceptions: Type Description ValueError If you try to name the webhook \"Clyde\" Source code in dis_snek/models/discord_objects/channel.py async def create_webhook ( self , name : str , avatar : Optional [ bytes ] = MISSING ) -> Webhook : \"\"\" Create a webhook in this channel Args: name: The name of the webhook avatar: An optional default avatar to use Returns: The created webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" return await Webhook . create ( self . _client , self , name , avatar ) # type: ignore async inherited delete_webhook ( self , webhook ) \u00b6 Delete a given webhook in this channel Parameters: Name Type Description Default webhook Webhook The webhook to delete required Source code in dis_snek/models/discord_objects/channel.py async def delete_webhook ( self , webhook : Webhook ) -> None : \"\"\" Delete a given webhook in this channel Args: webhook: The webhook to delete \"\"\" return await webhook . delete () async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) inherited property readonly parent_channel : GuildText \u00b6 The channel this thread is a child of inherited property readonly mention : str \u00b6 Returns a string that would mention the channel VoiceChannel ( GuildChannel ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class VoiceChannel ( GuildChannel ): # TODO May not be needed, can be directly just GuildVoice. bitrate : int = attr . ib () user_limit : int = attr . ib () rtc_region : str = attr . ib ( default = \"auto\" ) video_quality_mode : Union [ VideoQualityModes , int ] = attr . ib ( default = VideoQualityModes . AUTO ) async def edit ( self , name , position , permission_overwrites , parent_id , bitrate , user_limit , rtc_region , video_quality_mode , reason , ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , parent_id = parent_id , bitrate = bitrate , user_limit = user_limit , rtc_region = rtc_region , video_quality_mode = video_quality_mode , ) await self . _edit ( payload = payload , reason = reason ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) GuildVoice ( VoiceChannel , InvitableMixin ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildVoice ( VoiceChannel , InvitableMixin ): pass inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited create_invite ( self , max_age = 86400 , max_uses = 0 , temporary = False , unique = False , target_type = None , target_user = None , target_application = None , reason = None ) \u00b6 Create channel invite. Parameters: Name Type Description Default max_age int Max age of invite in seconds, default 86400 (24 hours). 86400 max_uses int Max uses of invite, default 0. 0 temporary bool Grants temporary membership, default False. False unique bool Invite is unique, default false. False target_type Optional[InviteTargetTypes] Target type for streams and embedded applications. None target_user_id Target User ID for Stream target type. required target_application_id Target Application ID for Embedded App target type. required reason Optional[str] The reason for creating this invite. None Returns: Type Description Invite Newly created Invite object. Source code in dis_snek/models/discord_objects/channel.py async def create_invite ( self , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : Optional [ \"InviteTargetTypes\" ] = None , target_user : Optional [ Union [ \"Snowflake_Type\" , \"User\" ]] = None , target_application : Optional [ Union [ \"Snowflake_Type\" , \"Application\" ]] = None , reason : Optional [ str ] = None , ) -> \"Invite\" : \"\"\" Create channel invite. Args: max_age: Max age of invite in seconds, default 86400 (24 hours). max_uses: Max uses of invite, default 0. temporary: Grants temporary membership, default False. unique: Invite is unique, default false. target_type: Target type for streams and embedded applications. target_user_id: Target User ID for Stream target type. target_application_id: Target Application ID for Embedded App target type. reason: The reason for creating this invite. Returns: Newly created Invite object. \"\"\" if target_type : if target_type == InviteTargetTypes . STREAM and not target_user : raise ValueError ( \"Stream target must include target user id.\" ) elif target_type == InviteTargetTypes . EMBEDDED_APPLICATION and not target_application : raise ValueError ( \"Embedded Application target must include target application id.\" ) if target_user and target_application : raise ValueError ( \"Invite target must be either User or Embedded Application, not both.\" ) elif target_user : target_user = to_snowflake ( target_user ) target_type = InviteTargetTypes . STREAM elif target_application : target_application = to_snowflake ( target_application ) target_type = InviteTargetTypes . EMBEDDED_APPLICATION invite_data = await self . _client . http . create_channel_invite ( self . id , max_age , max_uses , temporary , unique , target_type , target_user , target_application , reason ) return Invite . from_dict ( invite_data , self . _client ) async inherited get_invites ( self ) \u00b6 Gets all invites (with invite metadata) for the channel. Source code in dis_snek/models/discord_objects/channel.py async def get_invites ( self ) -> List [ \"Invite\" ]: \"\"\" Gets all invites (with invite metadata) for the channel. \"\"\" invites_data = await self . _client . http . get_channel_invites ( self . id ) return Invite . from_list ( invites_data , self . _client ) inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) GuildStageVoice ( GuildVoice ) attrs \u00b6 Source code in dis_snek/models/discord_objects/channel.py @define () class GuildStageVoice ( GuildVoice ): stage_instance : \"StageInstance\" = attr . ib ( default = MISSING ) # todo: Listeners and speakers properties (needs voice state caching) async def get_stage_instance ( self ): \"\"\"Gets the stage instance associated with this channel. If no stage is live, will return None.\"\"\" self . stage_instance = StageInstance . from_dict ( await self . _client . http . get_stage_instance ( self . id ), self . _client ) return self . stage_instance async def create_stage_instance ( self , topic : str , privacy_level : StagePrivacyLevel = StagePrivacyLevel . GUILD_ONLY , reason : Optional [ str ] = MISSING , ): \"\"\" Create a stage instance in this channel. Arguments: topic: The topic of the stage (1-120 characters) privacy_level: The privacy level of the stage reason: The reason for creating this instance \"\"\" self . stage_instance = StageInstance . from_dict ( await self . _client . http . create_stage_instance ( self . id , topic , privacy_level , reason ), self . _client ) return self . stage_instance async def close_stage ( self , reason : Optional [ str ] = MISSING ): \"\"\" Closes the live stage instance Arguments: reason: The reason for closing the stage \"\"\" if not self . stage_instance : # we dont know of an active stage instance, so lets check for one if not await self . get_stage_instance (): raise ValueError ( \"No stage instance found\" ) await self . stage_instance . delete ( reason = reason ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/channel.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/channel.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async inherited create_invite ( self , max_age = 86400 , max_uses = 0 , temporary = False , unique = False , target_type = None , target_user = None , target_application = None , reason = None ) \u00b6 Create channel invite. Parameters: Name Type Description Default max_age int Max age of invite in seconds, default 86400 (24 hours). 86400 max_uses int Max uses of invite, default 0. 0 temporary bool Grants temporary membership, default False. False unique bool Invite is unique, default false. False target_type Optional[InviteTargetTypes] Target type for streams and embedded applications. None target_user_id Target User ID for Stream target type. required target_application_id Target Application ID for Embedded App target type. required reason Optional[str] The reason for creating this invite. None Returns: Type Description Invite Newly created Invite object. Source code in dis_snek/models/discord_objects/channel.py async def create_invite ( self , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : Optional [ \"InviteTargetTypes\" ] = None , target_user : Optional [ Union [ \"Snowflake_Type\" , \"User\" ]] = None , target_application : Optional [ Union [ \"Snowflake_Type\" , \"Application\" ]] = None , reason : Optional [ str ] = None , ) -> \"Invite\" : \"\"\" Create channel invite. Args: max_age: Max age of invite in seconds, default 86400 (24 hours). max_uses: Max uses of invite, default 0. temporary: Grants temporary membership, default False. unique: Invite is unique, default false. target_type: Target type for streams and embedded applications. target_user_id: Target User ID for Stream target type. target_application_id: Target Application ID for Embedded App target type. reason: The reason for creating this invite. Returns: Newly created Invite object. \"\"\" if target_type : if target_type == InviteTargetTypes . STREAM and not target_user : raise ValueError ( \"Stream target must include target user id.\" ) elif target_type == InviteTargetTypes . EMBEDDED_APPLICATION and not target_application : raise ValueError ( \"Embedded Application target must include target application id.\" ) if target_user and target_application : raise ValueError ( \"Invite target must be either User or Embedded Application, not both.\" ) elif target_user : target_user = to_snowflake ( target_user ) target_type = InviteTargetTypes . STREAM elif target_application : target_application = to_snowflake ( target_application ) target_type = InviteTargetTypes . EMBEDDED_APPLICATION invite_data = await self . _client . http . create_channel_invite ( self . id , max_age , max_uses , temporary , unique , target_type , target_user , target_application , reason ) return Invite . from_dict ( invite_data , self . _client ) async inherited get_invites ( self ) \u00b6 Gets all invites (with invite metadata) for the channel. Source code in dis_snek/models/discord_objects/channel.py async def get_invites ( self ) -> List [ \"Invite\" ]: \"\"\" Gets all invites (with invite metadata) for the channel. \"\"\" invites_data = await self . _client . http . get_channel_invites ( self . id ) return Invite . from_list ( invites_data , self . _client ) inherited property readonly mention : str \u00b6 Returns a string that would mention the channel async inherited delete ( self , reason = MISSING ) \u00b6 Delete this channel. Parameters: Name Type Description Default reason Optional[str] The reason for deleting this channel MISSING Source code in dis_snek/models/discord_objects/channel.py async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason ) async get_stage_instance ( self ) \u00b6 Gets the stage instance associated with this channel. If no stage is live, will return None. Source code in dis_snek/models/discord_objects/channel.py async def get_stage_instance ( self ): \"\"\"Gets the stage instance associated with this channel. If no stage is live, will return None.\"\"\" self . stage_instance = StageInstance . from_dict ( await self . _client . http . get_stage_instance ( self . id ), self . _client ) return self . stage_instance async create_stage_instance ( self , topic , privacy_level =< StagePrivacyLevel . GUILD_ONLY : 2 > , reason = MISSING ) \u00b6 Create a stage instance in this channel. Parameters: Name Type Description Default topic str The topic of the stage (1-120 characters) required privacy_level StagePrivacyLevel The privacy level of the stage <StagePrivacyLevel.GUILD_ONLY: 2> reason Optional[str] The reason for creating this instance MISSING Source code in dis_snek/models/discord_objects/channel.py async def create_stage_instance ( self , topic : str , privacy_level : StagePrivacyLevel = StagePrivacyLevel . GUILD_ONLY , reason : Optional [ str ] = MISSING , ): \"\"\" Create a stage instance in this channel. Arguments: topic: The topic of the stage (1-120 characters) privacy_level: The privacy level of the stage reason: The reason for creating this instance \"\"\" self . stage_instance = StageInstance . from_dict ( await self . _client . http . create_stage_instance ( self . id , topic , privacy_level , reason ), self . _client ) return self . stage_instance async close_stage ( self , reason = MISSING ) \u00b6 Closes the live stage instance Parameters: Name Type Description Default reason Optional[str] The reason for closing the stage MISSING Source code in dis_snek/models/discord_objects/channel.py async def close_stage ( self , reason : Optional [ str ] = MISSING ): \"\"\" Closes the live stage instance Arguments: reason: The reason for closing the stage \"\"\" if not self . stage_instance : # we dont know of an active stage instance, so lets check for one if not await self . get_stage_instance (): raise ValueError ( \"No stage instance found\" ) await self . stage_instance . delete ( reason = reason ) BaseComponent ( DictSerializationMixin ) attrs \u00b6 A base component class. This should never be instantiated. Source code in dis_snek/models/discord_objects/components.py class BaseComponent ( DictSerializationMixin ): \"\"\" A base component class. This should never be instantiated. \"\"\" def __init__ ( self ) -> None : raise NotImplementedError @classmethod def from_dict_factory ( cls , data : dict ) -> \"TYPE_ALL_COMPONENT\" : data . pop ( \"hash\" , None ) # TODO Zero clue why discord sometimes include a hash attribute... component_type = data . pop ( \"type\" , None ) component_class = TYPE_COMPONENT_MAPPING . get ( component_type , None ) if not component_class : raise TypeError ( f \"Unsupported component type for { data } ( { component_type } ), please consult the docs.\" ) return component_class . from_dict ( data ) inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/components.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/components.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) InteractiveComponent ( BaseComponent ) attrs \u00b6 A base interactive component class. This should never be instantiated. Source code in dis_snek/models/discord_objects/components.py class InteractiveComponent ( BaseComponent ): \"\"\" A base interactive component class. This should never be instantiated. \"\"\" def __eq__ ( self , other : Any ) -> bool : if isinstance ( other , dict ): other = BaseComponent . from_dict_factory ( other ) return self . custom_id == other . custom_id and self . type == other . type return False inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/components.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/components.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) Button ( InteractiveComponent ) attrs \u00b6 Represents a discord ui button Attributes: Name Type Description style optional[ButtonStyles, int] Buttons come in a variety of styles to convey different types of actions. label optional[str] The text that appears on the button, max 80 characters. emoji optional[Union[Emoji, dict, str]] The emoji that appears on the button. custom_id Optional[str] A developer-defined identifier for the button, max 100 characters. url Optional[str] A url for link-style buttons. disabled bool Disable the button and make it not interactable, default false. Source code in dis_snek/models/discord_objects/components.py @attr . s ( slots = True , eq = False ) class Button ( InteractiveComponent ): \"\"\" Represents a discord ui button Attributes: style optional[ButtonStyles, int]: Buttons come in a variety of styles to convey different types of actions. label optional[str]: The text that appears on the button, max 80 characters. emoji optional[Union[Emoji, dict, str]]: The emoji that appears on the button. custom_id Optional[str]: A developer-defined identifier for the button, max 100 characters. url Optional[str]: A url for link-style buttons. disabled bool: Disable the button and make it not interactable, default false. \"\"\" style : Union [ ButtonStyles , int ] = attr . ib () label : Optional [ str ] = attr . ib ( default = None ) emoji : Optional [ Union [ \"Emoji\" , dict , str ]] = attr . ib ( default = None , metadata = export_converter ( process_emoji )) custom_id : Optional [ str ] = attr . ib ( default = MISSING , validator = str_validator ) url : Optional [ str ] = attr . ib ( default = None ) disabled : bool = attr . ib ( default = False ) type : Union [ ComponentTypes , int ] = attr . ib ( default = ComponentTypes . BUTTON , init = False , on_setattr = attr . setters . frozen ) @style . validator def _style_validator ( self , attribute : str , value : int ): if not isinstance ( value , ButtonStyles ) and value not in ButtonStyles . __members__ . values (): raise ValueError ( f 'Button style type of \" { value } \" not recognized, please consult the docs.' ) def __attrs_post_init__ ( self ): if self . style != ButtonStyles . URL : # handle adding a custom id to any button that requires a custom id if self . custom_id is MISSING : self . custom_id = str ( uuid . uuid4 ()) def _check_object ( self ): if self . style == ButtonStyles . URL : if self . custom_id not in ( None , MISSING ): raise TypeError ( \"A link button cannot have a `custom_id`!\" ) if not self . url : raise TypeError ( \"A link button must have a `url`!\" ) else : if self . url : raise TypeError ( \"You can't have a URL on a non-link button!\" ) if not self . label and not self . emoji : raise TypeError ( \"You must have at least a label or emoji on a button.\" ) inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/components.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/components.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) SelectOption ( BaseComponent ) attrs \u00b6 Represents a select option. Attributes: Name Type Description label str The label (max 80 characters) value str The value of the select, this is whats sent to your bot description Optional[str] A description of this option emoji Optional[Union[Emoji, dict, str] An emoji to show in this select option default bool Is this option selected by default Source code in dis_snek/models/discord_objects/components.py @attr . s ( slots = True ) class SelectOption ( BaseComponent ): \"\"\" Represents a select option. Attributes: label str: The label (max 80 characters) value str: The value of the select, this is whats sent to your bot description Optional[str]: A description of this option emoji Optional[Union[Emoji, dict, str]: An emoji to show in this select option default bool: Is this option selected by default \"\"\" label : str = attr . ib ( validator = str_validator ) value : str = attr . ib ( validator = str_validator ) description : Optional [ str ] = attr . ib ( default = None ) emoji : Optional [ Union [ \"Emoji\" , dict , str ]] = attr . ib ( default = None , metadata = export_converter ( process_emoji )) default : bool = attr . ib ( default = False ) @label . validator def _label_validator ( self , attribute : str , value : str ): if not value or len ( value ) > SELECT_MAX_NAME_LENGTH : raise ValueError ( \"Label length should be between 1 and 100.\" ) @value . validator def _value_validator ( self , attribute : str , value : str ): if not value or len ( value ) > SELECT_MAX_NAME_LENGTH : raise ValueError ( \"Value length should be between 1 and 100.\" ) @description . validator def _description_validator ( self , attribute : str , value : str ): if value is not None and len ( value ) > SELECT_MAX_NAME_LENGTH : raise ValueError ( \"Description length must be 100 or lower.\" ) inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/components.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/components.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) Select ( InteractiveComponent ) attrs \u00b6 Represents a select component. Attributes: Name Type Description options List[dict] The choices in the select, max 25. custom_id str A developer-defined identifier for the button, max 100 characters. placeholder str The custom placeholder text to show if nothing is selected, max 100 characters. min_values Optional[int] The minimum number of items that must be chosen. (default 1, min 0, max 25) max_values Optional[int] The maximum number of items that can be chosen. (default 1, max 25) disabled bool Disable the select and make it not intractable, default false. type Union[ComponentTypes, int] The action role type number defined by discord. This cannot be modified. Source code in dis_snek/models/discord_objects/components.py @attr . s ( slots = True , eq = False ) class Select ( InteractiveComponent ): \"\"\" Represents a select component. Attributes: options List[dict]: The choices in the select, max 25. custom_id str: A developer-defined identifier for the button, max 100 characters. placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters. min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25) max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25) disabled bool: Disable the select and make it not intractable, default false. type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified. \"\"\" options : List [ Union [ SelectOption , Dict ]] = attr . ib ( factory = list ) custom_id : str = attr . ib ( factory = uuid . uuid4 , validator = str_validator ) placeholder : str = attr . ib ( default = None ) min_values : Optional [ int ] = attr . ib ( default = 1 ) max_values : Optional [ int ] = attr . ib ( default = 1 ) disabled : bool = attr . ib ( default = False ) type : Union [ ComponentTypes , int ] = attr . ib ( default = ComponentTypes . SELECT , init = False , on_setattr = attr . setters . frozen ) def __len__ ( self ) -> int : return len ( self . options ) @placeholder . validator def _placeholder_validator ( self , attribute : str , value : str ): if value is not None and len ( value ) > SELECT_MAX_NAME_LENGTH : raise ValueError ( \"Placeholder length must be 100 or lower.\" ) @min_values . validator def _min_values_validator ( self , attribute : str , value : int ): if value < 0 : raise ValueError ( \"Select min value cannot be a negative number.\" ) @max_values . validator def _max_values_validator ( self , attribute : str , value : int ): if value < 0 : raise ValueError ( \"Select max value cannot be a negative number.\" ) @options . validator def _options_validator ( self , attribute : str , value : List [ Union [ SelectOption , Dict ]]): if not all ( isinstance ( x , ( SelectOption , Dict )) for x in value ): raise ValueError ( f \"Select options must be of type `SelectOption`\" ) def _check_object ( self ): if not self . custom_id : raise TypeError ( \"You need to have a custom id to identify the select.\" ) if not self . options : raise TypeError ( \"Selects needs to have at least 1 option.\" ) if len ( self . options ) > SELECTS_MAX_OPTIONS : raise TypeError ( \"Selects can only hold 25 options\" ) if self . max_values < self . min_values : raise TypeError ( \"Selects max value cannot be less than min value.\" ) def add_option ( self , option : Union [ SelectOption ]): if not isinstance ( option , ( SelectOption , Dict )): raise ValueError ( f \"Select option must be of `SelectOption` type, not { type ( option ) } \" ) self . options . append ( option ) inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/components.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/components.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) ActionRow ( BaseComponent ) attrs \u00b6 Represents an action row Attributes: Name Type Description components List[Union[dict, Select, Button]] The components within this action row type Union[ComponentTypes, int] The action role type number defined by discord. This cannot be modified. Source code in dis_snek/models/discord_objects/components.py @attr . s ( slots = True , init = False ) class ActionRow ( BaseComponent ): \"\"\" Represents an action row Attributes: components List[Union[dict, Select, Button]]: The components within this action row type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified. \"\"\" _max_items = ACTION_ROW_MAX_ITEMS components : List [ Union [ dict , Select , Button ]] = attr . ib ( factory = list ) type : Union [ ComponentTypes , int ] = attr . ib ( default = ComponentTypes . ACTION_ROW , init = False , on_setattr = attr . setters . frozen ) def __init__ ( self , * components : Union [ dict , Select , Button ]) -> None : self . __attrs_init__ ( components ) self . components = [ self . _component_checks ( c ) for c in self . components ] def __len__ ( self ) -> int : return len ( self . components ) @classmethod def from_dict ( cls , data ): return cls ( * data [ \"components\" ]) def _component_checks ( self , component : Union [ dict , Select , Button ]): if isinstance ( component , dict ): component = BaseComponent . from_dict_factory ( component ) if not issubclass ( type ( component ), InteractiveComponent ): raise TypeError ( \"You can only add select or button to the action row.\" ) component . _check_object () return component def _check_object ( self ): if not ( 0 < len ( self . components ) <= ActionRow . _max_items ): raise TypeError ( f \"Number of components in one row should be between 1 and { ActionRow . _max_items } .\" ) if any ( x . type == ComponentTypes . SELECT for x in self . components ) and len ( self . components ) != 1 : raise TypeError ( \"Action row must have only one select component and nothing else.\" ) def add_components ( self , * components : Union [ dict , Button , Select ]): \"\"\" Add one or more component(s) to this action row Args: components: The components to add \"\"\" for c in components : self . components . append ( self . _component_checks ( c )) inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/components.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/components.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) classmethod from_dict ( data ) \u00b6 Process and converts dictionary data received from discord api to object class instance. Parameters: Name Type Description Default data The json data received from discord api. required Source code in dis_snek/models/discord_objects/components.py @classmethod def from_dict ( cls , data ): return cls ( * data [ \"components\" ]) add_components ( self , * components ) \u00b6 Add one or more component(s) to this action row Parameters: Name Type Description Default components Union[dict, dis_snek.models.discord_objects.components.Button, dis_snek.models.discord_objects.components.Select] The components to add () Source code in dis_snek/models/discord_objects/components.py def add_components ( self , * components : Union [ dict , Button , Select ]): \"\"\" Add one or more component(s) to this action row Args: components: The components to add \"\"\" for c in components : self . components . append ( self . _component_checks ( c )) process_components ( components ) \u00b6 Process the passed components into a format discord will understand. Parameters: Name Type Description Default components Union[List[List[Union[dis_snek.models.discord_objects.components.BaseComponent, Dict]]], List[Union[dis_snek.models.discord_objects.components.BaseComponent, Dict]], dis_snek.models.discord_objects.components.BaseComponent, Dict] List of dict / components to process required Returns: Type Description List[Dict] formatted dictionary for discord Exceptions: Type Description ValueError Invalid components Source code in dis_snek/models/discord_objects/components.py def process_components ( components : Optional [ Union [ List [ List [ Union [ BaseComponent , Dict ]]], List [ Union [ BaseComponent , Dict ]], BaseComponent , Dict ] ] ) -> List [ Dict ]: \"\"\" Process the passed components into a format discord will understand. Args: components: List of dict / components to process Returns: formatted dictionary for discord Raises: ValueError: Invalid components \"\"\" if not components : # Its just empty, so nothing to process. return components if isinstance ( components , dict ): # If a naked dictionary is passed, assume the user knows what they're doing and send it blindly # after wrapping it in a list for discord return [ components ] if issubclass ( type ( components ), BaseComponent ): # Naked component was passed components = [ components ] if isinstance ( components , list ): if all ( isinstance ( c , dict ) for c in components ): # user has passed a list of dicts, this is the correct format, blindly send it return components if all ( isinstance ( c , list ) for c in components ): # list of lists... actionRow-less sending return [ ActionRow ( * row ) . to_dict () for row in components ] if all ( issubclass ( type ( c ), InteractiveComponent ) for c in components ): # list of naked components return [ ActionRow ( * components ) . to_dict ()] if all ( isinstance ( c , ActionRow ) for c in components ): # we have a list of action rows return [ action_row . to_dict () for action_row in components ] raise ValueError ( f \"Invalid components: { components } \" ) spread_to_rows ( * components , * , max_in_row = 5 ) \u00b6 A helper function that spreads your components into ActionRow s of a set size Parameters: Name Type Description Default *components Union[dis_snek.models.discord_objects.components.ActionRow, dis_snek.models.discord_objects.components.Button, dis_snek.models.discord_objects.components.Select] The components to spread, use None to explicit start a new row () max_in_row The maximum number of components in each row 5 Returns: Type Description List[dis_snek.models.discord_objects.components.ActionRow] List[ActionRow] of components spread to rows Exceptions: Type Description ValueError Too many or few components or rows Source code in dis_snek/models/discord_objects/components.py def spread_to_rows ( * components : Union [ ActionRow , Button , Select ], max_in_row = 5 ) -> List [ ActionRow ]: \"\"\" A helper function that spreads your components into `ActionRow`s of a set size Args: *components: The components to spread, use `None` to explicit start a new row max_in_row: The maximum number of components in each row Returns: List[ActionRow] of components spread to rows Raises: ValueError: Too many or few components or rows \"\"\" # todo: incorrect format errors if not components or len ( components ) > 25 : raise ValueError ( \"Number of components should be between 1 and 25.\" ) if not 1 <= max_in_row <= 5 : raise ValueError ( \"max_in_row should be between 1 and 5.\" ) rows = [] button_row = [] for component in list ( components ): if component is not None and component . type == ComponentTypes . BUTTON : button_row . append ( component ) if len ( button_row ) == max_in_row : rows . append ( ActionRow ( * button_row )) button_row = [] continue if button_row : rows . append ( ActionRow ( * button_row )) button_row = [] if component is not None : if component . type == ComponentTypes . ACTION_ROW : rows . append ( component ) elif component . type == ComponentTypes . SELECT : rows . append ( ActionRow ( component )) if button_row : rows . append ( ActionRow ( * button_row )) if len ( rows ) > 5 : raise ValueError ( \"Number of rows exceeds 5.\" ) return rows get_components_ids ( component ) \u00b6 Returns generator with the custom_id of a component or list of components. Parameters: Name Type Description Default component Union[str, dict, list, dis_snek.models.discord_objects.components.InteractiveComponent] Objects to get custom_id s from required Exceptions: Type Description ValueError Unknown component type Source code in dis_snek/models/discord_objects/components.py def get_components_ids ( component : Union [ str , dict , list , InteractiveComponent ]) -> Iterator [ str ]: \"\"\" Returns generator with the `custom_id` of a component or list of components. Args: component: Objects to get `custom_id`s from Raises: ValueError: Unknown component type \"\"\" if isinstance ( component , str ): yield component elif isinstance ( component , dict ): if component [ \"type\" ] == ComponentTypes . actionrow : yield from ( comp [ \"custom_id\" ] for comp in component [ \"components\" ] if \"custom_id\" in comp ) elif \"custom_id\" in component : yield component [ \"custom_id\" ] elif c_id := getattr ( component , \"custom_id\" , None ): yield c_id elif isinstance ( component , ActionRow ): yield from ( comp_id for comp in component . components for comp_id in get_components_ids ( comp )) elif isinstance ( component , list ): yield from ( comp_id for comp in component for comp_id in get_components_ids ( comp )) else : raise ValueError ( f \"Unknown component type of { component } ( { type ( component ) } ). \" f \"Expected str, dict or list\" ) EmbedField ( DictSerializationMixin ) attrs \u00b6 Representation of an embed field. Attributes: Name Type Description name str Field name value str Field value inline bool If the field should be inline Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedField ( DictSerializationMixin ): \"\"\"Representation of an embed field. Attributes: name: Field name value: Field value inline: If the field should be inline \"\"\" name : str = attr . ib () value : str = attr . ib () inline : bool = attr . ib ( default = False ) def __len__ ( self ): return len ( self . name ) + len ( self . value ) inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/embed.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) EmbedAuthor attrs \u00b6 Representation of an embed author Attributes: Name Type Description name Optional[str] Name to show on embed url Optional[str] Url to go to when name is clicked icon_url Optional[str] Icon to show next to name proxy_icon_url Optional[str] Proxy icon url Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedAuthor : \"\"\"Representation of an embed author Attributes: name: Name to show on embed url: Url to go to when name is clicked icon_url: Icon to show next to name proxy_icon_url: Proxy icon url \"\"\" name : Optional [ str ] = attr . ib ( default = None ) url : Optional [ str ] = attr . ib ( default = None ) icon_url : Optional [ str ] = attr . ib ( default = None ) proxy_icon_url : Optional [ str ] = attr . ib ( default = None , metadata = no_export_meta ) def __len__ ( self ): return len ( self . name ) EmbedAttachment attrs \u00b6 Representation of an attachment Attributes: Name Type Description url Optional[str] Attachment url proxy_url Optional[str] Proxy url height Optional[int] Attachment height width Optional[int] Attachment width Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedAttachment : # thumbnail or image or video \"\"\"Representation of an attachment Attributes: url: Attachment url proxy_url: Proxy url height: Attachment height width: Attachment width \"\"\" url : Optional [ str ] = attr . ib ( default = None ) proxy_url : Optional [ str ] = attr . ib ( default = None , metadata = no_export_meta ) height : Optional [ int ] = attr . ib ( default = None , metadata = no_export_meta ) width : Optional [ int ] = attr . ib ( default = None , metadata = no_export_meta ) @property def size ( self ): return self . height , self . width EmbedFooter attrs \u00b6 Representation of an Embed Footer Attributes: Name Type Description text str Footer text icon_url Optional[str] Footer icon url proxy_icon_url Optional[str] Proxy icon url Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedFooter : \"\"\"Representation of an Embed Footer Attributes: text: Footer text icon_url: Footer icon url proxy_icon_url: Proxy icon url \"\"\" text : str = attr . ib () icon_url : Optional [ str ] = attr . ib ( default = None ) proxy_icon_url : Optional [ str ] = attr . ib ( default = None , metadata = no_export_meta ) def __len__ ( self ): return len ( self . text ) EmbedProvider attrs \u00b6 Represents an embed's provider. Note Only used by system embeds, not bots Attributes: Name Type Description name Optional[str] Provider name url Optional[str] Provider url Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedProvider : \"\"\" Represents an embed's provider. Note: Only used by system embeds, not bots Attributes: name: Provider name url: Provider url \"\"\" name : Optional [ str ] = attr . ib ( default = None ) url : Optional [ str ] = attr . ib ( default = None ) Embed ( DictSerializationMixin ) attrs \u00b6 Represents a discord embed object. Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class Embed ( DictSerializationMixin ): \"\"\"Represents a discord embed object.\"\"\" title : Optional [ str ] = field ( default = None , repr = True ) \"\"\"The title of the embed\"\"\" description : Optional [ str ] = field ( default = None , repr = True ) \"\"\"The description of the embed\"\"\" color : Optional [ Union [ str , int , Color ]] = field ( default = None , repr = True ) \"\"\"The colour of the embed\"\"\" url : Optional [ str ] = field ( default = None , validator = v_optional ( instance_of ( str )), repr = True ) \"\"\"The url the embed should direct to when clicked\"\"\" timestamp : Optional [ Timestamp ] = field ( default = None , converter = c_optional ( timestamp_converter ), on_setattr = setters . convert , validator = v_optional ( instance_of (( datetime , float , int ))), repr = True , ) \"\"\"Timestamp of embed content\"\"\" fields : List [ EmbedField ] = field ( factory = list , converter = list_converter ( EmbedField . from_dict ), repr = True ) \"\"\"A list of [fields][dis_snek.models.discord_objects.embed.EmbedField] to go in the embed\"\"\" author : Optional [ EmbedAuthor ] = field ( default = None , converter = c_optional ( EmbedAuthor )) \"\"\"The author of the embed\"\"\" thumbnail : Optional [ EmbedAttachment ] = field ( default = None , converter = c_optional ( EmbedAttachment )) \"\"\"The thumbnail of the embed\"\"\" image : Optional [ EmbedAttachment ] = field ( default = None , converter = c_optional ( EmbedAttachment )) \"\"\"The image of the embed\"\"\" video : Optional [ EmbedAttachment ] = field ( default = None , converter = c_optional ( EmbedAttachment ), metadata = no_export_meta ) \"\"\"The video of the embed, only used by system embeds\"\"\" footer : Optional [ EmbedFooter ] = field ( default = None , converter = c_optional ( EmbedFooter )) \"\"\"The footer of the embed\"\"\" provider : Optional [ EmbedProvider ] = field ( default = None , converter = c_optional ( EmbedProvider ), metadata = no_export_meta ) \"\"\"The provider of the embed, only used for system embeds\"\"\" @title . validator def _name_validation ( self , attribute : str , value : Any ) -> None : \"\"\"Validate the embed title.\"\"\" if value is not None : if isinstance ( value , str ): if len ( value ) > EMBED_MAX_NAME_LENGTH : raise ValueError ( f \"Title cannot exceed { EMBED_MAX_NAME_LENGTH } characters\" ) return raise TypeError ( \"Title must be of type String\" ) @description . validator def _description_validation ( self , attribute : str , value : Any ) -> None : \"\"\"Validate the description.\"\"\" if value is not None : if isinstance ( value , str ): if len ( value ) > EMBED_MAX_DESC_LENGTH : raise ValueError ( f \"Description cannot exceed { EMBED_MAX_DESC_LENGTH } characters\" ) return raise TypeError ( \"Description must be of type String\" ) @fields . validator def _fields_validation ( self , attribute : str , value : Any ) -> None : \"\"\"Validate the fields.\"\"\" if isinstance ( value , list ): if len ( value ) > EMBED_MAX_FIELDS : raise ValueError ( f \"Embeds can only hold { EMBED_MAX_FIELDS } fields\" ) def _check_object ( self ): self . _name_validation ( \"title\" , self . title ) self . _description_validation ( \"description\" , self . description ) self . _fields_validation ( \"fields\" , self . fields ) if len ( self ) > EMBED_TOTAL_MAX : raise ValueError ( \"Your embed is too large, more info at https://discord.com/developers/docs/resources/channel#embed-limits\" ) def to_dict ( self ) -> Dict [ str , Any ]: data = super () . to_dict () if color := data . get ( \"color\" ): if isinstance ( color , dict ): color = color [ \"value\" ] elif not isinstance ( color , int ): color = Color ( color ) . value data [ \"color\" ] = color return data def __len__ ( self ): # yes i know there are far more optimal ways to write this # its written like this for readability total = 0 total += len ( self . title ) if self . title else 0 total += len ( self . description ) if self . description else 0 total += len ( self . footer ) if self . footer else 0 total += len ( self . author ) if self . author else 0 for _field in self . fields : total += len ( _field ) return total def set_author ( self , name : str , url : Optional [ str ] = None , icon_url : Optional [ str ] = None , ) -> None : \"\"\" Set the author field of the embed. Args: name: The text to go in the title section url: A url link to the author icon_url: A url of an image to use as the icon \"\"\" self . author = EmbedAuthor ( name = name , url = url , icon_url = icon_url ) def set_thumbnail ( self , url : str ) -> None : \"\"\" Set the thumbnail of the embed. Args: url: the url of the image to use \"\"\" self . thumbnail = EmbedAttachment ( url = url ) def set_image ( self , url : str ) -> None : \"\"\" Set the image of the embed. Args: url: the url of the image to use \"\"\" self . image = EmbedAttachment ( url = url ) def set_footer ( self , text : str , icon_url : Optional [ str ] = None ) -> None : \"\"\" Set the footer field of the embed. Args: text: The text to go in the title section icon_url: A url of an image to use as the icon \"\"\" self . footer = EmbedFooter ( text = text , icon_url = icon_url ) def add_field ( self , name : str , value : str , inline : bool = False ) -> None : \"\"\" Add a field to the embed. Args: name: The title of this field value: The value in this field inline: Should this field be inline with other fields? \"\"\" self . fields . append ( EmbedField ( name , value , inline )) self . _fields_validation ( \"fields\" , self . fields ) attrs-field author : Optional [ dis_snek . models . discord_objects . embed . EmbedAuthor ] \u00b6 The author of the embed attrs-field color : Union [ str , int , dis_snek . models . color . Color ] \u00b6 The colour of the embed attrs-field description : Optional [ str ] \u00b6 The description of the embed attrs-field fields : List [ dis_snek . models . discord_objects . embed . EmbedField ] \u00b6 A list of fields to go in the embed attrs-field footer : Optional [ dis_snek . models . discord_objects . embed . EmbedFooter ] \u00b6 The footer of the embed attrs-field image : Optional [ dis_snek . models . discord_objects . embed . EmbedAttachment ] \u00b6 The image of the embed attrs-field provider : Optional [ dis_snek . models . discord_objects . embed . EmbedProvider ] \u00b6 The provider of the embed, only used for system embeds attrs-field thumbnail : Optional [ dis_snek . models . discord_objects . embed . EmbedAttachment ] \u00b6 The thumbnail of the embed attrs-field timestamp : Optional [ dis_snek . models . timestamp . Timestamp ] \u00b6 Timestamp of embed content attrs-field title : Optional [ str ] \u00b6 The title of the embed attrs-field url : Optional [ str ] \u00b6 The url the embed should direct to when clicked attrs-field video : Optional [ dis_snek . models . discord_objects . embed . EmbedAttachment ] \u00b6 The video of the embed, only used by system embeds inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/embed.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/embed.py def to_dict ( self ) -> Dict [ str , Any ]: data = super () . to_dict () if color := data . get ( \"color\" ): if isinstance ( color , dict ): color = color [ \"value\" ] elif not isinstance ( color , int ): color = Color ( color ) . value data [ \"color\" ] = color return data set_author ( self , name , url = None , icon_url = None ) \u00b6 Set the author field of the embed. Parameters: Name Type Description Default name str The text to go in the title section required url Optional[str] A url link to the author None icon_url Optional[str] A url of an image to use as the icon None Source code in dis_snek/models/discord_objects/embed.py def set_author ( self , name : str , url : Optional [ str ] = None , icon_url : Optional [ str ] = None , ) -> None : \"\"\" Set the author field of the embed. Args: name: The text to go in the title section url: A url link to the author icon_url: A url of an image to use as the icon \"\"\" self . author = EmbedAuthor ( name = name , url = url , icon_url = icon_url ) set_thumbnail ( self , url ) \u00b6 Set the thumbnail of the embed. Parameters: Name Type Description Default url str the url of the image to use required Source code in dis_snek/models/discord_objects/embed.py def set_thumbnail ( self , url : str ) -> None : \"\"\" Set the thumbnail of the embed. Args: url: the url of the image to use \"\"\" self . thumbnail = EmbedAttachment ( url = url ) set_image ( self , url ) \u00b6 Set the image of the embed. Parameters: Name Type Description Default url str the url of the image to use required Source code in dis_snek/models/discord_objects/embed.py def set_image ( self , url : str ) -> None : \"\"\" Set the image of the embed. Args: url: the url of the image to use \"\"\" self . image = EmbedAttachment ( url = url ) set_footer ( self , text , icon_url = None ) \u00b6 Set the footer field of the embed. Parameters: Name Type Description Default text str The text to go in the title section required icon_url Optional[str] A url of an image to use as the icon None Source code in dis_snek/models/discord_objects/embed.py def set_footer ( self , text : str , icon_url : Optional [ str ] = None ) -> None : \"\"\" Set the footer field of the embed. Args: text: The text to go in the title section icon_url: A url of an image to use as the icon \"\"\" self . footer = EmbedFooter ( text = text , icon_url = icon_url ) add_field ( self , name , value , inline = False ) \u00b6 Add a field to the embed. Parameters: Name Type Description Default name str The title of this field required value str The value in this field required inline bool Should this field be inline with other fields? False Source code in dis_snek/models/discord_objects/embed.py def add_field ( self , name : str , value : str , inline : bool = False ) -> None : \"\"\" Add a field to the embed. Args: name: The title of this field value: The value in this field inline: Should this field be inline with other fields? \"\"\" self . fields . append ( EmbedField ( name , value , inline )) self . _fields_validation ( \"fields\" , self . fields ) process_embeds ( embeds ) \u00b6 Process the passed embeds into a format discord will understand. Parameters: Name Type Description Default embeds Union[List[Union[dis_snek.models.discord_objects.embed.Embed, Dict]], dis_snek.models.discord_objects.embed.Embed, Dict] List of dict / embeds to process required Source code in dis_snek/models/discord_objects/embed.py def process_embeds ( embeds : Optional [ Union [ List [ Union [ Embed , Dict ]], Union [ Embed , Dict ]]]) -> Optional [ List [ dict ]]: \"\"\" Process the passed embeds into a format discord will understand. Args: embeds: List of dict / embeds to process \"\"\" if not embeds : # Its just empty, so nothing to process. return embeds if isinstance ( embeds , Embed ): # Single embed, convert it to dict and wrap it into a list for discord. return [ embeds . to_dict ()] if isinstance ( embeds , dict ): # We assume the dict correctly represents a single discord embed and just send it blindly # after wrapping it in a list for discord return [ embeds ] if isinstance ( embeds , list ): # A list of embeds, convert Embed to dict representation if needed. return [ embed . to_dict () if isinstance ( embed , Embed ) else embed for embed in embeds ] raise ValueError ( f \"Invalid embeds: { embeds } \" ) Emoji ( SnowflakeObject , DictSerializationMixin ) attrs \u00b6 Represent a basic emoji used in discord. Source code in dis_snek/models/discord_objects/emoji.py @define () class Emoji ( SnowflakeObject , DictSerializationMixin ): \"\"\"Represent a basic emoji used in discord.\"\"\" id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake ) ) # can be None for Standard Emoji \"\"\"The custom emoji id. Leave empty if you are using standard unicode emoji.\"\"\" name : Optional [ str ] = attr . ib ( default = None ) \"\"\"The custom emoji name, or standard unicode emoji in string\"\"\" animated : bool = attr . ib ( default = False ) \"\"\"Whether this emoji is animated\"\"\" @classmethod def unicode ( cls , emoji : str ): return cls ( name = emoji ) def __str__ ( self ) -> str : return f \"< { 'a:' if self . animated else '' }{ self . name } : { self . id } >\" # <:thinksmart:623335224318754826> def __eq__ ( self , other ): if self . id : return self . id == other . id return self . name == other . name @property def req_format ( self ) -> str : \"\"\" Format used for web request. \"\"\" if self . id : return f \" { self . name } : { self . id } \" else : return self . name attrs-field kw_only animated : bool \u00b6 Whether this emoji is animated attrs-field kw_only id : Optional [ Snowflake_Type ] \u00b6 The custom emoji id. Leave empty if you are using standard unicode emoji. attrs-field kw_only name : Optional [ str ] \u00b6 The custom emoji name, or standard unicode emoji in string property readonly req_format : str \u00b6 Format used for web request. inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/emoji.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/emoji.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) CustomEmoji ( Emoji ) attrs \u00b6 Represent a custom emoji in a guild with all its properties. Source code in dis_snek/models/discord_objects/emoji.py @define () class CustomEmoji ( Emoji ): \"\"\"Represent a custom emoji in a guild with all its properties.\"\"\" _client : \"Snake\" = field ( metadata = no_export_meta ) require_colons : bool = attr . ib ( default = False ) \"\"\"Whether this emoji must be wrapped in colons\"\"\" managed : bool = attr . ib ( default = False ) \"\"\"Whether this emoji is managed\"\"\" available : bool = attr . ib ( default = False ) \"\"\"Whether this emoji can be used, may be false due to loss of Server Boosts.\"\"\" _creator_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) _role_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list , converter = optional ( list_converter ( to_snowflake ))) _guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: creator_dict = data . pop ( \"user\" , None ) data [ \"creator_id\" ] = client . cache . place_user_data ( creator_dict ) . id if creator_dict else None if \"roles\" in data : data [ \"role_ids\" ] = data . pop ( \"roles\" ) return data @classmethod def from_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> \"CustomEmoji\" : data = cls . _process_dict ( data , client ) return cls ( client = client , ** cls . _filter_kwargs ( data , cls . _get_init_keys ())) @property def is_usable ( self ) -> bool : \"\"\" Determines if this emoji is usable by the current user. \"\"\" if not self . available : return False # todo: check roles return True async def get_creator ( self ) -> \"User\" : \"\"\" Get the user who created this emoji Returns: User object \"\"\" return await self . _client . cache . get_user ( self . _creator_id ) async def get_roles ( self ) -> List [ \"Role\" ]: \"\"\" Gets the roles allowed to use this emoji Returns: List of roles \"\"\" return [ await self . _client . cache . get_role ( self . _guild_id , r_id ) for r_id in self . _role_ids ] async def get_guild ( self ) -> \"Guild\" : \"\"\" Get the guild associated with this emoji Returns: Guild object \"\"\" return await self . _client . cache . get_guild ( self . _guild_id ) async def edit ( self , name : Optional [ str ] = None , roles : Optional [ List [ Union [ \"Snowflake_Type\" , \"Role\" ]]] = None , reason : Optional [ str ] = None , ) -> \"CustomEmoji\" : \"\"\" Modify the custom emoji information. Args: name: The name of the emoji. roles: The roles allowed to use this emoji. reason: Attach a reason to this action, used for audit logs. Returns: The newly modified custom emoji. \"\"\" data_payload = dict_filter_none ( dict ( name = name , roles = roles , ) ) updated_data = await self . _client . http . modify_guild_emoji ( data_payload , self . _guild_id , self . id , reason = reason ) self . update_from_dict ( updated_data ) return self async def delete ( self , reason : Optional [ str ] = None ) -> None : \"\"\" Deletes the custom emoji from the guild. Args: reason: Attach a reason to this action, used for audit logs. \"\"\" if not self . _guild_id : raise ValueError ( \"Cannot delete emoji, no guild id set.\" ) await self . _client . http . delete_guild_emoji ( self . _guild_id , self . id , reason = reason ) attrs-field kw_only available : bool \u00b6 Whether this emoji can be used, may be false due to loss of Server Boosts. attrs-field kw_only managed : bool \u00b6 Whether this emoji is managed attrs-field kw_only require_colons : bool \u00b6 Whether this emoji must be wrapped in colons inherited property readonly req_format : str \u00b6 Format used for web request. inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/emoji.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/emoji.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) classmethod from_dict ( data , client ) \u00b6 Process and converts dictionary data received from discord api to object class instance. Parameters: Name Type Description Default data Dict[str, Any] The json data received from discord api. required Source code in dis_snek/models/discord_objects/emoji.py @classmethod def from_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> \"CustomEmoji\" : data = cls . _process_dict ( data , client ) return cls ( client = client , ** cls . _filter_kwargs ( data , cls . _get_init_keys ())) property readonly is_usable : bool \u00b6 Determines if this emoji is usable by the current user. async get_creator ( self ) \u00b6 Get the user who created this emoji Returns: Type Description User User object Source code in dis_snek/models/discord_objects/emoji.py async def get_creator ( self ) -> \"User\" : \"\"\" Get the user who created this emoji Returns: User object \"\"\" return await self . _client . cache . get_user ( self . _creator_id ) async get_roles ( self ) \u00b6 Gets the roles allowed to use this emoji Returns: Type Description List[Role] List of roles Source code in dis_snek/models/discord_objects/emoji.py async def get_roles ( self ) -> List [ \"Role\" ]: \"\"\" Gets the roles allowed to use this emoji Returns: List of roles \"\"\" return [ await self . _client . cache . get_role ( self . _guild_id , r_id ) for r_id in self . _role_ids ] async get_guild ( self ) \u00b6 Get the guild associated with this emoji Returns: Type Description Guild Guild object Source code in dis_snek/models/discord_objects/emoji.py async def get_guild ( self ) -> \"Guild\" : \"\"\" Get the guild associated with this emoji Returns: Guild object \"\"\" return await self . _client . cache . get_guild ( self . _guild_id ) async edit ( self , name = None , roles = None , reason = None ) \u00b6 Modify the custom emoji information. Parameters: Name Type Description Default name Optional[str] The name of the emoji. None roles Optional[List[Union[Snowflake_Type, Role]]] The roles allowed to use this emoji. None reason Optional[str] Attach a reason to this action, used for audit logs. None Returns: Type Description CustomEmoji The newly modified custom emoji. Source code in dis_snek/models/discord_objects/emoji.py async def edit ( self , name : Optional [ str ] = None , roles : Optional [ List [ Union [ \"Snowflake_Type\" , \"Role\" ]]] = None , reason : Optional [ str ] = None , ) -> \"CustomEmoji\" : \"\"\" Modify the custom emoji information. Args: name: The name of the emoji. roles: The roles allowed to use this emoji. reason: Attach a reason to this action, used for audit logs. Returns: The newly modified custom emoji. \"\"\" data_payload = dict_filter_none ( dict ( name = name , roles = roles , ) ) updated_data = await self . _client . http . modify_guild_emoji ( data_payload , self . _guild_id , self . id , reason = reason ) self . update_from_dict ( updated_data ) return self async delete ( self , reason = None ) \u00b6 Deletes the custom emoji from the guild. Parameters: Name Type Description Default reason Optional[str] Attach a reason to this action, used for audit logs. None Source code in dis_snek/models/discord_objects/emoji.py async def delete ( self , reason : Optional [ str ] = None ) -> None : \"\"\" Deletes the custom emoji from the guild. Args: reason: Attach a reason to this action, used for audit logs. \"\"\" if not self . _guild_id : raise ValueError ( \"Cannot delete emoji, no guild id set.\" ) await self . _client . http . delete_guild_emoji ( self . _guild_id , self . id , reason = reason ) Guild ( DiscordObject ) attrs \u00b6 Guilds in Discord represent an isolated collection of users and channels, and are often referred to as \"servers\" in the UI. Source code in dis_snek/models/discord_objects/guild.py @define () class Guild ( DiscordObject ): \"\"\"Guilds in Discord represent an isolated collection of users and channels, and are often referred to as \"servers\" in the UI.\"\"\" unavailable : bool = attr . ib ( default = False ) \"\"\"True if this guild is unavailable due to an outage.\"\"\" name : str = attr . ib () \"\"\"Name of guild. (2-100 characters, excluding trailing and leading whitespace)\"\"\" splash : Optional [ str ] = attr . ib ( default = None ) \"\"\"Hash for splash image.\"\"\" discovery_splash : Optional [ str ] = attr . ib ( default = None ) \"\"\"Hash for discovery splash image. Only present for guilds with the \"DISCOVERABLE\" feature.\"\"\" # owner: bool = attr.ib(default=False) # we get this from api but it's kinda useless to store permissions : Optional [ Permissions ] = attr . ib ( default = None , converter = optional ( Permissions )) \"\"\"Total permissions for the user in the guild. (excludes overwrites)\"\"\" afk_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The channel id for afk.\"\"\" afk_timeout : Optional [ int ] = attr . ib ( default = None ) \"\"\"afk timeout in seconds.\"\"\" widget_enabled : bool = attr . ib ( default = False ) \"\"\"True if the server widget is enabled.\"\"\" widget_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The channel id that the widget will generate an invite to, or None if set to no invite.\"\"\" verification_level : Union [ VerificationLevels , int ] = attr . ib ( default = VerificationLevels . NONE ) \"\"\"The verification level required for the guild.\"\"\" default_message_notifications : Union [ DefaultNotificationLevels , int ] = attr . ib ( default = DefaultNotificationLevels . ALL_MESSAGES ) \"\"\"The default message notifications level.\"\"\" explicit_content_filter : Union [ ExplicitContentFilterLevels , int ] = attr . ib ( default = ExplicitContentFilterLevels . DISABLED ) \"\"\"The explicit content filter level.\"\"\" mfa_level : Union [ MFALevels , int ] = attr . ib ( default = MFALevels . NONE ) \"\"\"The required MFA (Multi Factor Authentication) level for the guild.\"\"\" system_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The id of the channel where guild notices such as welcome messages and boost events are posted.\"\"\" system_channel_flags : Union [ SystemChannelFlags , int ] = attr . ib ( default = SystemChannelFlags . NONE ) \"\"\"The system channel flags.\"\"\" rules_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The id of the channel where Community guilds can display rules and/or guidelines.\"\"\" joined_at : str = attr . ib ( default = None , converter = optional ( timestamp_converter )) \"\"\"When this guild was joined at.\"\"\" large : bool = attr . ib ( default = False ) \"\"\"True if this is considered a large guild.\"\"\" member_count : int = attr . ib ( default = 0 ) \"\"\"The total number of members in this guild.\"\"\" voice_states : List [ dict ] = attr . ib ( factory = list ) \"\"\"The states of members currently in voice channels. Lacks the guild_id key.\"\"\" presences : List [ dict ] = attr . ib ( factory = list ) \"\"\"The presences of the members in the guild, will only include non-offline members if the size is greater than large threshold.\"\"\" max_presences : Optional [ int ] = attr . ib ( default = None ) \"\"\"The maximum number of presences for the guild. (None is always returned, apart from the largest of guilds)\"\"\" max_members : Optional [ int ] = attr . ib ( default = None ) \"\"\"The maximum number of members for the guild.\"\"\" vanity_url_code : Optional [ str ] = attr . ib ( default = None ) \"\"\"The vanity url code for the guild.\"\"\" description : Optional [ str ] = attr . ib ( default = None ) \"\"\"The description of a Community guild.\"\"\" banner : Optional [ str ] = attr . ib ( default = None ) \"\"\"Hash for banner image.\"\"\" premium_tier : Optional [ str ] = attr . ib ( default = None ) \"\"\"The premium tier level. (Server Boost level)\"\"\" premium_subscription_count : int = attr . ib ( default = 0 ) \"\"\"The number of boosts this guild currently has.\"\"\" preferred_locale : str = attr . ib () \"\"\"The preferred locale of a Community guild. Used in server discovery and notices from Discord. Defaults to \\\"en-US\\\"\"\" \" public_updates_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The id of the channel where admins and moderators of Community guilds receive notices from Discord.\"\"\" max_video_channel_users : int = attr . ib ( default = 0 ) \"\"\"The maximum amount of users in a video channel.\"\"\" welcome_screen : Optional [ dict ] = attr . ib ( factory = list ) # TODO welcome screen object. \"\"\"The welcome screen of a Community guild, shown to new members, returned in an Invite's guild object.\"\"\" nsfw_level : Union [ NSFWLevels , int ] = attr . ib ( default = NSFWLevels . DEFAULT ) \"\"\"The guild NSFW level.\"\"\" stage_instances : List [ dict ] = attr . ib ( factory = list ) # TODO stage instance objects \"\"\"Stage instances in the guild.\"\"\" _owner_id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) _channel_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _thread_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _member_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _role_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _features : List [ str ] = attr . ib ( factory = list ) _icon : Optional [ str ] = attr . ib ( default = None ) # todo merge, convert to asset _icon_hash : Optional [ str ] = attr . ib ( default = None ) # TODO Not storing these for now, get accurate data from api when needed instead. # _emojis: List[dict] = attr.ib(factory=list) # _stickers: List[Sticker] = attr.ib(factory=list) @classmethod def _process_dict ( cls , data , client ): guild_id = data [ \"id\" ] channels_data = data . pop ( \"channels\" , []) for c in channels_data : c [ \"guild_id\" ] = guild_id data [ \"channel_ids\" ] = [ client . cache . place_channel_data ( channel_data ) . id for channel_data in channels_data ] threads_data = data . pop ( \"threads\" , []) data [ \"thread_ids\" ] = [ client . cache . place_channel_data ( thread_data ) . id for thread_data in threads_data ] members_data = data . pop ( \"members\" , []) data [ \"member_ids\" ] = [ client . cache . place_member_data ( guild_id , member_data ) . id for member_data in members_data ] roles_data = data . pop ( \"roles\" , []) data [ \"role_ids\" ] = list ( client . cache . place_role_data ( guild_id , roles_data ) . keys ()) return data @property def channels ( self ) -> List [ \"TYPE_GUILD_CHANNEL\" ]: \"\"\"Returns a list of channels associated with this guild.\"\"\" return [ self . _client . cache . channel_cache . get ( c_id ) for c_id in self . _channel_ids ] @property def threads ( self ) -> List [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\"Returns a list of threads associated with this guild.\"\"\" return [ self . _client . cache . channel_cache . get ( t_id ) for t_id in self . _thread_ids ] @property def members ( self ) -> List [ \"Member\" ]: \"\"\"A generator that yields all members of this guild.\"\"\" return [ self . _client . cache . member_cache . get (( self . id , m_id )) for m_id in self . _member_ids ] @property def roles ( self ) -> List [ \"Role\" ]: \"\"\"Returns a list of roles associated with this guild\"\"\" return [ self . _client . cache . role_cache . get ( r_id ) for r_id in self . _role_ids ] @property def me ( self ) -> \"Member\" : \"\"\"Returns this bots member object within this guild.\"\"\" return self . _client . cache . member_cache . get (( self . id , self . _client . user . id )) @property def system_channel ( self ) -> Optional [ \"GuildText\" ]: \"\"\"Returns the channel this guild uses for system messages.\"\"\" return self . _client . cache . channel_cache . get ( self . system_channel_id ) @property def rules_channel ( self ) -> Optional [ \"GuildText\" ]: \"\"\"Returns the channel declared as a rules channel\"\"\" return self . _client . cache . channel_cache . get ( self . rules_channel_id ) @property def public_updates_channel ( self ) -> Optional [ \"GuildText\" ]: \"\"\"Returns the channel where server staff receive notices from Discord\"\"\" return self . _client . cache . channel_cache . get ( self . public_updates_channel_id ) @property def emoji_limit ( self ) -> int : \"\"\"The maximum number of emoji this guild can have\"\"\" base = 200 if \"MORE_EMOJI\" in self . _features else 50 return max ( base , PREMIUM_GUILD_LIMITS [ self . premium_tier ][ \"emoji\" ]) @property def sticker_limit ( self ) -> int : \"\"\"The maximum number of stickers this guild can have\"\"\" base = 60 if \"MORE_sTICKERS\" in self . _features else 0 return max ( base , PREMIUM_GUILD_LIMITS [ self . premium_tier ][ \"stickers\" ]) @property def bitrate_limit ( self ) -> int : \"\"\"The maximum bitrate for this guild\"\"\" base = 128000 if \"VIP_REGIONS\" in self . _features else 96000 return max ( base , PREMIUM_GUILD_LIMITS [ self . premium_tier ][ \"bitrate\" ]) @property def filesize_limit ( self ) -> int : \"\"\"The maximum filesize that may be uploaded within this guild\"\"\" return PREMIUM_GUILD_LIMITS [ self . premium_tier ][ \"filesize\" ] @property def default_role ( self ) -> \"Role\" : \"\"\"The `@everyone` role in this guild\"\"\" return self . _client . cache . role_cache . get ( self . id ) # type: ignore @property def premium_subscriber_role ( self ) -> Optional [ \"Role\" ]: \"\"\"The role given to boosters of this server, if set\"\"\" for role in self . roles : if role . premium_subscriber : return role return None @property def my_role ( self ) -> Optional [ \"Role\" ]: \"\"\"The role associated with this client, if set\"\"\" m_r_id = self . _client . user . id for role in self . roles : if role . _bot_id == m_r_id : return role return None async def get_owner ( self ) -> \"Member\" : # maybe precache owner instead of using `get_owner` return await self . _client . cache . get_member ( self . id , self . _owner_id ) def is_owner ( self , member : \"Member\" ) -> bool : return self . _owner_id == member . id async def edit ( self , name : Optional [ str ] = MISSING , description : Optional [ str ] = MISSING , verification_level : Optional [ \"VerificationLevels\" ] = MISSING , default_message_notifications : Optional [ \"DefaultNotificationLevels\" ] = MISSING , explicit_content_filter : Optional [ \"ExplicitContentFilterLevels\" ] = MISSING , afk_channel : Optional [ Union [ \"GuildVoice\" , \"Snowflake_Type\" ]] = MISSING , afk_timeout : Optional [ int ] = MISSING , system_channel : Optional [ Union [ \"GuildText\" , \"Snowflake_Type\" ]] = MISSING , system_channel_flags : Optional [ SystemChannelFlags ] = MISSING , # ToDo: these are not tested. Mostly, since I do not have access to those features owner : Optional [ Union [ \"Member\" , \"Snowflake_Type\" ]] = MISSING , icon : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , splash : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , discovery_splash : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , banner : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , rules_channel : Optional [ Union [ \"GuildText\" , \"Snowflake_Type\" ]] = MISSING , public_updates_channel : Optional [ Union [ \"GuildText\" , \"Snowflake_Type\" ]] = MISSING , preferred_locale : Optional [ str ] = MISSING , # ToDo: validate voice region region : Optional [ str ] = MISSING , # ToDo: Fill in guild features. No idea how this works - https://discord.com/developers/docs/resources/guild#guild-object-guild-features features : Optional [ list [ str ]] = MISSING , reason : Optional [ str ] = MISSING , ): \"\"\" Edit the guild. Parameters: name: The new name of the guild. description: The new description of the guild. region: ToDo verification_level: The new verification level for the guild. default_message_notifications: The new notification level for the guild. explicit_content_filter: The new explicit content filter level for the guild. afk_channel: The voice channel that should be the new AFK channel. afk_timeout: How many seconds does a member need to be afk before they get moved to the AFK channel. Must be either `60`, `300`, `900`, `1800` or `3600`, otherwise HTTPException will be raised. icon: The new icon. Requires a bytes like object or a path to an image. owner: The new owner of the guild. You, the bot, need to be owner for this to work. splash: The new invite splash image. Requires a bytes like object or a path to an image. discovery_splash: The new discovery image. Requires a bytes like object or a path to an image. banner: The new banner image. Requires a bytes like object or a path to an image. system_channel: The text channel where new system messages should appear. This includes boosts and welcome messages. system_channel_flags: The new settings for the system channel. rules_channel: The text channel where your rules and community guidelines are displayed. public_updates_channel: The text channel where updates from discord should appear. preferred_locale: The new preferred locale of the guild. Must be an ISO 639 code. features: ToDo reason: An optional reason for the audit log. \"\"\" await self . _client . http . modify_guild ( guild_id = self . id , name = name , description = description , region = region , verification_level = int ( verification_level ) if verification_level else MISSING , default_message_notifications = int ( default_message_notifications ) if default_message_notifications else MISSING , explicit_content_filter = int ( explicit_content_filter ) if explicit_content_filter else MISSING , afk_channel_id = to_snowflake ( afk_channel ) if afk_channel else MISSING , afk_timeout = afk_timeout , icon = to_image_data ( icon ) if icon else MISSING , owner_id = to_snowflake ( owner ) if owner else MISSING , splash = to_image_data ( splash ) if splash else MISSING , discovery_splash = to_image_data ( discovery_splash ) if discovery_splash else MISSING , banner = to_image_data ( banner ) if banner else MISSING , system_channel_id = to_snowflake ( system_channel ) if system_channel else MISSING , system_channel_flags = int ( system_channel_flags ) if system_channel_flags else MISSING , rules_channel_id = to_snowflake ( rules_channel ) if rules_channel else MISSING , public_updates_channel_id = to_snowflake ( public_updates_channel ) if public_updates_channel else MISSING , preferred_locale = preferred_locale , features = features , reason = reason , ) async def create_custom_emoji ( self , name : str , imagefile : Union [ str , \"Path\" , \"IOBase\" ], roles : Optional [ List [ Union [ \"Snowflake_Type\" , \"Role\" ]]] = None , reason : Optional [ str ] = MISSING , ) -> \"CustomEmoji\" : \"\"\" Create a new custom emoji for the guild. parameters: name: Name of the emoji imagefile: The emoji image. (Supports PNG, JPEG, WebP, GIF) roles: Roles allowed to use this emoji. reason: An optional reason for the audit log. returns: The new custom emoji created. \"\"\" data_payload = dict_filter_none ( dict ( name = name , image = to_image_data ( imagefile ), roles = roles , ) ) emoji_data = await self . _client . http . create_guild_emoji ( data_payload , self . id , reason = reason ) emoji_data [ \"guild_id\" ] = self . id return CustomEmoji . from_dict ( emoji_data , self . _client ) # TODO Probably cache it async def create_guild_template ( self , name : str , description : str = None ) -> \"GuildTemplate\" : template = await self . _client . http . create_guild_template ( self . id , name , description ) return GuildTemplate . from_dict ( template , self . _client ) async def get_guild_templates ( self ): templates = await self . _client . http . get_guild_templates ( self . id ) return [ GuildTemplate . from_dict ( t , self . _client ) for t in templates ] async def get_all_custom_emojis ( self ) -> List [ CustomEmoji ]: \"\"\" Gets all the custom emoji present for this guild. returns: A list of custom emoji objects. \"\"\" emojis_data = await self . _client . http . get_all_guild_emoji ( self . id ) return [ CustomEmoji . from_dict ( emoji_data , self . _client ) for emoji_data in emojis_data ] async def get_custom_emoji ( self , emoji_id : \"Snowflake_Type\" ) -> CustomEmoji : \"\"\" Gets the custom emoji present for this guild, based on the emoji id. parameters: emoji_id: The target emoji to get data of. returns: The custom emoji object. \"\"\" emoji_data = await self . _client . http . get_guild_emoji ( self . id , emoji_id ) return CustomEmoji . from_dict ( emoji_data , self . _client ) async def create_channel ( self , channel_type : Union [ ChannelTypes , int ], name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = None , nsfw : bool = False , bitrate : int = 64000 , user_limit : int = 0 , slowmode_delay : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"TYPE_GUILD_CHANNEL\" : \"\"\" Create a guild channel, allows for explicit channel type setting. parameters: channel_type: The type of channel to create name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within nsfw: Should this channel be marked nsfw bitrate: The bitrate of this channel, only for voice user_limit: The max users that can be in this channel, only for voice slowmode_delay: The time users must wait between sending messages reason: The reason for creating this channel returns: The newly created channel. \"\"\" if category : category = to_snowflake ( category ) channel_data = await self . _client . http . create_guild_channel ( self . id , name , channel_type , topic , position , permission_overwrites , category , nsfw , bitrate , user_limit , slowmode_delay , reason , ) return self . _client . cache . place_channel_data ( channel_data ) async def create_text_channel ( self , name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = None , nsfw : bool = False , slowmode_delay : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"GuildText\" : \"\"\" Create a text channel in this guild. parameters: name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within nsfw: Should this channel be marked nsfw slowmode_delay: The time users must wait between sending messages reason: The reason for creating this channel returns: The newly created text channel. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_TEXT , name = name , topic = topic , position = position , permission_overwrites = permission_overwrites , category = category , nsfw = nsfw , slowmode_delay = slowmode_delay , reason = reason , ) async def create_voice_channel ( self , name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = None , nsfw : bool = False , bitrate : int = 64000 , user_limit : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"GuildVoice\" : \"\"\" Create a guild voice channel. parameters: name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within nsfw: Should this channel be marked nsfw bitrate: The bitrate of this channel, only for voice user_limit: The max users that can be in this channel, only for voice reason: The reason for creating this channel returns: The newly created voice channel. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_VOICE , name = name , topic = topic , position = position , permission_overwrites = permission_overwrites , category = category , nsfw = nsfw , bitrate = bitrate , user_limit = user_limit , reason = reason , ) async def create_stage_channel ( self , name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = MISSING , bitrate : int = 64000 , user_limit : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"GuildStageVoice\" : \"\"\" Create a guild stage channel. parameters: name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within bitrate: The bitrate of this channel, only for voice user_limit: The max users that can be in this channel, only for voice reason: The reason for creating this channel returns: The newly created stage channel. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_STAGE_VOICE , name = name , topic = topic , position = position , permission_overwrites = permission_overwrites , category = category , bitrate = bitrate , user_limit = user_limit , reason = reason , ) async def create_category ( self , name : str , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"GuildCategory\" : \"\"\" Create a category within this guild. parameters: name: The name of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel reason: The reason for creating this channel returns: The newly created category. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_CATEGORY , name = name , position = position , permission_overwrites = permission_overwrites , reason = reason , ) async def delete_channel ( self , channel : Union [ \"TYPE_GUILD_CHANNEL\" , \"Snowflake_Type\" ], reason : str = None ) -> None : \"\"\" Delete the given channel, can handle either a snowflake or channel object This is effectively just an alias for `channel.delete()` Args: channel: The channel to be deleted reason: The reason for this deletion \"\"\" if isinstance ( channel , ( str , int )): channel = await self . _client . get_channel ( channel ) if not channel : raise ValueError ( \"Unable to find requested channel\" ) # TODO self._channel_ids is not updated properly when new guild channels are created so this check is # disabled for now # if channel.id not in self._channel_ids: # raise ValueError(\"This guild does not hold the requested channel\") await channel . delete ( reason ) async def create_custom_sticker ( self , name : str , imagefile : Union [ str , \"Path\" , \"IOBase\" ], description : Optional [ str ] = MISSING , tags : Optional [ str ] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"Sticker\" : \"\"\" Creates a custom sticker for a guild Args: name: Sticker name imagefile: Sticker image file description: Sticker description tags: Sticker tags reason: Reason for creating the sticker Returns: New Sticker instance \"\"\" payload = FormData () payload . add_field ( \"name\" , name ) # TODO Validate image type? if isinstance ( imagefile , IOBase ): payload . add_field ( \"file\" , name ) else : payload . add_field ( \"file\" , open ( str ( imagefile ))) if description : payload . add_field ( \"description\" , description ) if tags : payload . add_field ( \"tags\" , tags ) sticker_data = await self . _client . http . create_guild_sticker ( payload , self . id , reason ) return Sticker . from_dict ( sticker_data , self . _client ) async def get_all_custom_stickers ( self ) -> List [ \"Sticker\" ]: \"\"\" Gets all custom stickers for a guild. Returns: List of Sticker objects \"\"\" stickers_data = await self . _client . http . list_guild_stickers ( self . id ) return Sticker . from_list ( stickers_data , self . _client ) async def get_custom_sticker ( self , sticker_id : \"Snowflake_Type\" ) -> \"Sticker\" : \"\"\" Gets a specific custom sticker for a guild Args: sticker_id: ID of sticker to get Returns: Requested Sticker \"\"\" sticker_data = await self . _client . http . get_guild_sticker ( self . id , to_snowflake ( sticker_id )) return Sticker . from_dict ( sticker_data , self . _client ) async def get_active_threads ( self ) -> \"ThreadList\" : \"\"\" Gets all active threads in the guild, including public and private threads. Threads are ordered by their id, in descending order. returns: List of active threads and thread member object for each returned thread the bot user has joined. \"\"\" threads_data = await self . _client . http . list_active_threads ( self . id ) return ThreadList . from_dict ( threads_data , self . _client ) async def get_role ( self , role_id : \"Snowflake_Type\" ) -> Optional [ \"Role\" ]: \"\"\" Get the specified role by ID. Args: role_id: The ID of the role to get Returns: A role object or None if the role is not found. \"\"\" return await self . _client . cache . get_role ( self . id , role_id ) async def create_role ( self , name : Optional [ str ] = MISSING , permissions : Optional [ Permissions ] = MISSING , colour : Optional [ Union [ Color , int ]] = MISSING , color : Optional [ Union [ Color , int ]] = MISSING , hoist : Optional [ bool ] = False , mentionable : Optional [ bool ] = False , # ToDo: icon needs testing. I have to access to that icon : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"Role\" : \"\"\" Create a new role for the guild. You must have the `manage roles` permission. Args: name: The name the role should have. `Default: new role` permissions: The permissions the role should have. `Default: @everyone permissions` colour: The colour of the role. Can be either `Color` or an RGB integer. `Default: BrandColors.BLACK` color: Alias for `colour` icon: Can be either a bytes like object or a path to an image, or a unicode emoji which is supported by discord. hoist: Whether the role is shown separately in the members list. `Default: False` mentionable: Whether the role can be mentioned. `Default: False` reason: An optional reason for the audit log. Returns: A role object or None if the role is not found. \"\"\" payload = {} if name : payload . update ({ \"name\" : name }) if permissions : payload . update ({ \"permissions\" : str ( int ( permissions ))}) colour = colour or color if colour : payload . update ({ \"color\" : colour . value }) if hoist : payload . update ({ \"hoist\" : True }) if mentionable : payload . update ({ \"mentionable\" : True }) if icon : # test if the icon is probably a unicode emoji (str and len() == 1) or a path / bytes obj if isinstance ( icon , str ) and len ( icon ) == 1 : payload . update ({ \"unicode_emoji\" : icon }) else : payload . update ({ \"icon\" : to_image_data ( icon )}) result = await self . _client . http . create_guild_role ( guild_id = self . id , payload = payload , reason = reason ) return self . _client . cache . place_role_data ( guild_id = self . id , data = [ result ])[ to_snowflake ( result [ \"id\" ])] async def get_channel ( self , channel_id : \"Snowflake_Type\" ) -> Optional [ Union [ \"TYPE_GUILD_CHANNEL\" , \"TYPE_THREAD_CHANNEL\" ]]: \"\"\" Returns a channel with the given `channel_id` Args: channel_id: The ID of the channel to get Returns: Channel object if found, otherwise None \"\"\" if channel_id in self . _channel_ids and channel_id not in self . _thread_ids : # theoretically, this could get any channel the client can see, # but to make it less confusing to new programmers, # i intentionally check that the guild contains the channel first return await self . _client . cache . get_channel ( channel_id ) return None async def get_thread ( self , thread_id : \"Snowflake_Type\" ) -> Optional [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\" Returns a Thread with the given `thread_id` Args: thread_id: The ID of the thread to get Returns: Channel object if found, otherwise None \"\"\" # get_channel can retrieve threads, so this is basically an alias with extra steps for that if thread_id in self . _thread_ids : return await self . get_channel ( thread_id ) return None async def prune_members ( self , days : int = 7 , roles : List [ Union [ \"Snowflake_Type\" , \"Role\" ]] = MISSING , compute_prune_count : bool = True , reason : str = MISSING , ) -> Optional [ int ]: \"\"\" Begin a guild prune. Removes members from the guild who who have not interacted for the last `days` days. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles` Requires `kick members` permission. Args: days: number of days to prune (1-30) roles: list of roles to include in the prune compute_prune_count: Whether the number of members pruned should be calculated (disable this for large guilds) reason: The reason for this prune Returns: The total number of members pruned, if `compute_prune_count` is set to True, otherwise None \"\"\" if roles is not MISSING : roles = [ r . id if isinstance ( r , Role ) else r for r in roles ] else : roles = [] resp = await self . _client . http . begin_guild_prune ( self . id , days , include_roles = roles , compute_prune_count = compute_prune_count , reason = reason ) return resp [ \"pruned\" ] async def estimate_prune_members ( self , days : int = 7 , roles : List [ Union [ \"Snowflake_Type\" , \"Role\" ]] = MISSING ) -> int : \"\"\" Calculate how many members would be pruned, should `guild.prune_members` be used. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles` Args: days: number of days to prune (1-30) roles: list of roles to include in the prune Returns: Total number of members that would be pruned \"\"\" if roles is not MISSING : roles = [ r . id if isinstance ( r , Role ) else r for r in roles ] else : roles = [] resp = await self . _client . http . get_guild_prune_count ( self . id , days = days , include_roles = roles ) return resp [ \"pruned\" ] async def leave ( self ) -> None : \"\"\"Leave this guild\"\"\" await self . _client . http . leave_guild ( self . id ) async def delete ( self ) -> None : \"\"\"Delete the guild. You must own this guild to do this.\"\"\" await self . _client . http . delete_guild ( self . id ) async def kick ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ], reason : str = MISSING ) -> None : \"\"\" Kick a user from the guild. You must have the `kick members` permission Args: user: The user to kick reason: The reason for the kick \"\"\" await self . _client . http . remove_guild_member ( self . id , to_snowflake ( user ), reason = reason ) async def ban ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ], delete_message_days : int = 0 , reason : str = MISSING ) -> None : \"\"\" Ban a user from the guild. You must have the `ban members` permission Args: user: The user to ban delete_message_days: How many days worth of messages to remove reason: The reason for the ban \"\"\" await self . _client . http . create_guild_ban ( self . id , to_snowflake ( user ), delete_message_days , reason = reason ) async def get_ban ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ]) -> GuildBan : \"\"\" Get's the ban information for the specified user in the guild. You must have the `ban members` permission Args: user: The user to look up. Raises: NotFound: If the user is not banned in the guild. Returns: The ban information. \"\"\" ban_info = await self . _client . http . get_guild_ban ( self . id , to_snowflake ( user )) return GuildBan ( reason = ban_info [ \"reason\" ], user = self . _client . cache . place_user_data ( ban_info [ \"user\" ])) async def get_bans ( self ) -> list [ GuildBan ]: \"\"\" Get's all bans for the guild. You must have the `ban members` permission Returns: A list containing all bans and information about them. \"\"\" ban_infos = await self . _client . http . get_guild_bans ( self . id ) return [ GuildBan ( reason = ban_info [ \"reason\" ], user = self . _client . cache . place_user_data ( ban_info [ \"user\" ])) for ban_info in ban_infos ] async def unban ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ], reason : str = MISSING ) -> None : \"\"\" Unban a user from the guild. You must have the `ban members` permission Args: user: The user to unban reason: The reason for the ban \"\"\" await self . _client . http . remove_guild_ban ( self . id , to_snowflake ( user ), reason = reason ) async def get_widget_image ( self , style : str = None ) -> str : \"\"\" Get a guilds widget image For a list of styles, look here: https://discord.com/developers/docs/resources/guild#get-guild-widget-image-widget-style-options Args: style: The style to use for the widget image \"\"\" return await self . _client . http . get_guild_widget_image ( self . id , style ) async def get_widget ( self ) -> dict : \"\"\" Gets the guilds widget \"\"\" # todo: Guild widget object return await self . _client . http . get_guild_widget ( self . id ) async def modify_widget ( self , enabled : bool = None , channel : Union [ \"TYPE_GUILD_CHANNEL\" , \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Modify the guild's widget. Args: enabled: Should the widget be enabled? channel: The channel to use in the widget \"\"\" if channel : if isinstance ( channel , DiscordObject ): channel = channel . id return await self . _client . http . modify_guild_widget ( self . id , enabled , channel ) async def get_invites ( self ) -> List [ \"Invite\" ]: invites_data = await self . _client . http . get_guild_invites ( self . id ) return Invite . from_list ( invites_data , self . _client ) async def get_guild_integrations ( self ) -> List [ \"GuildIntegration\" ]: data = await self . _client . http . get_guild_integrations ( self . id ) return [ GuildIntegration . from_dict ( d | { \"guild_id\" : self . id }, self . _client ) for d in data ] attrs-field kw_only afk_channel_id : Optional [ Snowflake_Type ] \u00b6 The channel id for afk. attrs-field kw_only afk_timeout : Optional [ int ] \u00b6 afk timeout in seconds. attrs-field kw_only banner : Optional [ str ] \u00b6 Hash for banner image. attrs-field kw_only default_message_notifications : Union [ dis_snek . models . enums . DefaultNotificationLevels , int ] \u00b6 The default message notifications level. attrs-field kw_only description : Optional [ str ] \u00b6 The description of a Community guild. attrs-field kw_only discovery_splash : Optional [ str ] \u00b6 Hash for discovery splash image. Only present for guilds with the \"DISCOVERABLE\" feature. attrs-field kw_only explicit_content_filter : Union [ dis_snek . models . enums . ExplicitContentFilterLevels , int ] \u00b6 The explicit content filter level. attrs-field kw_only joined_at : str \u00b6 When this guild was joined at. attrs-field kw_only large : bool \u00b6 True if this is considered a large guild. attrs-field kw_only max_members : Optional [ int ] \u00b6 The maximum number of members for the guild. attrs-field kw_only max_presences : Optional [ int ] \u00b6 The maximum number of presences for the guild. (None is always returned, apart from the largest of guilds) attrs-field kw_only max_video_channel_users : int \u00b6 The maximum amount of users in a video channel. attrs-field kw_only member_count : int \u00b6 The total number of members in this guild. attrs-field kw_only mfa_level : Union [ dis_snek . models . enums . MFALevels , int ] \u00b6 The required MFA (Multi Factor Authentication) level for the guild. attrs-field kw_only name : str \u00b6 Name of guild. (2-100 characters, excluding trailing and leading whitespace) attrs-field kw_only nsfw_level : Union [ dis_snek . models . enums . NSFWLevels , int ] \u00b6 The guild NSFW level. attrs-field kw_only permissions : Optional [ dis_snek . models . enums . Permissions ] \u00b6 Total permissions for the user in the guild. (excludes overwrites) attrs-field kw_only preferred_locale : str \u00b6 The preferred locale of a Community guild. Used in server discovery and notices from Discord. Defaults to \"en-US\" attrs-field kw_only premium_subscription_count : int \u00b6 The number of boosts this guild currently has. attrs-field kw_only premium_tier : Optional [ str ] \u00b6 The premium tier level. (Server Boost level) attrs-field kw_only presences : List [ dict ] \u00b6 The presences of the members in the guild, will only include non-offline members if the size is greater than large threshold. attrs-field kw_only public_updates_channel_id : Optional [ Snowflake_Type ] \u00b6 The id of the channel where admins and moderators of Community guilds receive notices from Discord. attrs-field kw_only rules_channel_id : Optional [ Snowflake_Type ] \u00b6 The id of the channel where Community guilds can display rules and/or guidelines. attrs-field kw_only splash : Optional [ str ] \u00b6 Hash for splash image. attrs-field kw_only stage_instances : List [ dict ] \u00b6 Stage instances in the guild. attrs-field kw_only system_channel_flags : Union [ dis_snek . models . enums . SystemChannelFlags , int ] \u00b6 The system channel flags. attrs-field kw_only system_channel_id : Optional [ Snowflake_Type ] \u00b6 The id of the channel where guild notices such as welcome messages and boost events are posted. attrs-field kw_only unavailable : bool \u00b6 True if this guild is unavailable due to an outage. attrs-field kw_only vanity_url_code : Optional [ str ] \u00b6 The vanity url code for the guild. attrs-field kw_only verification_level : Union [ dis_snek . models . enums . VerificationLevels , int ] \u00b6 The verification level required for the guild. attrs-field kw_only voice_states : List [ dict ] \u00b6 The states of members currently in voice channels. Lacks the guild_id key. attrs-field kw_only welcome_screen : Optional [ dict ] \u00b6 The welcome screen of a Community guild, shown to new members, returned in an Invite's guild object. attrs-field kw_only widget_channel_id : Optional [ Snowflake_Type ] \u00b6 The channel id that the widget will generate an invite to, or None if set to no invite. attrs-field kw_only widget_enabled : bool \u00b6 True if the server widget is enabled. inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/guild.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/guild.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) property readonly channels : List [ TYPE_GUILD_CHANNEL ] \u00b6 Returns a list of channels associated with this guild. property readonly threads : List [ TYPE_THREAD_CHANNEL ] \u00b6 Returns a list of threads associated with this guild. property readonly members : List [ Member ] \u00b6 A generator that yields all members of this guild. property readonly roles : List [ Role ] \u00b6 Returns a list of roles associated with this guild property readonly me : Member \u00b6 Returns this bots member object within this guild. property readonly system_channel : Optional [ GuildText ] \u00b6 Returns the channel this guild uses for system messages. property readonly rules_channel : Optional [ GuildText ] \u00b6 Returns the channel declared as a rules channel property readonly public_updates_channel : Optional [ GuildText ] \u00b6 Returns the channel where server staff receive notices from Discord property readonly emoji_limit : int \u00b6 The maximum number of emoji this guild can have property readonly sticker_limit : int \u00b6 The maximum number of stickers this guild can have property readonly bitrate_limit : int \u00b6 The maximum bitrate for this guild property readonly filesize_limit : int \u00b6 The maximum filesize that may be uploaded within this guild property readonly default_role : Role \u00b6 The @everyone role in this guild property readonly premium_subscriber_role : Optional [ Role ] \u00b6 The role given to boosters of this server, if set property readonly my_role : Optional [ Role ] \u00b6 The role associated with this client, if set async edit ( self , name = MISSING , description = MISSING , verification_level = MISSING , default_message_notifications = MISSING , explicit_content_filter = MISSING , afk_channel = MISSING , afk_timeout = MISSING , system_channel = MISSING , system_channel_flags = MISSING , owner = MISSING , icon = MISSING , splash = MISSING , discovery_splash = MISSING , banner = MISSING , rules_channel = MISSING , public_updates_channel = MISSING , preferred_locale = MISSING , region = MISSING , features = MISSING , reason = MISSING ) \u00b6 Edit the guild. Parameters: Name Type Description Default name Optional[str] The new name of the guild. MISSING description Optional[str] The new description of the guild. MISSING region Optional[str] ToDo MISSING verification_level Optional[VerificationLevels] The new verification level for the guild. MISSING default_message_notifications Optional[DefaultNotificationLevels] The new notification level for the guild. MISSING explicit_content_filter Optional[ExplicitContentFilterLevels] The new explicit content filter level for the guild. MISSING afk_channel Union[GuildVoice, Snowflake_Type] The voice channel that should be the new AFK channel. MISSING afk_timeout Optional[int] How many seconds does a member need to be afk before they get moved to the AFK channel. Must be either 60 , 300 , 900 , 1800 or 3600 , otherwise HTTPException will be raised. MISSING icon Union[str, Path, IOBase] The new icon. Requires a bytes like object or a path to an image. MISSING owner Union[Member, Snowflake_Type] The new owner of the guild. You, the bot, need to be owner for this to work. MISSING splash Union[str, Path, IOBase] The new invite splash image. Requires a bytes like object or a path to an image. MISSING discovery_splash Union[str, Path, IOBase] The new discovery image. Requires a bytes like object or a path to an image. MISSING banner Union[str, Path, IOBase] The new banner image. Requires a bytes like object or a path to an image. MISSING system_channel Union[GuildText, Snowflake_Type] The text channel where new system messages should appear. This includes boosts and welcome messages. MISSING system_channel_flags Optional[dis_snek.models.enums.SystemChannelFlags] The new settings for the system channel. MISSING rules_channel Union[GuildText, Snowflake_Type] The text channel where your rules and community guidelines are displayed. MISSING public_updates_channel Union[GuildText, Snowflake_Type] The text channel where updates from discord should appear. MISSING preferred_locale Optional[str] The new preferred locale of the guild. Must be an ISO 639 code. MISSING features Optional[list[str]] ToDo MISSING reason Optional[str] An optional reason for the audit log. MISSING Source code in dis_snek/models/discord_objects/guild.py async def edit ( self , name : Optional [ str ] = MISSING , description : Optional [ str ] = MISSING , verification_level : Optional [ \"VerificationLevels\" ] = MISSING , default_message_notifications : Optional [ \"DefaultNotificationLevels\" ] = MISSING , explicit_content_filter : Optional [ \"ExplicitContentFilterLevels\" ] = MISSING , afk_channel : Optional [ Union [ \"GuildVoice\" , \"Snowflake_Type\" ]] = MISSING , afk_timeout : Optional [ int ] = MISSING , system_channel : Optional [ Union [ \"GuildText\" , \"Snowflake_Type\" ]] = MISSING , system_channel_flags : Optional [ SystemChannelFlags ] = MISSING , # ToDo: these are not tested. Mostly, since I do not have access to those features owner : Optional [ Union [ \"Member\" , \"Snowflake_Type\" ]] = MISSING , icon : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , splash : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , discovery_splash : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , banner : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , rules_channel : Optional [ Union [ \"GuildText\" , \"Snowflake_Type\" ]] = MISSING , public_updates_channel : Optional [ Union [ \"GuildText\" , \"Snowflake_Type\" ]] = MISSING , preferred_locale : Optional [ str ] = MISSING , # ToDo: validate voice region region : Optional [ str ] = MISSING , # ToDo: Fill in guild features. No idea how this works - https://discord.com/developers/docs/resources/guild#guild-object-guild-features features : Optional [ list [ str ]] = MISSING , reason : Optional [ str ] = MISSING , ): \"\"\" Edit the guild. Parameters: name: The new name of the guild. description: The new description of the guild. region: ToDo verification_level: The new verification level for the guild. default_message_notifications: The new notification level for the guild. explicit_content_filter: The new explicit content filter level for the guild. afk_channel: The voice channel that should be the new AFK channel. afk_timeout: How many seconds does a member need to be afk before they get moved to the AFK channel. Must be either `60`, `300`, `900`, `1800` or `3600`, otherwise HTTPException will be raised. icon: The new icon. Requires a bytes like object or a path to an image. owner: The new owner of the guild. You, the bot, need to be owner for this to work. splash: The new invite splash image. Requires a bytes like object or a path to an image. discovery_splash: The new discovery image. Requires a bytes like object or a path to an image. banner: The new banner image. Requires a bytes like object or a path to an image. system_channel: The text channel where new system messages should appear. This includes boosts and welcome messages. system_channel_flags: The new settings for the system channel. rules_channel: The text channel where your rules and community guidelines are displayed. public_updates_channel: The text channel where updates from discord should appear. preferred_locale: The new preferred locale of the guild. Must be an ISO 639 code. features: ToDo reason: An optional reason for the audit log. \"\"\" await self . _client . http . modify_guild ( guild_id = self . id , name = name , description = description , region = region , verification_level = int ( verification_level ) if verification_level else MISSING , default_message_notifications = int ( default_message_notifications ) if default_message_notifications else MISSING , explicit_content_filter = int ( explicit_content_filter ) if explicit_content_filter else MISSING , afk_channel_id = to_snowflake ( afk_channel ) if afk_channel else MISSING , afk_timeout = afk_timeout , icon = to_image_data ( icon ) if icon else MISSING , owner_id = to_snowflake ( owner ) if owner else MISSING , splash = to_image_data ( splash ) if splash else MISSING , discovery_splash = to_image_data ( discovery_splash ) if discovery_splash else MISSING , banner = to_image_data ( banner ) if banner else MISSING , system_channel_id = to_snowflake ( system_channel ) if system_channel else MISSING , system_channel_flags = int ( system_channel_flags ) if system_channel_flags else MISSING , rules_channel_id = to_snowflake ( rules_channel ) if rules_channel else MISSING , public_updates_channel_id = to_snowflake ( public_updates_channel ) if public_updates_channel else MISSING , preferred_locale = preferred_locale , features = features , reason = reason , ) async create_custom_emoji ( self , name , imagefile , roles = None , reason = MISSING ) \u00b6 Create a new custom emoji for the guild. Parameters: Name Type Description Default name str Name of the emoji required imagefile Union[str, Path, IOBase] The emoji image. (Supports PNG, JPEG, WebP, GIF) required roles Optional[List[Union[Snowflake_Type, Role]]] Roles allowed to use this emoji. None reason Optional[str] An optional reason for the audit log. MISSING Returns: Type Description CustomEmoji The new custom emoji created. Source code in dis_snek/models/discord_objects/guild.py async def create_custom_emoji ( self , name : str , imagefile : Union [ str , \"Path\" , \"IOBase\" ], roles : Optional [ List [ Union [ \"Snowflake_Type\" , \"Role\" ]]] = None , reason : Optional [ str ] = MISSING , ) -> \"CustomEmoji\" : \"\"\" Create a new custom emoji for the guild. parameters: name: Name of the emoji imagefile: The emoji image. (Supports PNG, JPEG, WebP, GIF) roles: Roles allowed to use this emoji. reason: An optional reason for the audit log. returns: The new custom emoji created. \"\"\" data_payload = dict_filter_none ( dict ( name = name , image = to_image_data ( imagefile ), roles = roles , ) ) emoji_data = await self . _client . http . create_guild_emoji ( data_payload , self . id , reason = reason ) emoji_data [ \"guild_id\" ] = self . id return CustomEmoji . from_dict ( emoji_data , self . _client ) # TODO Probably cache it async get_all_custom_emojis ( self ) \u00b6 Gets all the custom emoji present for this guild. Returns: Type Description List[dis_snek.models.discord_objects.emoji.CustomEmoji] A list of custom emoji objects. Source code in dis_snek/models/discord_objects/guild.py async def get_all_custom_emojis ( self ) -> List [ CustomEmoji ]: \"\"\" Gets all the custom emoji present for this guild. returns: A list of custom emoji objects. \"\"\" emojis_data = await self . _client . http . get_all_guild_emoji ( self . id ) return [ CustomEmoji . from_dict ( emoji_data , self . _client ) for emoji_data in emojis_data ] async get_custom_emoji ( self , emoji_id ) \u00b6 Gets the custom emoji present for this guild, based on the emoji id. Parameters: Name Type Description Default emoji_id Snowflake_Type The target emoji to get data of. required Returns: Type Description CustomEmoji The custom emoji object. Source code in dis_snek/models/discord_objects/guild.py async def get_custom_emoji ( self , emoji_id : \"Snowflake_Type\" ) -> CustomEmoji : \"\"\" Gets the custom emoji present for this guild, based on the emoji id. parameters: emoji_id: The target emoji to get data of. returns: The custom emoji object. \"\"\" emoji_data = await self . _client . http . get_guild_emoji ( self . id , emoji_id ) return CustomEmoji . from_dict ( emoji_data , self . _client ) async create_channel ( self , channel_type , name , topic = MISSING , position = 0 , permission_overwrites = MISSING , category = None , nsfw = False , bitrate = 64000 , user_limit = 0 , slowmode_delay = 0 , reason = MISSING ) \u00b6 Create a guild channel, allows for explicit channel type setting. Parameters: Name Type Description Default channel_type Union[dis_snek.models.enums.ChannelTypes, int] The type of channel to create required name str The name of the channel required topic Optional[str] The topic of the channel MISSING position int The position of the channel in the channel list 0 permission_overwrites Optional[List[Union[PermissionOverwrite, dict]]] Permission overwrites to apply to the channel MISSING category Union[Snowflake_Type, GuildCategory] The category this channel should be within None nsfw bool Should this channel be marked nsfw False bitrate int The bitrate of this channel, only for voice 64000 user_limit int The max users that can be in this channel, only for voice 0 slowmode_delay int The time users must wait between sending messages 0 reason Optional[str] The reason for creating this channel MISSING Returns: Type Description TYPE_GUILD_CHANNEL The newly created channel. Source code in dis_snek/models/discord_objects/guild.py async def create_channel ( self , channel_type : Union [ ChannelTypes , int ], name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = None , nsfw : bool = False , bitrate : int = 64000 , user_limit : int = 0 , slowmode_delay : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"TYPE_GUILD_CHANNEL\" : \"\"\" Create a guild channel, allows for explicit channel type setting. parameters: channel_type: The type of channel to create name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within nsfw: Should this channel be marked nsfw bitrate: The bitrate of this channel, only for voice user_limit: The max users that can be in this channel, only for voice slowmode_delay: The time users must wait between sending messages reason: The reason for creating this channel returns: The newly created channel. \"\"\" if category : category = to_snowflake ( category ) channel_data = await self . _client . http . create_guild_channel ( self . id , name , channel_type , topic , position , permission_overwrites , category , nsfw , bitrate , user_limit , slowmode_delay , reason , ) return self . _client . cache . place_channel_data ( channel_data ) async create_text_channel ( self , name , topic = MISSING , position = 0 , permission_overwrites = MISSING , category = None , nsfw = False , slowmode_delay = 0 , reason = MISSING ) \u00b6 Create a text channel in this guild. Parameters: Name Type Description Default name str The name of the channel required topic Optional[str] The topic of the channel MISSING position int The position of the channel in the channel list 0 permission_overwrites Optional[List[Union[PermissionOverwrite, dict]]] Permission overwrites to apply to the channel MISSING category Union[Snowflake_Type, GuildCategory] The category this channel should be within None nsfw bool Should this channel be marked nsfw False slowmode_delay int The time users must wait between sending messages 0 reason Optional[str] The reason for creating this channel MISSING Returns: Type Description GuildText The newly created text channel. Source code in dis_snek/models/discord_objects/guild.py async def create_text_channel ( self , name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = None , nsfw : bool = False , slowmode_delay : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"GuildText\" : \"\"\" Create a text channel in this guild. parameters: name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within nsfw: Should this channel be marked nsfw slowmode_delay: The time users must wait between sending messages reason: The reason for creating this channel returns: The newly created text channel. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_TEXT , name = name , topic = topic , position = position , permission_overwrites = permission_overwrites , category = category , nsfw = nsfw , slowmode_delay = slowmode_delay , reason = reason , ) async create_voice_channel ( self , name , topic = MISSING , position = 0 , permission_overwrites = MISSING , category = None , nsfw = False , bitrate = 64000 , user_limit = 0 , reason = MISSING ) \u00b6 Create a guild voice channel. Parameters: Name Type Description Default name str The name of the channel required topic Optional[str] The topic of the channel MISSING position int The position of the channel in the channel list 0 permission_overwrites Optional[List[Union[PermissionOverwrite, dict]]] Permission overwrites to apply to the channel MISSING category Union[Snowflake_Type, GuildCategory] The category this channel should be within None nsfw bool Should this channel be marked nsfw False bitrate int The bitrate of this channel, only for voice 64000 user_limit int The max users that can be in this channel, only for voice 0 reason Optional[str] The reason for creating this channel MISSING Returns: Type Description GuildVoice The newly created voice channel. Source code in dis_snek/models/discord_objects/guild.py async def create_voice_channel ( self , name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = None , nsfw : bool = False , bitrate : int = 64000 , user_limit : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"GuildVoice\" : \"\"\" Create a guild voice channel. parameters: name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within nsfw: Should this channel be marked nsfw bitrate: The bitrate of this channel, only for voice user_limit: The max users that can be in this channel, only for voice reason: The reason for creating this channel returns: The newly created voice channel. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_VOICE , name = name , topic = topic , position = position , permission_overwrites = permission_overwrites , category = category , nsfw = nsfw , bitrate = bitrate , user_limit = user_limit , reason = reason , ) async create_stage_channel ( self , name , topic = MISSING , position = 0 , permission_overwrites = MISSING , category = MISSING , bitrate = 64000 , user_limit = 0 , reason = MISSING ) \u00b6 Create a guild stage channel. Parameters: Name Type Description Default name str The name of the channel required topic Optional[str] The topic of the channel MISSING position int The position of the channel in the channel list 0 permission_overwrites Optional[List[Union[PermissionOverwrite, dict]]] Permission overwrites to apply to the channel MISSING category Union[Snowflake_Type, GuildCategory] The category this channel should be within MISSING bitrate int The bitrate of this channel, only for voice 64000 user_limit int The max users that can be in this channel, only for voice 0 reason Optional[str] The reason for creating this channel MISSING Returns: Type Description GuildStageVoice The newly created stage channel. Source code in dis_snek/models/discord_objects/guild.py async def create_stage_channel ( self , name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = MISSING , bitrate : int = 64000 , user_limit : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"GuildStageVoice\" : \"\"\" Create a guild stage channel. parameters: name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within bitrate: The bitrate of this channel, only for voice user_limit: The max users that can be in this channel, only for voice reason: The reason for creating this channel returns: The newly created stage channel. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_STAGE_VOICE , name = name , topic = topic , position = position , permission_overwrites = permission_overwrites , category = category , bitrate = bitrate , user_limit = user_limit , reason = reason , ) async create_category ( self , name , position = 0 , permission_overwrites = MISSING , reason = MISSING ) \u00b6 Create a category within this guild. Parameters: Name Type Description Default name str The name of the channel required position int The position of the channel in the channel list 0 permission_overwrites Optional[List[Union[PermissionOverwrite, dict]]] Permission overwrites to apply to the channel MISSING reason Optional[str] The reason for creating this channel MISSING Returns: Type Description GuildCategory The newly created category. Source code in dis_snek/models/discord_objects/guild.py async def create_category ( self , name : str , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"GuildCategory\" : \"\"\" Create a category within this guild. parameters: name: The name of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel reason: The reason for creating this channel returns: The newly created category. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_CATEGORY , name = name , position = position , permission_overwrites = permission_overwrites , reason = reason , ) async delete_channel ( self , channel , reason = None ) \u00b6 Delete the given channel, can handle either a snowflake or channel object This is effectively just an alias for channel.delete() Parameters: Name Type Description Default channel Union[TYPE_GUILD_CHANNEL, Snowflake_Type] The channel to be deleted required reason str The reason for this deletion None Source code in dis_snek/models/discord_objects/guild.py async def delete_channel ( self , channel : Union [ \"TYPE_GUILD_CHANNEL\" , \"Snowflake_Type\" ], reason : str = None ) -> None : \"\"\" Delete the given channel, can handle either a snowflake or channel object This is effectively just an alias for `channel.delete()` Args: channel: The channel to be deleted reason: The reason for this deletion \"\"\" if isinstance ( channel , ( str , int )): channel = await self . _client . get_channel ( channel ) if not channel : raise ValueError ( \"Unable to find requested channel\" ) # TODO self._channel_ids is not updated properly when new guild channels are created so this check is # disabled for now # if channel.id not in self._channel_ids: # raise ValueError(\"This guild does not hold the requested channel\") await channel . delete ( reason ) async create_custom_sticker ( self , name , imagefile , description = MISSING , tags = MISSING , reason = MISSING ) \u00b6 Creates a custom sticker for a guild Parameters: Name Type Description Default name str Sticker name required imagefile Union[str, Path, IOBase] Sticker image file required description Optional[str] Sticker description MISSING tags Optional[str] Sticker tags MISSING reason Optional[str] Reason for creating the sticker MISSING Returns: Type Description Sticker New Sticker instance Source code in dis_snek/models/discord_objects/guild.py async def create_custom_sticker ( self , name : str , imagefile : Union [ str , \"Path\" , \"IOBase\" ], description : Optional [ str ] = MISSING , tags : Optional [ str ] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"Sticker\" : \"\"\" Creates a custom sticker for a guild Args: name: Sticker name imagefile: Sticker image file description: Sticker description tags: Sticker tags reason: Reason for creating the sticker Returns: New Sticker instance \"\"\" payload = FormData () payload . add_field ( \"name\" , name ) # TODO Validate image type? if isinstance ( imagefile , IOBase ): payload . add_field ( \"file\" , name ) else : payload . add_field ( \"file\" , open ( str ( imagefile ))) if description : payload . add_field ( \"description\" , description ) if tags : payload . add_field ( \"tags\" , tags ) sticker_data = await self . _client . http . create_guild_sticker ( payload , self . id , reason ) return Sticker . from_dict ( sticker_data , self . _client ) async get_all_custom_stickers ( self ) \u00b6 Gets all custom stickers for a guild. Returns: Type Description List[Sticker] List of Sticker objects Source code in dis_snek/models/discord_objects/guild.py async def get_all_custom_stickers ( self ) -> List [ \"Sticker\" ]: \"\"\" Gets all custom stickers for a guild. Returns: List of Sticker objects \"\"\" stickers_data = await self . _client . http . list_guild_stickers ( self . id ) return Sticker . from_list ( stickers_data , self . _client ) async get_custom_sticker ( self , sticker_id ) \u00b6 Gets a specific custom sticker for a guild Parameters: Name Type Description Default sticker_id Snowflake_Type ID of sticker to get required Returns: Type Description Sticker Requested Sticker Source code in dis_snek/models/discord_objects/guild.py async def get_custom_sticker ( self , sticker_id : \"Snowflake_Type\" ) -> \"Sticker\" : \"\"\" Gets a specific custom sticker for a guild Args: sticker_id: ID of sticker to get Returns: Requested Sticker \"\"\" sticker_data = await self . _client . http . get_guild_sticker ( self . id , to_snowflake ( sticker_id )) return Sticker . from_dict ( sticker_data , self . _client ) async get_active_threads ( self ) \u00b6 Gets all active threads in the guild, including public and private threads. Threads are ordered by their id, in descending order. Returns: Type Description ThreadList List of active threads and thread member object for each returned thread the bot user has joined. Source code in dis_snek/models/discord_objects/guild.py async def get_active_threads ( self ) -> \"ThreadList\" : \"\"\" Gets all active threads in the guild, including public and private threads. Threads are ordered by their id, in descending order. returns: List of active threads and thread member object for each returned thread the bot user has joined. \"\"\" threads_data = await self . _client . http . list_active_threads ( self . id ) return ThreadList . from_dict ( threads_data , self . _client ) async get_role ( self , role_id ) \u00b6 Get the specified role by ID. Parameters: Name Type Description Default role_id Snowflake_Type The ID of the role to get required Returns: Type Description Optional[Role] A role object or None if the role is not found. Source code in dis_snek/models/discord_objects/guild.py async def get_role ( self , role_id : \"Snowflake_Type\" ) -> Optional [ \"Role\" ]: \"\"\" Get the specified role by ID. Args: role_id: The ID of the role to get Returns: A role object or None if the role is not found. \"\"\" return await self . _client . cache . get_role ( self . id , role_id ) async create_role ( self , name = MISSING , permissions = MISSING , colour = MISSING , color = MISSING , hoist = False , mentionable = False , icon = MISSING , reason = MISSING ) \u00b6 Create a new role for the guild. You must have the manage roles permission. Parameters: Name Type Description Default name Optional[str] The name the role should have. Default: new role MISSING permissions Optional[dis_snek.models.enums.Permissions] The permissions the role should have. Default: @everyone permissions MISSING colour Union[dis_snek.models.color.Color, int] The colour of the role. Can be either Color or an RGB integer. Default: BrandColors.BLACK MISSING color Union[dis_snek.models.color.Color, int] Alias for colour MISSING icon Union[str, Path, IOBase] Can be either a bytes like object or a path to an image, or a unicode emoji which is supported by discord. MISSING hoist Optional[bool] Whether the role is shown separately in the members list. Default: False False mentionable Optional[bool] Whether the role can be mentioned. Default: False False reason Optional[str] An optional reason for the audit log. MISSING Returns: Type Description Role A role object or None if the role is not found. Source code in dis_snek/models/discord_objects/guild.py async def create_role ( self , name : Optional [ str ] = MISSING , permissions : Optional [ Permissions ] = MISSING , colour : Optional [ Union [ Color , int ]] = MISSING , color : Optional [ Union [ Color , int ]] = MISSING , hoist : Optional [ bool ] = False , mentionable : Optional [ bool ] = False , # ToDo: icon needs testing. I have to access to that icon : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"Role\" : \"\"\" Create a new role for the guild. You must have the `manage roles` permission. Args: name: The name the role should have. `Default: new role` permissions: The permissions the role should have. `Default: @everyone permissions` colour: The colour of the role. Can be either `Color` or an RGB integer. `Default: BrandColors.BLACK` color: Alias for `colour` icon: Can be either a bytes like object or a path to an image, or a unicode emoji which is supported by discord. hoist: Whether the role is shown separately in the members list. `Default: False` mentionable: Whether the role can be mentioned. `Default: False` reason: An optional reason for the audit log. Returns: A role object or None if the role is not found. \"\"\" payload = {} if name : payload . update ({ \"name\" : name }) if permissions : payload . update ({ \"permissions\" : str ( int ( permissions ))}) colour = colour or color if colour : payload . update ({ \"color\" : colour . value }) if hoist : payload . update ({ \"hoist\" : True }) if mentionable : payload . update ({ \"mentionable\" : True }) if icon : # test if the icon is probably a unicode emoji (str and len() == 1) or a path / bytes obj if isinstance ( icon , str ) and len ( icon ) == 1 : payload . update ({ \"unicode_emoji\" : icon }) else : payload . update ({ \"icon\" : to_image_data ( icon )}) result = await self . _client . http . create_guild_role ( guild_id = self . id , payload = payload , reason = reason ) return self . _client . cache . place_role_data ( guild_id = self . id , data = [ result ])[ to_snowflake ( result [ \"id\" ])] async get_channel ( self , channel_id ) \u00b6 Returns a channel with the given channel_id Parameters: Name Type Description Default channel_id Snowflake_Type The ID of the channel to get required Returns: Type Description Union[TYPE_GUILD_CHANNEL, TYPE_THREAD_CHANNEL] Channel object if found, otherwise None Source code in dis_snek/models/discord_objects/guild.py async def get_channel ( self , channel_id : \"Snowflake_Type\" ) -> Optional [ Union [ \"TYPE_GUILD_CHANNEL\" , \"TYPE_THREAD_CHANNEL\" ]]: \"\"\" Returns a channel with the given `channel_id` Args: channel_id: The ID of the channel to get Returns: Channel object if found, otherwise None \"\"\" if channel_id in self . _channel_ids and channel_id not in self . _thread_ids : # theoretically, this could get any channel the client can see, # but to make it less confusing to new programmers, # i intentionally check that the guild contains the channel first return await self . _client . cache . get_channel ( channel_id ) return None async get_thread ( self , thread_id ) \u00b6 Returns a Thread with the given thread_id Parameters: Name Type Description Default thread_id Snowflake_Type The ID of the thread to get required Returns: Type Description Optional[TYPE_THREAD_CHANNEL] Channel object if found, otherwise None Source code in dis_snek/models/discord_objects/guild.py async def get_thread ( self , thread_id : \"Snowflake_Type\" ) -> Optional [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\" Returns a Thread with the given `thread_id` Args: thread_id: The ID of the thread to get Returns: Channel object if found, otherwise None \"\"\" # get_channel can retrieve threads, so this is basically an alias with extra steps for that if thread_id in self . _thread_ids : return await self . get_channel ( thread_id ) return None async prune_members ( self , days = 7 , roles = MISSING , compute_prune_count = True , reason = MISSING ) \u00b6 Begin a guild prune. Removes members from the guild who who have not interacted for the last days days. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in roles Requires kick members permission. Parameters: Name Type Description Default days int number of days to prune (1-30) 7 roles List[Union[Snowflake_Type, Role]] list of roles to include in the prune MISSING compute_prune_count bool Whether the number of members pruned should be calculated (disable this for large guilds) True reason str The reason for this prune MISSING Returns: Type Description Optional[int] The total number of members pruned, if compute_prune_count is set to True, otherwise None Source code in dis_snek/models/discord_objects/guild.py async def prune_members ( self , days : int = 7 , roles : List [ Union [ \"Snowflake_Type\" , \"Role\" ]] = MISSING , compute_prune_count : bool = True , reason : str = MISSING , ) -> Optional [ int ]: \"\"\" Begin a guild prune. Removes members from the guild who who have not interacted for the last `days` days. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles` Requires `kick members` permission. Args: days: number of days to prune (1-30) roles: list of roles to include in the prune compute_prune_count: Whether the number of members pruned should be calculated (disable this for large guilds) reason: The reason for this prune Returns: The total number of members pruned, if `compute_prune_count` is set to True, otherwise None \"\"\" if roles is not MISSING : roles = [ r . id if isinstance ( r , Role ) else r for r in roles ] else : roles = [] resp = await self . _client . http . begin_guild_prune ( self . id , days , include_roles = roles , compute_prune_count = compute_prune_count , reason = reason ) return resp [ \"pruned\" ] async estimate_prune_members ( self , days = 7 , roles = MISSING ) \u00b6 Calculate how many members would be pruned, should guild.prune_members be used. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in roles Parameters: Name Type Description Default days int number of days to prune (1-30) 7 roles List[Union[Snowflake_Type, Role]] list of roles to include in the prune MISSING Returns: Type Description int Total number of members that would be pruned Source code in dis_snek/models/discord_objects/guild.py async def estimate_prune_members ( self , days : int = 7 , roles : List [ Union [ \"Snowflake_Type\" , \"Role\" ]] = MISSING ) -> int : \"\"\" Calculate how many members would be pruned, should `guild.prune_members` be used. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles` Args: days: number of days to prune (1-30) roles: list of roles to include in the prune Returns: Total number of members that would be pruned \"\"\" if roles is not MISSING : roles = [ r . id if isinstance ( r , Role ) else r for r in roles ] else : roles = [] resp = await self . _client . http . get_guild_prune_count ( self . id , days = days , include_roles = roles ) return resp [ \"pruned\" ] async leave ( self ) \u00b6 Leave this guild Source code in dis_snek/models/discord_objects/guild.py async def leave ( self ) -> None : \"\"\"Leave this guild\"\"\" await self . _client . http . leave_guild ( self . id ) async delete ( self ) \u00b6 Delete the guild. You must own this guild to do this. Source code in dis_snek/models/discord_objects/guild.py async def delete ( self ) -> None : \"\"\"Delete the guild. You must own this guild to do this.\"\"\" await self . _client . http . delete_guild ( self . id ) async kick ( self , user , reason = MISSING ) \u00b6 Kick a user from the guild. You must have the kick members permission Parameters: Name Type Description Default user Union[User, Member, Snowflake_Type] The user to kick required reason str The reason for the kick MISSING Source code in dis_snek/models/discord_objects/guild.py async def kick ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ], reason : str = MISSING ) -> None : \"\"\" Kick a user from the guild. You must have the `kick members` permission Args: user: The user to kick reason: The reason for the kick \"\"\" await self . _client . http . remove_guild_member ( self . id , to_snowflake ( user ), reason = reason ) async ban ( self , user , delete_message_days = 0 , reason = MISSING ) \u00b6 Ban a user from the guild. You must have the ban members permission Parameters: Name Type Description Default user Union[User, Member, Snowflake_Type] The user to ban required delete_message_days int How many days worth of messages to remove 0 reason str The reason for the ban MISSING Source code in dis_snek/models/discord_objects/guild.py async def ban ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ], delete_message_days : int = 0 , reason : str = MISSING ) -> None : \"\"\" Ban a user from the guild. You must have the `ban members` permission Args: user: The user to ban delete_message_days: How many days worth of messages to remove reason: The reason for the ban \"\"\" await self . _client . http . create_guild_ban ( self . id , to_snowflake ( user ), delete_message_days , reason = reason ) async get_ban ( self , user ) \u00b6 Get's the ban information for the specified user in the guild. You must have the ban members permission Parameters: Name Type Description Default user Union[User, Member, Snowflake_Type] The user to look up. required Exceptions: Type Description NotFound If the user is not banned in the guild. Returns: Type Description GuildBan The ban information. Source code in dis_snek/models/discord_objects/guild.py async def get_ban ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ]) -> GuildBan : \"\"\" Get's the ban information for the specified user in the guild. You must have the `ban members` permission Args: user: The user to look up. Raises: NotFound: If the user is not banned in the guild. Returns: The ban information. \"\"\" ban_info = await self . _client . http . get_guild_ban ( self . id , to_snowflake ( user )) return GuildBan ( reason = ban_info [ \"reason\" ], user = self . _client . cache . place_user_data ( ban_info [ \"user\" ])) async get_bans ( self ) \u00b6 Get's all bans for the guild. You must have the ban members permission Returns: Type Description list A list containing all bans and information about them. Source code in dis_snek/models/discord_objects/guild.py async def get_bans ( self ) -> list [ GuildBan ]: \"\"\" Get's all bans for the guild. You must have the `ban members` permission Returns: A list containing all bans and information about them. \"\"\" ban_infos = await self . _client . http . get_guild_bans ( self . id ) return [ GuildBan ( reason = ban_info [ \"reason\" ], user = self . _client . cache . place_user_data ( ban_info [ \"user\" ])) for ban_info in ban_infos ] async unban ( self , user , reason = MISSING ) \u00b6 Unban a user from the guild. You must have the ban members permission Parameters: Name Type Description Default user Union[User, Member, Snowflake_Type] The user to unban required reason str The reason for the ban MISSING Source code in dis_snek/models/discord_objects/guild.py async def unban ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ], reason : str = MISSING ) -> None : \"\"\" Unban a user from the guild. You must have the `ban members` permission Args: user: The user to unban reason: The reason for the ban \"\"\" await self . _client . http . remove_guild_ban ( self . id , to_snowflake ( user ), reason = reason ) async get_widget_image ( self , style = None ) \u00b6 Get a guilds widget image For a list of styles, look here: https://discord.com/developers/docs/resources/guild#get-guild-widget-image-widget-style-options Parameters: Name Type Description Default style str The style to use for the widget image None Source code in dis_snek/models/discord_objects/guild.py async def get_widget_image ( self , style : str = None ) -> str : \"\"\" Get a guilds widget image For a list of styles, look here: https://discord.com/developers/docs/resources/guild#get-guild-widget-image-widget-style-options Args: style: The style to use for the widget image \"\"\" return await self . _client . http . get_guild_widget_image ( self . id , style ) async get_widget ( self ) \u00b6 Gets the guilds widget Source code in dis_snek/models/discord_objects/guild.py async def get_widget ( self ) -> dict : \"\"\" Gets the guilds widget \"\"\" # todo: Guild widget object return await self . _client . http . get_guild_widget ( self . id ) async modify_widget ( self , enabled = None , channel = None ) \u00b6 Modify the guild's widget. Parameters: Name Type Description Default enabled bool Should the widget be enabled? None channel Union[TYPE_GUILD_CHANNEL, Snowflake_Type] The channel to use in the widget None Source code in dis_snek/models/discord_objects/guild.py async def modify_widget ( self , enabled : bool = None , channel : Union [ \"TYPE_GUILD_CHANNEL\" , \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Modify the guild's widget. Args: enabled: Should the widget be enabled? channel: The channel to use in the widget \"\"\" if channel : if isinstance ( channel , DiscordObject ): channel = channel . id return await self . _client . http . modify_guild_widget ( self . id , enabled , channel ) GuildTemplate ( ClientObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/guild.py @define () class GuildTemplate ( ClientObject ): code : str = attr . ib ( metadata = docs ( \"the template code (unique ID)\" )) name : str = attr . ib ( metadata = docs ( \"the name\" )) description : Optional [ str ] = attr . ib ( default = None , metadata = docs ( \"the description\" )) usage_count : int = attr . ib ( default = 0 , metadata = docs ( \"number of times this template has been used\" )) creator_id : \"Snowflake_Type\" = attr . ib ( metadata = docs ( \"The ID of the user who created this template\" )) creator : Optional [ \"User\" ] = attr . ib ( default = None , metadata = docs ( \"the user who created this template\" )) created_at : \"Timestamp\" = attr . ib ( metadata = docs ( \"When this template was created\" )) updated_at : \"Timestamp\" = attr . ib ( metadata = docs ( \"When this template was last synced to the source guild\" )) source_guild_id : \"Snowflake_Type\" = attr . ib ( metadata = docs ( \"The ID of the guild this template is based on\" )) guild_snapshot : \"Guild\" = attr . ib ( metadata = docs ( \"A snapshot of the guild this template contains\" )) is_dirty : bool = attr . ib ( default = False , metadata = docs ( \"Whether this template has un-synced changes\" )) @classmethod def _process_dict ( cls , data , client ): data [ \"creator\" ] = client . cache . place_user_data ( data [ \"creator\" ]) # todo: partial guild obj that **isn't** cached data [ \"guild_snapshot\" ] = data . pop ( \"serialized_source_guild\" ) return data async def synchronise ( self ) -> \"GuildTemplate\" : \"\"\"Synchronise the template to the source guild's current state\"\"\" data = await self . _client . http . sync_guild_template ( self . source_guild_id , self . code ) self . update_from_dict ( data ) return self async def modify ( self , name : Optional [ str ] = None , description : Optional [ str ] = None ) -> \"GuildTemplate\" : \"\"\" Modify the template's metadata. Arguments: name: The name for the template description: The description for the template \"\"\" data = await self . _client . http . modify_guild_template ( self . source_guild_id , self . code , name = name , description = description ) self . update_from_dict ( data ) return self async def delete ( self ) -> None : \"\"\"Delete the guild template\"\"\" await self . _client . http . delete_guild_template ( self . source_guild_id , self . code ) attrs-field kw_only code : str \u00b6 the template code (unique ID) attrs-field kw_only created_at : Timestamp \u00b6 When this template was created attrs-field kw_only creator : Optional [ User ] \u00b6 the user who created this template attrs-field kw_only creator_id : Snowflake_Type \u00b6 The ID of the user who created this template attrs-field kw_only description : Optional [ str ] \u00b6 the description attrs-field kw_only guild_snapshot : Guild \u00b6 A snapshot of the guild this template contains attrs-field kw_only is_dirty : bool \u00b6 Whether this template has un-synced changes attrs-field kw_only name : str \u00b6 the name attrs-field kw_only source_guild_id : Snowflake_Type \u00b6 The ID of the guild this template is based on attrs-field kw_only updated_at : Timestamp \u00b6 When this template was last synced to the source guild attrs-field kw_only usage_count : int \u00b6 number of times this template has been used inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/guild.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/guild.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async synchronise ( self ) \u00b6 Synchronise the template to the source guild's current state Source code in dis_snek/models/discord_objects/guild.py async def synchronise ( self ) -> \"GuildTemplate\" : \"\"\"Synchronise the template to the source guild's current state\"\"\" data = await self . _client . http . sync_guild_template ( self . source_guild_id , self . code ) self . update_from_dict ( data ) return self async modify ( self , name = None , description = None ) \u00b6 Modify the template's metadata. Parameters: Name Type Description Default name Optional[str] The name for the template None description Optional[str] The description for the template None Source code in dis_snek/models/discord_objects/guild.py async def modify ( self , name : Optional [ str ] = None , description : Optional [ str ] = None ) -> \"GuildTemplate\" : \"\"\" Modify the template's metadata. Arguments: name: The name for the template description: The description for the template \"\"\" data = await self . _client . http . modify_guild_template ( self . source_guild_id , self . code , name = name , description = description ) self . update_from_dict ( data ) return self async delete ( self ) \u00b6 Delete the guild template Source code in dis_snek/models/discord_objects/guild.py async def delete ( self ) -> None : \"\"\"Delete the guild template\"\"\" await self . _client . http . delete_guild_template ( self . source_guild_id , self . code ) GuildWelcomeChannel ( ClientObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/guild.py @define () class GuildWelcomeChannel ( ClientObject ): channel_id : \"Snowflake_Type\" = attr . ib ( metadata = docs ( \"Welcome Channel ID\" )) description : str = attr . ib ( metadata = docs ( \"Welcome Channel description\" )) emoji_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , metadata = docs ( \"Welcome Channel emoji ID if the emoji is custom\" ) ) emoji_name : Optional [ str ] = attr . ib ( default = None , metadata = docs ( \"Emoji name if custom, unicode character if standard\" ) ) attrs-field kw_only channel_id : Snowflake_Type \u00b6 Welcome Channel ID attrs-field kw_only description : str \u00b6 Welcome Channel description attrs-field kw_only emoji_id : Optional [ Snowflake_Type ] \u00b6 Welcome Channel emoji ID if the emoji is custom attrs-field kw_only emoji_name : Optional [ str ] \u00b6 Emoji name if custom, unicode character if standard inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/guild.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/guild.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) GuildWelcome ( ClientObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/guild.py @define () class GuildWelcome ( ClientObject ): description : Optional [ str ] = attr . ib ( default = None , metadata = docs ( \"Welcome Screen server description\" )) welcome_channels : List [ \"GuildWelcomeChannel\" ] = attr . ib ( metadata = docs ( \"List of Welcome Channel objects, up to 5\" )) attrs-field kw_only description : Optional [ str ] \u00b6 Welcome Screen server description attrs-field kw_only welcome_channels : List [ GuildWelcomeChannel ] \u00b6 List of Welcome Channel objects, up to 5 inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/guild.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/guild.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) GuildIntegration ( DiscordObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/guild.py class GuildIntegration ( DiscordObject ): name : str = attr . ib () type : str = attr . ib () enabled : bool = attr . ib () account : dict = attr . ib () application : Optional [ Application ] = attr . ib ( default = None ) _guild_id : \"Snowflake_Type\" = attr . ib () syncing : Optional [ bool ] = attr . ib ( default = MISSING ) role_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = MISSING ) enable_emoticons : bool = attr . ib ( default = MISSING ) expire_behavior : IntegrationExpireBehaviour = attr . ib ( default = MISSING , converter = optional ( IntegrationExpireBehaviour ) ) expire_grace_period : int = attr . ib ( default = MISSING ) user : \"BaseUser\" = attr . ib ( default = MISSING ) synced_at : \"Timestamp\" = attr . ib ( default = MISSING , converter = optional ( timestamp_converter )) subscriber_count : int = attr . ib ( default = MISSING ) revoked : bool = attr . ib ( default = MISSING ) @classmethod def from_dict ( cls , data , client ): if app := data . get ( \"application\" , None ): data [ \"application\" ] = Application . from_dict ( app , client ) if user := data . get ( \"user\" , None ): data [ \"user\" ] = client . cache . place_user_data ( user ) return super () . from_dict ( data , client ) async def delete ( self , reason : str = MISSING ): \"\"\"Delete this guild integration\"\"\" await self . _client . http . delete_guild_integration ( self . _guild_id , self . id , reason ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/guild.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/guild.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) classmethod from_dict ( data , client ) \u00b6 Process and converts dictionary data received from discord api to object class instance. Parameters: Name Type Description Default data The json data received from discord api. required Source code in dis_snek/models/discord_objects/guild.py @classmethod def from_dict ( cls , data , client ): if app := data . get ( \"application\" , None ): data [ \"application\" ] = Application . from_dict ( app , client ) if user := data . get ( \"user\" , None ): data [ \"user\" ] = client . cache . place_user_data ( user ) return super () . from_dict ( data , client ) async delete ( self , reason = MISSING ) \u00b6 Delete this guild integration Source code in dis_snek/models/discord_objects/guild.py async def delete ( self , reason : str = MISSING ): \"\"\"Delete this guild integration\"\"\" await self . _client . http . delete_guild_integration ( self . _guild_id , self . id , reason ) Attachment ( DiscordObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/message.py @define () class Attachment ( DiscordObject ): filename : str = attr . ib () content_type : Optional [ str ] = attr . ib ( default = None ) size : int = attr . ib () url : str = attr . ib () proxy_url : str = attr . ib () height : Optional [ int ] = attr . ib ( default = None ) width : Optional [ int ] = attr . ib ( default = None ) @property def size ( self ): return self . height , self . width inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/message.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/message.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) ChannelMention ( DiscordObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/message.py @define () class ChannelMention ( DiscordObject ): guild_id : \"Snowflake_Type\" = attr . ib () type : ChannelTypes = attr . ib ( converter = ChannelTypes ) name : str = attr . ib () inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/message.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/message.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) MessageActivity dataclass \u00b6 MessageActivity(type: dis_snek.models.enums.MessageActivityTypes, party_id: str = None) Source code in dis_snek/models/discord_objects/message.py @dataclass class MessageActivity : type : MessageActivityTypes party_id : str = None MessageReference ( DictSerializationMixin ) attrs \u00b6 Reference to an originating message. Can be used for replies. Source code in dis_snek/models/discord_objects/message.py @attr . s ( slots = True ) class MessageReference ( DictSerializationMixin ): \"\"\"Reference to an originating message. Can be used for replies.\"\"\" message_id : int = attr . ib ( default = None , converter = optional_c ( to_snowflake )) \"\"\"id of the originating message.\"\"\" channel_id : Optional [ int ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) \"\"\"id of the originating message's channel.\"\"\" guild_id : Optional [ int ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) \"\"\"id of the originating message's guild.\"\"\" fail_if_not_exists : bool = attr . ib ( default = True ) \"\"\"When sending a message, whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message, default true.\"\"\" @classmethod def for_message ( cls , message : \"Message\" , fail_if_not_exists : bool = True ) -> \"MessageReference\" : return cls ( message_id = message . id , channel_id = message . channel . id , guild_id = message . guild . id , fail_if_not_exists = fail_if_not_exists , ) attrs-field channel_id : Optional [ int ] \u00b6 id of the originating message's channel. attrs-field fail_if_not_exists : bool \u00b6 When sending a message, whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message, default true. attrs-field guild_id : Optional [ int ] \u00b6 id of the originating message's guild. attrs-field message_id : int \u00b6 id of the originating message. inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/message.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/message.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) MessageInteraction ( DiscordObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/message.py @define class MessageInteraction ( DiscordObject ): type : InteractionTypes = attr . ib ( converter = InteractionTypes ) name : str = attr . ib () _user_id : \"Snowflake_Type\" = attr . ib () @classmethod def _process_dict ( cls , data , client ): user_data = data [ \"user\" ] data [ \"user_id\" ] = client . cache . place_user_data ( user_data ) . id return data async def user ( self ) -> \"User\" : \"\"\" Get the user associated with this interaction. \"\"\" return await self . get_user ( self . _user_id ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/message.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/message.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async user ( self ) \u00b6 Get the user associated with this interaction. Source code in dis_snek/models/discord_objects/message.py async def user ( self ) -> \"User\" : \"\"\" Get the user associated with this interaction. \"\"\" return await self . get_user ( self . _user_id ) AllowedMentions attrs \u00b6 The allowed mention field allows for more granular control over mentions without various hacks to the message content. This will always validate against message content to avoid phantom pings, and check against user/bot permissions. Source code in dis_snek/models/discord_objects/message.py @attr . s ( slots = True ) class AllowedMentions : \"\"\" The allowed mention field allows for more granular control over mentions without various hacks to the message content. This will always validate against message content to avoid phantom pings, and check against user/bot permissions. \"\"\" parse : Optional [ List [ str ]] = attr . ib ( factory = list ) \"\"\"An array of allowed mention types to parse from the content.\"\"\" roles : Optional [ List [ \"Snowflake_Type\" ]] = attr . ib ( factory = list ) \"\"\"Array of role_ids to mention. (Max size of 100)\"\"\" users : Optional [ List [ \"Snowflake_Type\" ]] = attr . ib ( factory = list ) \"\"\"Array of user_ids to mention. (Max size of 100)\"\"\" replied_user = attr . ib ( default = False ) \"\"\"For replies, whether to mention the author of the message being replied to. (default false)\"\"\" def add_roles ( self , * roles : Union [ \"Role\" , \"Snowflake_Type\" ]): for role in roles : if isinstance ( role , DiscordObject ): role = role . id self . roles . append ( role ) def add_users ( self , * users : Union [ \"Member\" , \"BaseUser\" , \"Snowflake_Type\" ]): for user in users : if isinstance ( user , DiscordObject ): user = user . id self . users . append ( user ) def to_dict ( self ) -> dict : return attr . asdict ( self , filter = lambda key , value : isinstance ( value , bool ) or value ) @classmethod def all ( cls ): return cls ( parse = list ( MentionTypes . __members__ . values ()), replied_user = True ) @classmethod def none ( cls ): return cls () attrs-field parse : Optional [ List [ str ]] \u00b6 An array of allowed mention types to parse from the content. attrs-field replied_user : None \u00b6 For replies, whether to mention the author of the message being replied to. (default false) attrs-field roles : Optional [ List [ Snowflake_Type ]] \u00b6 Array of role_ids to mention. (Max size of 100) attrs-field users : Optional [ List [ Snowflake_Type ]] \u00b6 Array of user_ids to mention. (Max size of 100) Message ( DiscordObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/message.py @define () class Message ( DiscordObject ): content : str = attr . ib () timestamp : Timestamp = attr . ib ( converter = timestamp_converter ) edited_timestamp : Optional [ Timestamp ] = attr . ib ( default = None , converter = optional_c ( timestamp_converter )) tts : bool = attr . ib ( default = False ) mention_everyone : bool = attr . ib ( default = False ) mention_channels : Optional [ List [ ChannelMention ]] = attr . ib ( default = None ) attachments : List [ Attachment ] = attr . ib ( factory = list ) embeds : List [ Embed ] = attr . ib ( factory = list ) reactions : List [ Reaction ] = attr . ib ( factory = list ) nonce : Optional [ Union [ int , str ]] = attr . ib ( default = None ) pinned : bool = attr . ib ( default = False ) webhook_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) type : MessageTypes = attr . ib ( converter = MessageTypes ) activity : Optional [ MessageActivity ] = attr . ib ( default = None , converter = optional_c ( MessageActivity )) application : Optional [ \"Application\" ] = attr . ib ( default = None ) # TODO: partial application application_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) message_reference : Optional [ MessageReference ] = attr . ib ( default = None , converter = optional_c ( MessageReference . from_dict ) ) flags : Optional [ MessageFlags ] = attr . ib ( default = None , converter = optional_c ( MessageFlags )) interaction : Optional [ \"MessageInteraction\" ] = attr . ib ( default = None ) components : Optional [ List [ \"ActionRow\" ]] = attr . ib ( default = None ) sticker_items : Optional [ List [ StickerItem ]] = attr . ib ( default = None ) # TODO: Perhaps automatically get the full sticker data. _channel_id : \"Snowflake_Type\" = attr . ib ( converter = optional_c ( to_snowflake )) _guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) _author_id : \"Snowflake_Type\" = attr . ib ( converter = optional_c ( to_snowflake ) ) # TODO: create override for detecting PartialMember _mention_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _mention_roles : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _referenced_message_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) _thread_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) channel : \"TextChannel\" = attr . ib ( default = None ) thread : \"Thread\" = attr . ib ( default = None ) guild : \"Guild\" = attr . ib ( default = None ) author : Union [ \"Member\" , \"User\" ] = attr . ib ( default = None ) @property async def mention_users ( self ) -> AsyncGenerator [ \"Member\" , None ]: for u_id in self . _mention_ids : yield await self . _client . cache . get_member ( self . _guild_id , u_id ) @property async def mention_roles ( self ) -> AsyncGenerator [ \"Role\" , None ]: for r_id in self . _mention_roles : yield await self . _client . cache . get_role ( self . _guild_id , r_id ) async def get_referenced_message ( self ) -> Optional [ \"Message\" ]: \"\"\" Get the message this message is referencing, if any Returns: The referenced message, if found \"\"\" if self . _referenced_message_id is None : return None return await self . _client . cache . get_message ( self . _channel_id , self . _referenced_message_id ) @classmethod def _process_dict ( cls , data : dict , client : \"Snake\" ) -> dict : # TODO: Is there a way to dynamically do this instead of hard coding? try : author_data = data . pop ( \"author\" ) except KeyError : # todo: properly handle message updates that change flags (ie recipient add) return data if \"guild_id\" in data and \"member\" in data : author_data [ \"member\" ] = data . pop ( \"member\" ) data [ \"author_id\" ] = client . cache . place_member_data ( data [ \"guild_id\" ], author_data ) . id else : data [ \"author_id\" ] = client . cache . place_user_data ( author_data ) . id mention_ids = [] for user_data in data . pop ( \"mentions\" , {}): if \"guild_id\" in data and \"member\" in user_data : mention_ids . append ( client . cache . place_member_data ( data [ \"guild_id\" ], user_data ) . id ) else : mention_ids . append ( client . cache . place_user_data ( user_data ) . id ) data [ \"mention_ids\" ] = mention_ids if \"mention_channels\" in data : mention_channels = [] for channel_data in data [ \"mention_channels\" ]: mention_channels . append ( ChannelMention . from_dict ( channel_data , client )) data [ \"mention_channels\" ] = mention_channels attachments = [] for attachment_data in data [ \"attachments\" ]: attachments . append ( Attachment . from_dict ( attachment_data , client )) data [ \"attachments\" ] = attachments embeds = [] for embed_data in data [ \"embeds\" ]: embeds . append ( Embed . from_dict ( embed_data )) data [ \"embeds\" ] = embeds if \"reactions\" in data : reactions = [] for reaction_data in data [ \"reactions\" ]: reactions . append ( Reaction . from_dict ( reaction_data | { \"message_id\" : data [ \"id\" ], \"channel_id\" : data [ \"channel_id\" ]}, client ) ) data [ \"reactions\" ] = reactions # TODO: Convert to application object ref_message_data = data . pop ( \"referenced_message\" , None ) if ref_message_data : data [ \"referenced_message_id\" ] = client . cache . place_message_data ( ref_message_data ) if \"interaction\" in data : data [ \"interaction\" ] = MessageInteraction . from_dict ( data [ \"interaction\" ], client ) thread_data = data . pop ( \"thread\" , None ) if thread_data : data [ \"thread_channel_id\" ] = client . cache . place_channel_data ( thread_data ) . id if \"components\" in data : components = [] for component_data in data [ \"components\" ]: components . append ( BaseComponent . from_dict_factory ( component_data )) data [ \"components\" ] = components if \"sticker_items\" in data : data [ \"sticker_items\" ] = StickerItem . from_list ( data [ \"sticker_items\" ], client ) return data @property def jump_url ( self ) -> str : \"\"\"A url that allows the client to *jump* to this message\"\"\" return f \"https://discord.com/channels/ { self . _guild_id or '@me' } / { self . _channel_id } / { self . id } \" @property def proto_url ( self ) -> str : \"\"\"A URL like `jump_url` that uses protocols\"\"\" return f \"discord://-/channels/ { self . _guild_id or '@me' } / { self . _channel_id } / { self . id } \" async def edit ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ Embed , dict ]], Union [ Embed , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , allowed_mentions : Optional [ Union [ AllowedMentions , dict ]] = None , attachments : Optional [ Optional [ List [ Union [ Attachment , dict ]]]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , MessageFlags ]] = None , ) -> \"Message\" : \"\"\" Edits the message. Args: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. allowed_mentions: Allowed mentions for the message. attachments: The attachments to keep, only used when editing message. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. Returns: New message object with edits applied \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , attachments = attachments , file = file , tts = tts , flags = flags , ) if self . flags == MessageFlags . EPHEMERAL : raise EphemeralEditException () message_data = await self . _client . http . edit_message ( message_payload , self . _channel_id , self . id ) if message_data : return self . _client . cache . place_message_data ( message_data ) async def delete ( self , delay : Optional [ int ] = MISSING ): \"\"\" Delete message. Args: delay: Seconds to wait before deleting message. \"\"\" if delay and delay > 0 : async def delayed_delete (): await asyncio . sleep ( delay ) try : await self . _client . http . delete_message ( self . _channel_id , self . id ) except Exception : pass # No real way to handle this asyncio . ensure_future ( delayed_delete ()) else : await self . _client . http . delete_message ( self . _channel_id , self . id ) async def reply ( self , content : Optional [ str ], ** kwargs ) -> \"Message\" : \"\"\"Reply to this message, takes all the same attributes as `send`\"\"\" return await self . channel . send ( content = content , reply_to = self , ** kwargs ) async def create_thread ( self , name : str , auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ): \"\"\" Create a thread from this message Args: name: The name of this thread auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080 reason: The optional reason for creating this thread Returns: The created thread object Raises: ThreadOutsideOfGuild: if this is invoked on a message outside of a guild \"\"\" if not isinstance ( await self . channel , GuildText ): raise ThreadOutsideOfGuild () thread_data = await self . _client . http . create_thread ( channel_id = self . _channel_id , name = name , auto_archive_duration = auto_archive_duration , message_id = self . id , reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async def get_reaction ( self , emoji : Union [ \"Emoji\" , dict , str ]) -> List [ \"User\" ]: \"\"\" Get reactions of a specific emoji from this message Args: emoji: The emoji to get Returns: list of users who have reacted with that emoji \"\"\" reaction_data = await self . _client . http . get_reactions ( self . _channel_id , self . id , emoji ) return [ self . _client . cache . place_user_data ( user_data ) for user_data in reaction_data ] async def add_reaction ( self , emoji : Union [ \"Emoji\" , dict , str ]): \"\"\" Add a reaction to this message. Args: emoji: the emoji to react with \"\"\" emoji = process_emoji_req_format ( emoji ) await self . _client . http . create_reaction ( self . _channel_id , self . id , emoji ) async def remove_reaction ( self , emoji : Union [ \"Emoji\" , dict , str ], member : Optional [ Union [ \"Member\" , \"User\" , \"Snowflake_Type\" ]] = MISSING ): \"\"\" Remove a specific reaction that a user reacted with Args: emoji: Emoji to remove member: Member to remove reaction of. Default's to snake bot user. \"\"\" emoji_str = process_emoji_req_format ( emoji ) if not member : member = self . _client . user user_id = to_snowflake ( member ) await self . _client . http . remove_user_reaction ( self . _channel_id , self . id , emoji_str , user_id ) async def clear_reactions ( self , emoji : Union [ \"Emoji\" , dict , str ]): # TODO Should we combine this with clear_all_reactions? \"\"\" Clear a specific reaction from message Args: emoji: The emoji to clear \"\"\" emoji = process_emoji_req_format ( emoji ) await self . _client . http . clear_reaction ( self . _channel_id , self . id , emoji ) async def clear_all_reactions ( self ): \"\"\"Clear all emojis from a message.\"\"\" await self . _client . http . clear_reactions ( self . channel . id , self . id ) async def pin ( self ): \"\"\"Pin message\"\"\" await self . _client . http . pin_message ( self . _channel_id , self . id ) self . pinned = True async def unpin ( self ): \"\"\"Unpin message\"\"\" await self . _client . http . unpin_message ( self . _channel_id , self . id ) self . pinned = False async def publish ( self ): \"\"\"Publish this message. (Discord api calls it \"crosspost\")\"\"\" await self . _client . http . crosspost_message ( self . _channel_id , self . id ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/message.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/message.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async get_referenced_message ( self ) \u00b6 Get the message this message is referencing, if any Returns: Type Description Optional[Message] The referenced message, if found Source code in dis_snek/models/discord_objects/message.py async def get_referenced_message ( self ) -> Optional [ \"Message\" ]: \"\"\" Get the message this message is referencing, if any Returns: The referenced message, if found \"\"\" if self . _referenced_message_id is None : return None return await self . _client . cache . get_message ( self . _channel_id , self . _referenced_message_id ) property readonly jump_url : str \u00b6 A url that allows the client to jump to this message property readonly proto_url : str \u00b6 A URL like jump_url that uses protocols async edit ( self , content = None , embeds = None , components = None , allowed_mentions = None , attachments = None , file = None , tts = False , flags = None ) \u00b6 Edits the message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[dis_snek.models.discord_objects.embed.Embed, dict]], dis_snek.models.discord_objects.embed.Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None allowed_mentions Union[dis_snek.models.discord_objects.message.AllowedMentions, dict] Allowed mentions for the message. None attachments Optional[List[Union[dis_snek.models.discord_objects.message.Attachment, dict]]] The attachments to keep, only used when editing message. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, dis_snek.models.enums.MessageFlags] Message flags to apply. None Returns: Type Description Message New message object with edits applied Source code in dis_snek/models/discord_objects/message.py async def edit ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ Embed , dict ]], Union [ Embed , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , allowed_mentions : Optional [ Union [ AllowedMentions , dict ]] = None , attachments : Optional [ Optional [ List [ Union [ Attachment , dict ]]]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , MessageFlags ]] = None , ) -> \"Message\" : \"\"\" Edits the message. Args: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. allowed_mentions: Allowed mentions for the message. attachments: The attachments to keep, only used when editing message. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. Returns: New message object with edits applied \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , attachments = attachments , file = file , tts = tts , flags = flags , ) if self . flags == MessageFlags . EPHEMERAL : raise EphemeralEditException () message_data = await self . _client . http . edit_message ( message_payload , self . _channel_id , self . id ) if message_data : return self . _client . cache . place_message_data ( message_data ) async delete ( self , delay = MISSING ) \u00b6 Delete message. Parameters: Name Type Description Default delay Optional[int] Seconds to wait before deleting message. MISSING Source code in dis_snek/models/discord_objects/message.py async def delete ( self , delay : Optional [ int ] = MISSING ): \"\"\" Delete message. Args: delay: Seconds to wait before deleting message. \"\"\" if delay and delay > 0 : async def delayed_delete (): await asyncio . sleep ( delay ) try : await self . _client . http . delete_message ( self . _channel_id , self . id ) except Exception : pass # No real way to handle this asyncio . ensure_future ( delayed_delete ()) else : await self . _client . http . delete_message ( self . _channel_id , self . id ) async reply ( self , content , ** kwargs ) \u00b6 Reply to this message, takes all the same attributes as send Source code in dis_snek/models/discord_objects/message.py async def reply ( self , content : Optional [ str ], ** kwargs ) -> \"Message\" : \"\"\"Reply to this message, takes all the same attributes as `send`\"\"\" return await self . channel . send ( content = content , reply_to = self , ** kwargs ) async create_thread ( self , name , auto_archive_duration =< AutoArchiveDuration . ONE_DAY : 1440 > , reason = None ) \u00b6 Create a thread from this message Parameters: Name Type Description Default name str The name of this thread required auto_archive_duration Union[dis_snek.models.enums.AutoArchiveDuration, int] duration in minutes to automatically archive the thread after recent activity, <AutoArchiveDuration.ONE_DAY: 1440> can be set to 60, 1440, 4320, 10080 required reason Optional[str] The optional reason for creating this thread None Returns: Type Description The created thread object Exceptions: Type Description ThreadOutsideOfGuild if this is invoked on a message outside of a guild Source code in dis_snek/models/discord_objects/message.py async def create_thread ( self , name : str , auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ): \"\"\" Create a thread from this message Args: name: The name of this thread auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080 reason: The optional reason for creating this thread Returns: The created thread object Raises: ThreadOutsideOfGuild: if this is invoked on a message outside of a guild \"\"\" if not isinstance ( await self . channel , GuildText ): raise ThreadOutsideOfGuild () thread_data = await self . _client . http . create_thread ( channel_id = self . _channel_id , name = name , auto_archive_duration = auto_archive_duration , message_id = self . id , reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async get_reaction ( self , emoji ) \u00b6 Get reactions of a specific emoji from this message Parameters: Name Type Description Default emoji Union[Emoji, dict, str] The emoji to get required Returns: Type Description List[User] list of users who have reacted with that emoji Source code in dis_snek/models/discord_objects/message.py async def get_reaction ( self , emoji : Union [ \"Emoji\" , dict , str ]) -> List [ \"User\" ]: \"\"\" Get reactions of a specific emoji from this message Args: emoji: The emoji to get Returns: list of users who have reacted with that emoji \"\"\" reaction_data = await self . _client . http . get_reactions ( self . _channel_id , self . id , emoji ) return [ self . _client . cache . place_user_data ( user_data ) for user_data in reaction_data ] async add_reaction ( self , emoji ) \u00b6 Add a reaction to this message. Parameters: Name Type Description Default emoji Union[Emoji, dict, str] the emoji to react with required Source code in dis_snek/models/discord_objects/message.py async def add_reaction ( self , emoji : Union [ \"Emoji\" , dict , str ]): \"\"\" Add a reaction to this message. Args: emoji: the emoji to react with \"\"\" emoji = process_emoji_req_format ( emoji ) await self . _client . http . create_reaction ( self . _channel_id , self . id , emoji ) async remove_reaction ( self , emoji , member = MISSING ) \u00b6 Remove a specific reaction that a user reacted with Parameters: Name Type Description Default emoji Union[Emoji, dict, str] Emoji to remove required member Union[Member, User, Snowflake_Type] Member to remove reaction of. Default's to snake bot user. MISSING Source code in dis_snek/models/discord_objects/message.py async def remove_reaction ( self , emoji : Union [ \"Emoji\" , dict , str ], member : Optional [ Union [ \"Member\" , \"User\" , \"Snowflake_Type\" ]] = MISSING ): \"\"\" Remove a specific reaction that a user reacted with Args: emoji: Emoji to remove member: Member to remove reaction of. Default's to snake bot user. \"\"\" emoji_str = process_emoji_req_format ( emoji ) if not member : member = self . _client . user user_id = to_snowflake ( member ) await self . _client . http . remove_user_reaction ( self . _channel_id , self . id , emoji_str , user_id ) async clear_reactions ( self , emoji ) \u00b6 Clear a specific reaction from message Parameters: Name Type Description Default emoji Union[Emoji, dict, str] The emoji to clear required Source code in dis_snek/models/discord_objects/message.py async def clear_reactions ( self , emoji : Union [ \"Emoji\" , dict , str ]): # TODO Should we combine this with clear_all_reactions? \"\"\" Clear a specific reaction from message Args: emoji: The emoji to clear \"\"\" emoji = process_emoji_req_format ( emoji ) await self . _client . http . clear_reaction ( self . _channel_id , self . id , emoji ) async clear_all_reactions ( self ) \u00b6 Clear all emojis from a message. Source code in dis_snek/models/discord_objects/message.py async def clear_all_reactions ( self ): \"\"\"Clear all emojis from a message.\"\"\" await self . _client . http . clear_reactions ( self . channel . id , self . id ) async pin ( self ) \u00b6 Pin message Source code in dis_snek/models/discord_objects/message.py async def pin ( self ): \"\"\"Pin message\"\"\" await self . _client . http . pin_message ( self . _channel_id , self . id ) self . pinned = True async unpin ( self ) \u00b6 Unpin message Source code in dis_snek/models/discord_objects/message.py async def unpin ( self ): \"\"\"Unpin message\"\"\" await self . _client . http . unpin_message ( self . _channel_id , self . id ) self . pinned = False async publish ( self ) \u00b6 Publish this message. (Discord api calls it \"crosspost\") Source code in dis_snek/models/discord_objects/message.py async def publish ( self ): \"\"\"Publish this message. (Discord api calls it \"crosspost\")\"\"\" await self . _client . http . crosspost_message ( self . _channel_id , self . id ) process_allowed_mentions ( allowed_mentions ) \u00b6 Process allowed mentions into a dictionary Parameters: Name Type Description Default allowed_mentions Union[dis_snek.models.discord_objects.message.AllowedMentions, dict] Allowed mentions object or dictionary required Returns: Type Description Optional[dict] Dictionary of allowed mentions Exceptions: Type Description ValueError Invalid allowed mentions Source code in dis_snek/models/discord_objects/message.py def process_allowed_mentions ( allowed_mentions : Optional [ Union [ AllowedMentions , dict ]]) -> Optional [ dict ]: \"\"\" Process allowed mentions into a dictionary Args: allowed_mentions: Allowed mentions object or dictionary Returns: Dictionary of allowed mentions Raises: ValueError: Invalid allowed mentions \"\"\" if not allowed_mentions : return allowed_mentions if isinstance ( allowed_mentions , dict ): return allowed_mentions if isinstance ( allowed_mentions , AllowedMentions ): return allowed_mentions . to_dict () raise ValueError ( f \"Invalid allowed mentions: { allowed_mentions } \" ) process_message_reference ( message_reference ) \u00b6 Process mention references into a dictionary Parameters: Name Type Description Default message_reference Union[dis_snek.models.discord_objects.message.MessageReference, dis_snek.models.discord_objects.message.Message, dict, Snowflake_Type] Message reference object required Returns: Type Description Optional[dict] Message reference dictionary Exceptions: Type Description ValueError Invalid message reference Source code in dis_snek/models/discord_objects/message.py def process_message_reference ( message_reference : Optional [ Union [ MessageReference , Message , dict , \"Snowflake_Type\" ]] ) -> Optional [ dict ]: \"\"\" Process mention references into a dictionary Args: message_reference: Message reference object Returns: Message reference dictionary Raises: ValueError: Invalid message reference \"\"\" if not message_reference : return message_reference if isinstance ( message_reference , dict ): return message_reference if isinstance ( message_reference , ( str , int )): message_reference = MessageReference ( message_id = message_reference ) if isinstance ( message_reference , Message ): message_reference = MessageReference . for_message ( message_reference ) if isinstance ( message_reference , MessageReference ): return message_reference . to_dict () raise ValueError ( f \"Invalid message reference: { message_reference } \" ) process_message_payload ( content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , attachments = None , file = None , tts = False , flags = None ) \u00b6 Format message content for it to be ready to send discord. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[dis_snek.models.discord_objects.embed.Embed, dict]], dis_snek.models.discord_objects.embed.Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[dis_snek.models.discord_objects.components.BaseComponent, dict]]], List[Union[dis_snek.models.discord_objects.components.BaseComponent, dict]], dis_snek.models.discord_objects.components.BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[dis_snek.models.discord_objects.message.AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[dis_snek.models.discord_objects.message.MessageReference, dis_snek.models.discord_objects.message.Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None attachments Optional[List[Union[dis_snek.models.discord_objects.message.Attachment, dict]]] The attachments to keep, only used when editing message. None file Union[File, IOBase, Path, str] Location of file to send, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, dis_snek.models.enums.MessageFlags] Message flags to apply. None Returns: Type Description Union[Dict, aiohttp.formdata.FormData] Dictionary or multipart data form. Source code in dis_snek/models/discord_objects/message.py def process_message_payload ( content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ Embed , dict ]], Union [ Embed , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ BaseComponent , dict ]]], List [ Union [ BaseComponent , dict ]], BaseComponent , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ AllowedMentions , dict ]] = None , reply_to : Optional [ Union [ MessageReference , Message , dict , \"Snowflake_Type\" ]] = None , attachments : Optional [ List [ Union [ Attachment , dict ]]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , MessageFlags ]] = None , ) -> Union [ Dict , FormData ]: \"\"\" Format message content for it to be ready to send discord. Args: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. attachments: The attachments to keep, only used when editing message. file: Location of file to send, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. Returns: Dictionary or multipart data form. \"\"\" content = content embeds = process_embeds ( embeds ) components = process_components ( components ) if stickers : stickers = [ to_snowflake ( sticker ) for sticker in stickers ] allowed_mentions = process_allowed_mentions ( allowed_mentions ) message_reference = process_message_reference ( reply_to ) if attachments : attachments = [ attachment . to_dict () for attachment in attachments ] message_data = dict_filter_none ( dict ( content = content , embeds = embeds , components = components , sticker_ids = stickers , allowed_mentions = allowed_mentions , message_reference = message_reference , attachments = attachments , tts = tts , flags = flags , ) ) if file : # We need to use multipart/form-data for file sending here. form = FormData () form . add_field ( \"payload_json\" , OverriddenJson . dumps ( message_data )) if isinstance ( file , File ): if isinstance ( file . file , IOBase ): form . add_field ( \"file\" , file . file , filename = file . file_name ) else : form . add_field ( \"file\" , open ( str ( file . file ), \"rb\" ), filename = file . file_name ) elif isinstance ( file , IOBase ): form . add_field ( \"file\" , file ) else : form . add_field ( \"file\" , open ( str ( file ), \"rb\" )) return form else : return message_data ReactionUsers ( AsyncIterator ) \u00b6 An async iterator for searching through a channel's history Parameters: Name Type Description Default channel_id The ID of the channel to search through required limit The maximum number of users to return (set to 0 for no limit) 50 after get users after this message ID None Source code in dis_snek/models/discord_objects/reaction.py class ReactionUsers ( AsyncIterator ): \"\"\" An async iterator for searching through a channel's history Args: channel_id: The ID of the channel to search through limit: The maximum number of users to return (set to 0 for no limit) after: get users after this message ID \"\"\" def __init__ ( self , reaction : \"Reaction\" , limit = 50 , after = None ): self . reaction : \"Reaction\" = reaction self . after : \"Snowflake_Type\" = after self . _more = True super () . __init__ ( limit ) async def fetch ( self ): if self . _more : expected = self . get_limit if self . after and not self . last : self . last = namedtuple ( \"temp\" , \"id\" ) self . last . id = self . after users = await self . reaction . _client . http . get_reactions ( self . reaction . _channel_id , self . reaction . _message_id , self . reaction . emoji . req_format , limit = expected , after = self . last . id or MISSING , ) if not users : raise QueueEmpty () self . _more = len ( users ) == expected return [ self . reaction . _client . cache . place_user_data ( u ) for u in users ] else : raise QueueEmpty () inherited property readonly get_limit \u00b6 Get how the maximum number of items that should be retrieved async fetch ( self ) \u00b6 Fetch additional objects. Your implementation of this method must return a list of objects. If no more objects are available, raise QueueEmpty Returns: Type Description List of objects Source code in dis_snek/models/discord_objects/reaction.py async def fetch ( self ): if self . _more : expected = self . get_limit if self . after and not self . last : self . last = namedtuple ( \"temp\" , \"id\" ) self . last . id = self . after users = await self . reaction . _client . http . get_reactions ( self . reaction . _channel_id , self . reaction . _message_id , self . reaction . emoji . req_format , limit = expected , after = self . last . id or MISSING , ) if not users : raise QueueEmpty () self . _more = len ( users ) == expected return [ self . reaction . _client . cache . place_user_data ( u ) for u in users ] else : raise QueueEmpty () async inherited add_object ( self , obj ) \u00b6 Add an object to iterator's queue Source code in dis_snek/models/discord_objects/reaction.py async def add_object ( self , obj ): \"\"\"Add an object to iterator's queue\"\"\" return await self . _queue . put ( obj ) async inherited flatten ( self ) \u00b6 Flatten this iterator into a list of objects Source code in dis_snek/models/discord_objects/reaction.py async def flatten ( self ) -> List : \"\"\"Flatten this iterator into a list of objects\"\"\" return [ elem async for elem in self ] async inherited search ( self , target_id ) \u00b6 Search the iterator for an object with the given ID Source code in dis_snek/models/discord_objects/reaction.py async def search ( self , target_id : \"Snowflake_Type\" ) -> bool : \"\"\"Search the iterator for an object with the given ID\"\"\" target_id = to_snowflake ( target_id ) if target_id in [ o . id for o in self . _retrieved_objects ]: return True async for o in self : if o . id == target_id : return True return False Reaction ( ClientObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/reaction.py @define () class Reaction ( ClientObject ): count : int = attr . ib () me : bool = attr . ib ( default = False ) emoji : \"Emoji\" = attr . ib ( converter = Emoji . from_dict ) _channel_id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) _message_id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) def users ( self , limit : int = 0 , after = None ) -> ReactionUsers : return ReactionUsers ( self , limit , after ) @property def message ( self ): return self . _client . cache . message_cache . get (( self . _channel_id , self . _message_id )) @property def channel ( self ): return self . _client . cache . channel_cache . get ( self . _channel_id ) async def remove ( self ): \"\"\"Remove all this emoji's reactions from the message\"\"\" await self . _client . http . clear_reaction ( self . _channel_id , self . _message_id , self . emoji . req_format ) inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/reaction.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) async remove ( self ) \u00b6 Remove all this emoji's reactions from the message Source code in dis_snek/models/discord_objects/reaction.py async def remove ( self ): \"\"\"Remove all this emoji's reactions from the message\"\"\" await self . _client . http . clear_reaction ( self . _channel_id , self . _message_id , self . emoji . req_format ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/reaction.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) Role ( DiscordObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/role.py @define () class Role ( DiscordObject ): _sentinel = object () name : str = field ( repr = True ) color : \"Color\" = field ( converter = Color ) hoist : bool = field ( default = False ) position : int = field ( repr = True ) permissions : \"Permissions\" = field ( converter = Permissions ) managed : bool = field ( default = False ) mentionable : bool = field ( default = True ) premium_subscriber : bool = field ( default = _sentinel , converter = partial ( sentinel_converter , sentinel = _sentinel )) guild : \"Guild\" = field ( default = None ) _guild_id : \"Snowflake_Type\" = field () _bot_id : Optional [ \"Snowflake_Type\" ] = field ( default = None ) integration_id : Optional [ \"Snowflake_Type\" ] = field ( default = None ) # todo integration object? @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data . update ( data . pop ( \"tags\" , {})) return data async def get_bot ( self ) -> Optional [ \"Member\" ]: \"\"\" Get the bot associated with this role if any. Returns: Member object if any \"\"\" if self . _bot_id is None : return None return await self . _client . cache . get_member ( self . _guild_id , self . _bot_id ) @property def default ( self ) -> bool : \"\"\"Is this the `@everyone` role\"\"\" return self . id == self . _guild_id @property def bot_managed ( self ) -> bool : \"\"\"Is this role owned/managed by a bot\"\"\" return self . bot_id is not None @property def mention ( self ) -> str : \"\"\"Returns a string that would mention the role\"\"\" return f \"<@& { self . id } >\" @property def integration ( self ) -> bool : \"\"\"Is this role owned/managed by a integration\"\"\" return self . tags . integration_id is not None async def is_assignable ( self ) -> bool : \"\"\"Can this role be assigned or removed by this bot? !!! note: This does not account for permissions, only the role hierarchy\"\"\" me = await self . guild . me if ( self . default or await me . top_role . position > self . position ) and not self . managed : return True return False async def delete ( self , reason : str = None ): \"\"\" Delete this role Args: reason: An optional reason for this deletion \"\"\" await self . _client . http . delete_guild_role ( self . _guild_id , self . id , reason ) async def edit ( self , name : str = MISSING , permissions : str = MISSING , color : Union [ int , Color ] = MISSING , hoist : bool = MISSING , mentionable : bool = MISSING , ) -> \"Role\" : \"\"\" Edit this role, all arguments are optional. Args: name: name of the role permissions: New permissions to use color: The color of the role hoist: whether the role should be displayed separately in the sidebar mentionable: whether the role should be mentionable Returns: Role with updated information \"\"\" if isinstance ( color , Color ): color = color . value payload = dict_filter_missing ( dict ( name = name , permissions = permissions , color = color , hoist = hoist , mentionable = mentionable ) ) r_data = await self . _client . http . modify_guild_role ( self . _guild_id , self . id , payload ) r_data [ \"guild_id\" ] = self . _guild_id return self . from_dict ( r_data , self . _client ) async get_bot ( self ) \u00b6 Get the bot associated with this role if any. Returns: Type Description Optional[Member] Member object if any Source code in dis_snek/models/discord_objects/role.py async def get_bot ( self ) -> Optional [ \"Member\" ]: \"\"\" Get the bot associated with this role if any. Returns: Member object if any \"\"\" if self . _bot_id is None : return None return await self . _client . cache . get_member ( self . _guild_id , self . _bot_id ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: property readonly default : bool \u00b6 Is this the @everyone role inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/role.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) property readonly bot_managed : bool \u00b6 Is this role owned/managed by a bot property readonly mention : str \u00b6 Returns a string that would mention the role property readonly integration : bool \u00b6 Is this role owned/managed by a integration inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/role.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async is_assignable ( self ) \u00b6 Can this role be assigned or removed by this bot? !!! note: This does not account for permissions, only the role hierarchy Source code in dis_snek/models/discord_objects/role.py async def is_assignable ( self ) -> bool : \"\"\"Can this role be assigned or removed by this bot? !!! note: This does not account for permissions, only the role hierarchy\"\"\" me = await self . guild . me if ( self . default or await me . top_role . position > self . position ) and not self . managed : return True return False async delete ( self , reason = None ) \u00b6 Delete this role Parameters: Name Type Description Default reason str An optional reason for this deletion None Source code in dis_snek/models/discord_objects/role.py async def delete ( self , reason : str = None ): \"\"\" Delete this role Args: reason: An optional reason for this deletion \"\"\" await self . _client . http . delete_guild_role ( self . _guild_id , self . id , reason ) async edit ( self , name = MISSING , permissions = MISSING , color = MISSING , hoist = MISSING , mentionable = MISSING ) \u00b6 Edit this role, all arguments are optional. Parameters: Name Type Description Default name str name of the role MISSING permissions str New permissions to use MISSING color Union[int, dis_snek.models.color.Color] The color of the role MISSING hoist bool whether the role should be displayed separately in the sidebar MISSING mentionable bool whether the role should be mentionable MISSING Returns: Type Description Role Role with updated information Source code in dis_snek/models/discord_objects/role.py async def edit ( self , name : str = MISSING , permissions : str = MISSING , color : Union [ int , Color ] = MISSING , hoist : bool = MISSING , mentionable : bool = MISSING , ) -> \"Role\" : \"\"\" Edit this role, all arguments are optional. Args: name: name of the role permissions: New permissions to use color: The color of the role hoist: whether the role should be displayed separately in the sidebar mentionable: whether the role should be mentionable Returns: Role with updated information \"\"\" if isinstance ( color , Color ): color = color . value payload = dict_filter_missing ( dict ( name = name , permissions = permissions , color = color , hoist = hoist , mentionable = mentionable ) ) r_data = await self . _client . http . modify_guild_role ( self . _guild_id , self . id , payload ) r_data [ \"guild_id\" ] = self . _guild_id return self . from_dict ( r_data , self . _client ) StickerTypes ( IntEnum ) \u00b6 Types of sticker. Source code in dis_snek/models/discord_objects/sticker.py class StickerTypes ( IntEnum ): \"\"\"Types of sticker.\"\"\" STANDARD = 1 \"\"\"An official sticker in a pack, part of Nitro or in a removed purchasable pack.\"\"\" GUILD = 2 \"\"\"A sticker uploaded to a Boosted guild for the guild's members.\"\"\" GUILD \u00b6 A sticker uploaded to a Boosted guild for the guild's members. STANDARD \u00b6 An official sticker in a pack, part of Nitro or in a removed purchasable pack. StickerFormatTypes ( IntEnum ) \u00b6 File formats for stickers. Source code in dis_snek/models/discord_objects/sticker.py class StickerFormatTypes ( IntEnum ): \"\"\"File formats for stickers.\"\"\" PNG = 1 APNG = 2 LOTTIE = 3 StickerItem ( DiscordObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/sticker.py @define ( kw_only = False ) class StickerItem ( DiscordObject ): name : str = attr . ib () \"\"\"Name of the sticker.\"\"\" format_type : StickerFormatTypes = attr . ib ( converter = StickerFormatTypes ) \"\"\"Type of sticker image format.\"\"\" attrs-field format_type : StickerFormatTypes \u00b6 Type of sticker image format. attrs-field name : str \u00b6 Name of the sticker. inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/sticker.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/sticker.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) Sticker ( StickerItem ) attrs \u00b6 Represents a sticker that can be sent in messages. Source code in dis_snek/models/discord_objects/sticker.py @define () class Sticker ( StickerItem ): \"\"\"Represents a sticker that can be sent in messages.\"\"\" pack_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) \"\"\"For standard stickers, id of the pack the sticker is from.\"\"\" description : Optional [ str ] = attr . ib ( default = None ) \"\"\"Description of the sticker.\"\"\" tags : str = attr . ib () \"\"\"autocomplete/suggestion tags for the sticker (max 200 characters)\"\"\" type : Union [ StickerTypes , int ] = attr . ib ( converter = StickerTypes ) \"\"\"Type of sticker.\"\"\" available : Optional [ bool ] = attr . ib ( default = True ) \"\"\"Whether this guild sticker can be used, may be false due to loss of Server Boosts.\"\"\" sort_value : Optional [ int ] = attr . ib ( default = None ) \"\"\"The standard sticker's sort order within its pack.\"\"\" _user_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) _guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) async def get_creator ( self ) -> \"User\" : \"\"\" Get the user who created this emoji Returns: User object \"\"\" return await self . _client . cache . get_user ( self . _user_id ) async def get_guild ( self ) -> \"Guild\" : \"\"\" Get the guild associated with this emoji Returns: Guild object \"\"\" return await self . _client . cache . get_guild ( self . _guild_id ) async def edit ( self , name : Optional [ str ] = MISSING , description : Optional [ str ] = MISSING , tags : Optional [ str ] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"Sticker\" : \"\"\" Edit a sticker Args: name: New name of the sticker description: New description of the sticker tags: New tags of the sticker reason: Reason for the edit Returns: The updated sticker instance \"\"\" if not self . _guild_id : raise ValueError ( \"You can only edit guild stickers.\" ) payload = dict_filter_none ( dict ( name = name , description = description , tags = tags )) sticker_data = await self . _client . http . modify_guild_sticker ( payload , self . _guild_id , self . id , reason ) return self . update_from_dict ( sticker_data ) async def delete ( self , reason : Optional [ str ] = MISSING ): \"\"\" Delete a sticker Args: reason: Reason for the deletion Raises: ValueError: If you attempt to delete a non-guild sticker \"\"\" if not self . _guild_id : raise ValueError ( \"You can only delete guild stickers.\" ) await self . _client . http . delete_guild_sticker ( self . _guild_id , self . id , reason ) attrs-field kw_only available : Optional [ bool ] \u00b6 Whether this guild sticker can be used, may be false due to loss of Server Boosts. attrs-field kw_only description : Optional [ str ] \u00b6 Description of the sticker. attrs-field kw_only pack_id : Optional [ Snowflake_Type ] \u00b6 For standard stickers, id of the pack the sticker is from. attrs-field kw_only sort_value : Optional [ int ] \u00b6 The standard sticker's sort order within its pack. attrs-field kw_only tags : str \u00b6 autocomplete/suggestion tags for the sticker (max 200 characters) attrs-field kw_only type : Union [ dis_snek . models . discord_objects . sticker . StickerTypes , int ] \u00b6 Type of sticker. inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/sticker.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) async get_creator ( self ) \u00b6 Get the user who created this emoji Returns: Type Description User User object Source code in dis_snek/models/discord_objects/sticker.py async def get_creator ( self ) -> \"User\" : \"\"\" Get the user who created this emoji Returns: User object \"\"\" return await self . _client . cache . get_user ( self . _user_id ) async get_guild ( self ) \u00b6 Get the guild associated with this emoji Returns: Type Description Guild Guild object Source code in dis_snek/models/discord_objects/sticker.py async def get_guild ( self ) -> \"Guild\" : \"\"\" Get the guild associated with this emoji Returns: Guild object \"\"\" return await self . _client . cache . get_guild ( self . _guild_id ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/sticker.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async edit ( self , name = MISSING , description = MISSING , tags = MISSING , reason = MISSING ) \u00b6 Edit a sticker Parameters: Name Type Description Default name Optional[str] New name of the sticker MISSING description Optional[str] New description of the sticker MISSING tags Optional[str] New tags of the sticker MISSING reason Optional[str] Reason for the edit MISSING Returns: Type Description Sticker The updated sticker instance Source code in dis_snek/models/discord_objects/sticker.py async def edit ( self , name : Optional [ str ] = MISSING , description : Optional [ str ] = MISSING , tags : Optional [ str ] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"Sticker\" : \"\"\" Edit a sticker Args: name: New name of the sticker description: New description of the sticker tags: New tags of the sticker reason: Reason for the edit Returns: The updated sticker instance \"\"\" if not self . _guild_id : raise ValueError ( \"You can only edit guild stickers.\" ) payload = dict_filter_none ( dict ( name = name , description = description , tags = tags )) sticker_data = await self . _client . http . modify_guild_sticker ( payload , self . _guild_id , self . id , reason ) return self . update_from_dict ( sticker_data ) async delete ( self , reason = MISSING ) \u00b6 Delete a sticker Parameters: Name Type Description Default reason Optional[str] Reason for the deletion MISSING Exceptions: Type Description ValueError If you attempt to delete a non-guild sticker Source code in dis_snek/models/discord_objects/sticker.py async def delete ( self , reason : Optional [ str ] = MISSING ): \"\"\" Delete a sticker Args: reason: Reason for the deletion Raises: ValueError: If you attempt to delete a non-guild sticker \"\"\" if not self . _guild_id : raise ValueError ( \"You can only delete guild stickers.\" ) await self . _client . http . delete_guild_sticker ( self . _guild_id , self . id , reason ) StickerPack ( DiscordObject ) attrs \u00b6 Represents a pack of standard stickers. Source code in dis_snek/models/discord_objects/sticker.py @define () class StickerPack ( DiscordObject ): \"\"\"Represents a pack of standard stickers.\"\"\" stickers : List [ \"Sticker\" ] = attr . ib ( factory = list ) \"\"\"The stickers in the pack.\"\"\" name : str = attr . ib () \"\"\"Name of the sticker pack.\"\"\" sku_id : \"Snowflake_Type\" = attr . ib () \"\"\"id of the pack's SKU.\"\"\" cover_sticker_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"id of a sticker in the pack which is shown as the pack's icon.\"\"\" description : str = attr . ib () \"\"\"Description of the sticker pack.\"\"\" banner_asset_id : \"Snowflake_Type\" = attr . ib () # TODO CDN Asset \"\"\"id of the sticker pack's banner image.\"\"\" attrs-field kw_only banner_asset_id : Snowflake_Type \u00b6 id of the sticker pack's banner image. attrs-field kw_only cover_sticker_id : Optional [ Snowflake_Type ] \u00b6 id of a sticker in the pack which is shown as the pack's icon. attrs-field kw_only description : str \u00b6 Description of the sticker pack. attrs-field kw_only name : str \u00b6 Name of the sticker pack. attrs-field kw_only sku_id : Snowflake_Type \u00b6 id of the pack's SKU. attrs-field kw_only stickers : List [ Sticker ] \u00b6 The stickers in the pack. inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/sticker.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/sticker.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) TeamMember ( ClientObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/team.py @define () class TeamMember ( ClientObject ): membership_state : TeamMembershipState = attr . ib ( converter = TeamMembershipState ) # permissions: List[str] = attr.ib(default=[\"*\"]) # disabled until discord adds more team roles team_id : \"Snowflake_Type\" = attr . ib () user : \"User\" = attr . ib () # TODO: cache partial user (avatar, discrim, id, username) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data [ \"user\" ] = client . cache . place_user_data ( data [ \"user\" ]) return data inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/team.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/team.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) Team ( DiscordObject ) attrs \u00b6 Source code in dis_snek/models/discord_objects/team.py @define () class Team ( DiscordObject ): icon : Optional [ Asset ] = attr . ib ( default = None ) members : List [ TeamMember ] = attr . ib ( factory = list ) name : str = attr . ib () owner_user_id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data [ \"members\" ] = [ TeamMember . from_dict ( member , client ) for member in data [ \"members\" ]] if data [ \"icon\" ]: data [ \"icon\" ] = Asset . from_path_hash ( client , f \"team-icons/ { data [ 'id' ] } / {{}} .png\" , data [ \"icon\" ]) return data @property def owner ( self ) -> \"User\" : return self . _client . cache . user_cache . get ( self . owner_user_id ) def is_in_team ( self , user : Union [ \"SnowflakeObject\" , \"Snowflake_Type\" ]) -> bool : \"\"\" Returns True if the passed user or ID is a member within the team. Args: user: The user or user ID to check Returns: Boolean indicating whether the user is in the team \"\"\" return to_snowflake ( user ) in [ m . id for m in self . members ] is_in_team ( self , user ) \u00b6 Returns True if the passed user or ID is a member within the team. Parameters: Name Type Description Default user Union[SnowflakeObject, Snowflake_Type] The user or user ID to check required Returns: Type Description bool Boolean indicating whether the user is in the team Source code in dis_snek/models/discord_objects/team.py def is_in_team ( self , user : Union [ \"SnowflakeObject\" , \"Snowflake_Type\" ]) -> bool : \"\"\" Returns True if the passed user or ID is a member within the team. Args: user: The user or user ID to check Returns: Boolean indicating whether the user is in the team \"\"\" return to_snowflake ( user ) in [ m . id for m in self . members ] inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/team.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/team.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) ThreadMember ( DiscordObject , SendMixin ) attrs \u00b6 A thread member is used to indicate whether a user has joined a thread or not. Source code in dis_snek/models/discord_objects/thread.py @define () class ThreadMember ( DiscordObject , SendMixin ): \"\"\"A thread member is used to indicate whether a user has joined a thread or not.\"\"\" join_timestamp : Timestamp = field ( converter = timestamp_converter ) \"\"\"The time the current user last joined the thread.\"\"\" flags : int = field () \"\"\"Any user-thread settings, currently only used for notifications.\"\"\" _user_id : \"Snowflake_Type\" = field ( converter = optional ( to_snowflake )) async def get_thread ( self ) -> \"TYPE_THREAD_CHANNEL\" : \"\"\" Gets the thread associated with with this member. Returns: The thread in question \"\"\" return await self . _client . get_channel ( self . id ) async def get_user ( self ) -> \"User\" : \"\"\" Get the user associated with this thread member. Returns: The user object \"\"\" return await self . _client . get_user ( self . _user_id ) async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : dm_id = await self . _client . cache . get_dm_channel_id ( self . _user_id ) return await self . _client . http . create_message ( message_payload , dm_id ) attrs-field kw_only flags : int \u00b6 Any user-thread settings, currently only used for notifications. attrs-field kw_only join_timestamp : Timestamp \u00b6 The time the current user last joined the thread. async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/thread.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) async get_thread ( self ) \u00b6 Gets the thread associated with with this member. Returns: Type Description TYPE_THREAD_CHANNEL The thread in question Source code in dis_snek/models/discord_objects/thread.py async def get_thread ( self ) -> \"TYPE_THREAD_CHANNEL\" : \"\"\" Gets the thread associated with with this member. Returns: The thread in question \"\"\" return await self . _client . get_channel ( self . id ) async get_user ( self ) \u00b6 Get the user associated with this thread member. Returns: Type Description User The user object Source code in dis_snek/models/discord_objects/thread.py async def get_user ( self ) -> \"User\" : \"\"\" Get the user associated with this thread member. Returns: The user object \"\"\" return await self . _client . get_user ( self . _user_id ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/thread.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/thread.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) ThreadList ( ClientObject ) attrs \u00b6 Represents a list of one or more threads. Source code in dis_snek/models/discord_objects/thread.py @define class ThreadList ( ClientObject ): \"\"\"Represents a list of one or more threads.\"\"\" threads : List [ \"TYPE_THREAD_CHANNEL\" ] = field ( factory = list ) # TODO Reference the cache or store actual object? \"\"\"The active threads.\"\"\" members : List [ ThreadMember ] = field ( factory = list ) \"\"\"A thread member object for each returned thread the current user has joined.\"\"\" has_more : bool = field ( default = False ) \"\"\"Whether there are potentially additional threads that could be returned on a subsequent call.\"\"\" @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: threads = [] for thread_data in data [ \"threads\" ]: threads . append ( client . cache . place_channel_data ( thread_data )) data [ \"threads\" ] = threads members = [] for member_data in data [ \"members\" ]: members . append ( ThreadMember . from_dict ( member_data , client )) data [ \"members\" ] = threads return data attrs-field kw_only has_more : bool \u00b6 Whether there are potentially additional threads that could be returned on a subsequent call. attrs-field kw_only members : List [ dis_snek . models . discord_objects . thread . ThreadMember ] \u00b6 A thread member object for each returned thread the current user has joined. attrs-field kw_only threads : List [ TYPE_THREAD_CHANNEL ] \u00b6 The active threads. inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/thread.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/thread.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) BaseUser ( DiscordObject , _SendDMMixin ) attrs \u00b6 Base class for User, essentially partial user discord model Source code in dis_snek/models/discord_objects/user.py @define () class BaseUser ( DiscordObject , _SendDMMixin ): \"\"\"Base class for User, essentially partial user discord model\"\"\" username : str = field ( repr = True , metadata = docs ( \"The user's username, not unique across the platform\" )) discriminator : int = field ( repr = True , metadata = docs ( \"The user's 4-digit discord-tag\" )) avatar : \"Asset\" = field ( metadata = docs ( \"The user's default avatar\" )) def __str__ ( self ): return self . tag @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data [ \"avatar\" ] = Asset . from_path_hash ( client , f \"avatars/ { data [ 'id' ] } / {{}} \" , data [ \"avatar\" ]) return data @property def tag ( self ) -> str : \"\"\"Returns the user's Discord tag\"\"\" return f \" { self . username } # { self . discriminator } \" @property def mention ( self ) -> str : \"\"\"Returns a string that would mention the user\"\"\" return f \"<@ { self . id } >\" @property def display_name ( self ) -> str : \"\"\"The users display name, will return nickname if one is set, otherwise will return username\"\"\" return self . username # for duck-typing compatibility with Member async def get_dm ( self ) -> \"DM\" : \"\"\"Get the DM channel associated with this user.\"\"\" return await self . _client . cache . get_channel ( self . id ) # noqa @property def mutual_guilds ( self ) -> List [ \"Guild\" ]: \"\"\"Get a list of mutual guilds shared between this user and the client.\"\"\" # should user_guilds be its own property? return [ g for g in self . _client . guilds if g . id in self . user_guilds ] attrs-field kw_only avatar : Asset \u00b6 The user's default avatar attrs-field kw_only discriminator : int \u00b6 The user's 4-digit discord-tag attrs-field kw_only username : str \u00b6 The user's username, not unique across the platform async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/user.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: property readonly tag : str \u00b6 Returns the user's Discord tag property readonly mention : str \u00b6 Returns a string that would mention the user inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/user.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) property readonly display_name : str \u00b6 The users display name, will return nickname if one is set, otherwise will return username async get_dm ( self ) \u00b6 Get the DM channel associated with this user. Source code in dis_snek/models/discord_objects/user.py async def get_dm ( self ) -> \"DM\" : \"\"\"Get the DM channel associated with this user.\"\"\" return await self . _client . cache . get_channel ( self . id ) # noqa property readonly mutual_guilds : List [ Guild ] \u00b6 Get a list of mutual guilds shared between this user and the client. inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/user.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) User ( BaseUser ) attrs \u00b6 Source code in dis_snek/models/discord_objects/user.py @define () class User ( BaseUser ): bot : bool = field ( repr = True , default = False , metadata = docs ( \"Is this user a bot?\" )) system : bool = field ( default = False , metadata = docs ( \"whether the user is an Official Discord System user (part of the urgent message system)\" ), ) public_flags : \"UserFlags\" = field ( repr = True , default = 0 , converter = UserFlags , metadata = docs ( \"The flags associated with this user\" ) ) premium_type : \"PremiumTypes\" = field ( default = 0 , converter = PremiumTypes , metadata = docs ( \"The type of nitro subscription on a user's account\" ) ) banner : Optional [ \"Asset\" ] = field ( default = None , metadata = docs ( \"The user's banner\" )) accent_color : Optional [ \"Color\" ] = field ( default = None , converter = optional_c ( Color ), metadata = docs ( \"The user's banner color\" ), ) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data = super () . _process_dict ( data , client ) if \"banner\" in data : data [ \"banner\" ] = Asset . from_path_hash ( client , f \"banners/ { data [ 'id' ] } / {{}} \" , data [ \"banner\" ]) return data attrs-field kw_only accent_color : Optional [ Color ] \u00b6 The user's banner color attrs-field inherited kw_only avatar : Asset \u00b6 The user's default avatar attrs-field kw_only banner : Optional [ Asset ] \u00b6 The user's banner attrs-field kw_only bot : bool \u00b6 Is this user a bot? attrs-field inherited kw_only discriminator : int \u00b6 The user's 4-digit discord-tag attrs-field kw_only premium_type : PremiumTypes \u00b6 The type of nitro subscription on a user's account attrs-field kw_only public_flags : UserFlags \u00b6 The flags associated with this user attrs-field kw_only system : bool \u00b6 whether the user is an Official Discord System user (part of the urgent message system) attrs-field inherited kw_only username : str \u00b6 The user's username, not unique across the platform async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/user.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited property readonly tag : str \u00b6 Returns the user's Discord tag inherited property readonly mention : str \u00b6 Returns a string that would mention the user inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/user.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited property readonly display_name : str \u00b6 The users display name, will return nickname if one is set, otherwise will return username async inherited get_dm ( self ) \u00b6 Get the DM channel associated with this user. Source code in dis_snek/models/discord_objects/user.py async def get_dm ( self ) -> \"DM\" : \"\"\"Get the DM channel associated with this user.\"\"\" return await self . _client . cache . get_channel ( self . id ) # noqa inherited property readonly mutual_guilds : List [ Guild ] \u00b6 Get a list of mutual guilds shared between this user and the client. inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/user.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) SnakeBotUser ( User ) attrs \u00b6 Source code in dis_snek/models/discord_objects/user.py @define () class SnakeBotUser ( User ): verified : bool = field ( repr = True , metadata = { \"docs\" : \"\" }) mfa_enabled : bool = field ( default = False , metadata = { \"docs\" : \"\" }) email : Optional [ str ] = field ( default = None , metadata = { \"docs\" : \"\" }) # needs special permissions? locale : Optional [ str ] = field ( default = None , metadata = { \"docs\" : \"\" }) bio : Optional [ str ] = field ( default = None , metadata = { \"docs\" : \"\" }) flags : \"UserFlags\" = field ( default = 0 , converter = UserFlags , metadata = { \"docs\" : \"\" }) _guild_ids : Set [ str ] = field ( factory = set , metadata = { \"docs\" : \"\" }) def _add_guilds ( self , guild_ids : Set [ \"Snowflake_Type\" ]): self . _guild_ids |= guild_ids @property def guilds ( self ) -> List [ \"Guild\" ]: return [ self . _client . cache . guild_cache . get ( g_id ) for g_id in self . _guild_ids ] async def edit ( self , username : Optional [ str ] = None , avatar : Optional [ bytes ] = MISSING ): \"\"\" Edit the client's user. You can either change the username, or avatar, or both at once. `avatar` may be set to `None` to remove your bot's avatar ??? Hint \"Example Usage:\" ```python f = open(\"path_to_file\", \"rb\") await self.user.edit(avatar=f.read()) ``` or ```python await self.user.edit(username=\"hello world\") ``` Args: username: The username you want to use avatar: The avatar to use, must be `bytes` (see example) Raises: TooManyChanges: If you change the profile too many times \"\"\" payload = {} if username : payload [ \"username\" ] = username if avatar : payload [ \"avatar\" ] = _bytes_to_base64_data ( avatar ) # noqa elif avatar is None : payload [ \"avatar\" ] = None try : resp = await self . _client . http . modify_client_user ( payload ) except HTTPException : raise TooManyChanges ( \"You have changed your profile too frequently, you need to wait a while before trying again.\" ) from None if resp : self . _client . cache . place_user_data ( resp ) attrs-field inherited kw_only accent_color : Optional [ Color ] \u00b6 The user's banner color attrs-field inherited kw_only avatar : Asset \u00b6 The user's default avatar attrs-field inherited kw_only banner : Optional [ Asset ] \u00b6 The user's banner attrs-field inherited kw_only bot : bool \u00b6 Is this user a bot? attrs-field inherited kw_only discriminator : int \u00b6 The user's 4-digit discord-tag attrs-field inherited kw_only premium_type : PremiumTypes \u00b6 The type of nitro subscription on a user's account attrs-field inherited kw_only public_flags : UserFlags \u00b6 The flags associated with this user attrs-field inherited kw_only system : bool \u00b6 whether the user is an Official Discord System user (part of the urgent message system) attrs-field inherited kw_only username : str \u00b6 The user's username, not unique across the platform async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/user.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited property readonly tag : str \u00b6 Returns the user's Discord tag inherited property readonly mention : str \u00b6 Returns a string that would mention the user inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/user.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited property readonly display_name : str \u00b6 The users display name, will return nickname if one is set, otherwise will return username async inherited get_dm ( self ) \u00b6 Get the DM channel associated with this user. Source code in dis_snek/models/discord_objects/user.py async def get_dm ( self ) -> \"DM\" : \"\"\"Get the DM channel associated with this user.\"\"\" return await self . _client . cache . get_channel ( self . id ) # noqa inherited property readonly mutual_guilds : List [ Guild ] \u00b6 Get a list of mutual guilds shared between this user and the client. inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/user.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async edit ( self , username = None , avatar = MISSING ) \u00b6 Edit the client's user. You can either change the username, or avatar, or both at once. avatar may be set to None to remove your bot's avatar Example Usage: 1 2 f = open ( \"path_to_file\" , \"rb\" ) await self . user . edit ( avatar = f . read ()) or 1 await self . user . edit ( username = \"hello world\" ) Parameters: Name Type Description Default username Optional[str] The username you want to use None avatar Optional[bytes] The avatar to use, must be bytes (see example) MISSING Exceptions: Type Description TooManyChanges If you change the profile too many times Source code in dis_snek/models/discord_objects/user.py async def edit ( self , username : Optional [ str ] = None , avatar : Optional [ bytes ] = MISSING ): \"\"\" Edit the client's user. You can either change the username, or avatar, or both at once. `avatar` may be set to `None` to remove your bot's avatar ??? Hint \"Example Usage:\" ```python f = open(\"path_to_file\", \"rb\") await self.user.edit(avatar=f.read()) ``` or ```python await self.user.edit(username=\"hello world\") ``` Args: username: The username you want to use avatar: The avatar to use, must be `bytes` (see example) Raises: TooManyChanges: If you change the profile too many times \"\"\" payload = {} if username : payload [ \"username\" ] = username if avatar : payload [ \"avatar\" ] = _bytes_to_base64_data ( avatar ) # noqa elif avatar is None : payload [ \"avatar\" ] = None try : resp = await self . _client . http . modify_client_user ( payload ) except HTTPException : raise TooManyChanges ( \"You have changed your profile too frequently, you need to wait a while before trying again.\" ) from None if resp : self . _client . cache . place_user_data ( resp ) Member ( DiscordObject , _SendDMMixin ) attrs \u00b6 Source code in dis_snek/models/discord_objects/user.py @attr . s ( ** { k : v for k , v in class_defaults . items () if k != \"on_setattr\" }) class Member ( DiscordObject , _SendDMMixin ): bot : bool = field ( repr = True , default = False , metadata = docs ( \"Is this user a bot?\" )) nick : Optional [ str ] = field ( repr = True , default = None , metadata = docs ( \"The user's nickname in this guild'\" )) deaf : bool = field ( default = False , metadata = docs ( \"Has this user been deafened in voice channels?\" )) mute : bool = field ( default = False , metadata = docs ( \"Has this user been muted in voice channels?\" )) joined_at : \"Timestamp\" = field ( converter = timestamp_converter , metadata = docs ( \"When the user joined this guild\" )) premium_since : Optional [ \"Timestamp\" ] = field ( default = None , converter = optional_c ( timestamp_converter ), metadata = docs ( \"When the user started boosting the guild\" ), ) pending : Optional [ bool ] = field ( default = None , metadata = docs ( \"Whether the user has **not** passed guild's membership screening requirements\" ) ) guild_avatar : \"Asset\" = field ( default = None , metadata = docs ( \"The user's guild avatar\" )) _guild_id : \"Snowflake_Type\" = field ( repr = True , metadata = docs ( \"The ID of the guild\" )) _role_ids : List [ \"Snowflake_Type\" ] = field ( factory = list , converter = list_converter ( to_snowflake ), metadata = docs ( \"The roles IDs this user has\" ) ) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: if \"user\" in data : user_data = data . pop ( \"user\" ) client . cache . place_user_data ( user_data ) data [ \"id\" ] = user_data [ \"id\" ] data [ \"bot\" ] = user_data . get ( \"bot\" , False ) elif \"member\" in data : member_data = data . pop ( \"member\" ) client . cache . place_user_data ( data ) member_data [ \"id\" ] = data [ \"id\" ] member_data [ \"bot\" ] = data . get ( \"bot\" , False ) if \"guild_id\" not in member_data : member_data [ \"guild_id\" ] = data . get ( \"guild_id\" ) data = member_data if data . get ( \"avatar\" ): try : data [ \"guild_avatar\" ] = Asset . from_path_hash ( client , f \"guilds/ { data [ 'guild_id' ] } /users/ { data [ 'id' ] } /avatars/ {{}} \" , data . pop ( \"avatar\" , None ) ) except Exception as e : log . warning ( f \"[DEBUG NEEDED - REPORT THIS] Incomplete dictionary has been passed to member object: { e } \" ) raise data [ \"role_ids\" ] = data . pop ( \"roles\" , []) return data def update_from_dict ( self , data ): if \"guild_id\" not in data : data [ \"guild_id\" ] = self . _guild_id data [ \"_role_ids\" ] = data . pop ( \"roles\" , []) return super () . update_from_dict ( data ) @property def user ( self ): \"\"\"Returns this member's user object\"\"\" return self . _client . cache . user_cache . get ( self . id ) def __str__ ( self ): return self . user . tag def __getattr__ ( self , name ): # this allows for transparent access to user attributes try : return getattr ( self . user , name ) except AttributeError : raise AttributeError ( f \"Neither `User` or `Member` have attribute { name } \" ) def __setattr__ ( self , key , value ): # this allows for transparent access to user attributes if attrib := getattr ( self . __attrs_attrs__ , key ): value = attr . setters . convert ( self , attrib , value ) value = attr . setters . validate ( self , attrib , value ) super ( Member , self ) . __setattr__ ( key , value ) @property def nickname ( self ): \"\"\"alias for nick\"\"\" return self . nick @nickname . setter def nickname ( self , nickname ): self . nick = nickname @property def guild ( self ) -> \"Guild\" : return self . _client . cache . guild_cache . get ( self . _guild_id ) @property def roles ( self ) -> List [ \"Role\" ]: return [ r for r in self . guild . roles if r . id in self . _role_ids ] @property def top_role ( self ) -> \"Role\" : return self . _client . cache . role_cache . get ( self . _role_ids [ - 1 ]) @property def display_name ( self ) -> str : \"\"\"The users display name, will return nickname if one is set, otherwise will return username\"\"\" return self . nickname or self . username @property def display_avatar ( self ): \"\"\"The users displayed avatar, will return `guild_avatar` if one is set, otherwise will return user avatar\"\"\" return self . guild_avatar or self . user . avatar @property def premium ( self ) -> bool : \"\"\"Is this member a server booster?\"\"\" return self . premium_since is not None async def guild_permissions ( self ) -> Permissions : \"\"\" Returns the permissions this member has in the guild Returns: Permission data \"\"\" guild = self . guild if guild . is_owner ( self ): return Permissions . ALL role_everyone = guild . default_role # get @everyone role permissions = role_everyone . permissions for role in self . roles : permissions |= role . permissions if Permissions . ADMINISTRATOR in permissions : return Permissions . ALL return permissions async def has_permission ( self , * permissions : Permissions ) -> bool : \"\"\" Checks if the member has all the given permission(s). ??? Hint \"Example Usage:\" Two different styles can be used to call this method. ```python await member.has_permission(Permissions.KICK_MEMBERS, Permissions.BAN_MEMBERS) ``` ```python await member.has_permission(Permissions.KICK_MEMBERS | Permissions.BAN_MEMBERS) ``` If `member` has both permissions, `True` gets returned. Args: permissions: The permission(s) to check whether the user has it. \"\"\" # Get the user's permissions guild_permissions = await self . guild_permissions () # Check all permissions separately for permission in permissions : if permission not in guild_permissions : return False return True async def channel_permissions ( self , channel : \"TYPE_GUILD_CHANNEL\" ) -> Permissions : \"\"\" Returns the permissions this member has in a channel. Args: channel: The channel in question Returns: Permissions data \"\"\" permissions = await self . guild_permissions () if Permissions . ADMINISTRATOR in permissions : return Permissions . ALL # Find (@everyone) role overwrite and apply it. overwrites = channel . _permission_overwrites if overwrite_everyone := overwrites . get ( channel . _guild_id ): permissions &= ~ overwrite_everyone . deny permissions |= overwrite_everyone . allow # Apply role specific overwrites. allow = Permissions . NONE deny = Permissions . NONE for role_id in self . roles . ids : if overwrite_role := overwrites . get ( role_id ): allow |= overwrite_role . allow deny |= overwrite_role . deny permissions &= ~ deny permissions |= allow # Apply member specific overwrite if it exist. if overwrite_member := overwrites . get ( self . id ): permissions &= ~ overwrite_member . deny permissions |= overwrite_member . allow return permissions async def edit_nickname ( self , new_nickname : str ): \"\"\" Change the user's nickname. Args: new_nickname: The new nickname to apply. \"\"\" return await self . _client . http . modify_guild_member ( self . _guild_id , self . id , nickname = new_nickname ) async def add_role ( self , role : Union [ Snowflake_Type , Role ], reason : str = MISSING ): \"\"\" Add a role to this member. Args: role: The role to add reason: The reason for adding this role \"\"\" role = to_snowflake ( role ) return await self . _client . http . add_guild_member_role ( self . _guild_id , self . id , role , reason = reason ) async def remove_role ( self , role : Union [ Snowflake_Type , Role ], reason : str = MISSING ): \"\"\" Remove a role from this user. Args: role: The role to remove reason: The reason for this removal \"\"\" if isinstance ( role , Role ): role = role . id return await self . _client . http . remove_guild_member_role ( self . _guild_id , self . id , role , reason = reason ) async def has_role ( self , * roles : Union [ Snowflake_Type , Role ]) -> bool : \"\"\" Checks if the user has the given role(s) Args: roles: The role(s) to check whether the user has it. \"\"\" for role in roles : role_id = to_snowflake ( role ) if role_id not in self . _role_ids : return False return True async def kick ( self , reason : str = MISSING ): \"\"\" Remove a member from the guild. Args: reason: The reason for this removal \"\"\" return await self . _client . http . remove_guild_member ( self . _guild_id , self . id ) async def ban ( self , delete_message_days = 0 , reason : str = MISSING ): \"\"\" Ban a member from the guild. Args: delete_message_days: The number of days of messages to delete reason: The reason for this ban \"\"\" return await self . _client . http . create_guild_ban ( self . _guild_id , self . id , delete_message_days , reason = reason ) attrs-field kw_only bot : bool \u00b6 Is this user a bot? attrs-field kw_only deaf : bool \u00b6 Has this user been deafened in voice channels? attrs-field kw_only guild_avatar : Asset \u00b6 The user's guild avatar attrs-field kw_only joined_at : Timestamp \u00b6 When the user joined this guild attrs-field kw_only mute : bool \u00b6 Has this user been muted in voice channels? attrs-field kw_only nick : Optional [ str ] \u00b6 The user's nickname in this guild' attrs-field kw_only pending : Optional [ bool ] \u00b6 Whether the user has not passed guild's membership screening requirements attrs-field kw_only premium_since : Optional [ Timestamp ] \u00b6 When the user started boosting the guild async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/discord_objects/user.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/user.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/user.py def update_from_dict ( self , data ): if \"guild_id\" not in data : data [ \"guild_id\" ] = self . _guild_id data [ \"_role_ids\" ] = data . pop ( \"roles\" , []) return super () . update_from_dict ( data ) property readonly user \u00b6 Returns this member's user object property writable nickname \u00b6 alias for nick property readonly display_name : str \u00b6 The users display name, will return nickname if one is set, otherwise will return username property readonly display_avatar \u00b6 The users displayed avatar, will return guild_avatar if one is set, otherwise will return user avatar property readonly premium : bool \u00b6 Is this member a server booster? async guild_permissions ( self ) \u00b6 Returns the permissions this member has in the guild Returns: Type Description Permissions Permission data Source code in dis_snek/models/discord_objects/user.py async def guild_permissions ( self ) -> Permissions : \"\"\" Returns the permissions this member has in the guild Returns: Permission data \"\"\" guild = self . guild if guild . is_owner ( self ): return Permissions . ALL role_everyone = guild . default_role # get @everyone role permissions = role_everyone . permissions for role in self . roles : permissions |= role . permissions if Permissions . ADMINISTRATOR in permissions : return Permissions . ALL return permissions async has_permission ( self , * permissions ) \u00b6 Checks if the member has all the given permission(s). Example Usage: Two different styles can be used to call this method. 1 await member . has_permission ( Permissions . KICK_MEMBERS , Permissions . BAN_MEMBERS ) 1 await member . has_permission ( Permissions . KICK_MEMBERS | Permissions . BAN_MEMBERS ) If member has both permissions, True gets returned. Parameters: Name Type Description Default permissions Permissions The permission(s) to check whether the user has it. () Source code in dis_snek/models/discord_objects/user.py async def has_permission ( self , * permissions : Permissions ) -> bool : \"\"\" Checks if the member has all the given permission(s). ??? Hint \"Example Usage:\" Two different styles can be used to call this method. ```python await member.has_permission(Permissions.KICK_MEMBERS, Permissions.BAN_MEMBERS) ``` ```python await member.has_permission(Permissions.KICK_MEMBERS | Permissions.BAN_MEMBERS) ``` If `member` has both permissions, `True` gets returned. Args: permissions: The permission(s) to check whether the user has it. \"\"\" # Get the user's permissions guild_permissions = await self . guild_permissions () # Check all permissions separately for permission in permissions : if permission not in guild_permissions : return False return True async channel_permissions ( self , channel ) \u00b6 Returns the permissions this member has in a channel. Parameters: Name Type Description Default channel TYPE_GUILD_CHANNEL The channel in question required Returns: Type Description Permissions Permissions data Source code in dis_snek/models/discord_objects/user.py async def channel_permissions ( self , channel : \"TYPE_GUILD_CHANNEL\" ) -> Permissions : \"\"\" Returns the permissions this member has in a channel. Args: channel: The channel in question Returns: Permissions data \"\"\" permissions = await self . guild_permissions () if Permissions . ADMINISTRATOR in permissions : return Permissions . ALL # Find (@everyone) role overwrite and apply it. overwrites = channel . _permission_overwrites if overwrite_everyone := overwrites . get ( channel . _guild_id ): permissions &= ~ overwrite_everyone . deny permissions |= overwrite_everyone . allow # Apply role specific overwrites. allow = Permissions . NONE deny = Permissions . NONE for role_id in self . roles . ids : if overwrite_role := overwrites . get ( role_id ): allow |= overwrite_role . allow deny |= overwrite_role . deny permissions &= ~ deny permissions |= allow # Apply member specific overwrite if it exist. if overwrite_member := overwrites . get ( self . id ): permissions &= ~ overwrite_member . deny permissions |= overwrite_member . allow return permissions async edit_nickname ( self , new_nickname ) \u00b6 Change the user's nickname. Parameters: Name Type Description Default new_nickname str The new nickname to apply. required Source code in dis_snek/models/discord_objects/user.py async def edit_nickname ( self , new_nickname : str ): \"\"\" Change the user's nickname. Args: new_nickname: The new nickname to apply. \"\"\" return await self . _client . http . modify_guild_member ( self . _guild_id , self . id , nickname = new_nickname ) async add_role ( self , role , reason = MISSING ) \u00b6 Add a role to this member. Parameters: Name Type Description Default role Union[str, int, dis_snek.models.discord_objects.role.Role] The role to add required reason str The reason for adding this role MISSING Source code in dis_snek/models/discord_objects/user.py async def add_role ( self , role : Union [ Snowflake_Type , Role ], reason : str = MISSING ): \"\"\" Add a role to this member. Args: role: The role to add reason: The reason for adding this role \"\"\" role = to_snowflake ( role ) return await self . _client . http . add_guild_member_role ( self . _guild_id , self . id , role , reason = reason ) async remove_role ( self , role , reason = MISSING ) \u00b6 Remove a role from this user. Parameters: Name Type Description Default role Union[str, int, dis_snek.models.discord_objects.role.Role] The role to remove required reason str The reason for this removal MISSING Source code in dis_snek/models/discord_objects/user.py async def remove_role ( self , role : Union [ Snowflake_Type , Role ], reason : str = MISSING ): \"\"\" Remove a role from this user. Args: role: The role to remove reason: The reason for this removal \"\"\" if isinstance ( role , Role ): role = role . id return await self . _client . http . remove_guild_member_role ( self . _guild_id , self . id , role , reason = reason ) async has_role ( self , * roles ) \u00b6 Checks if the user has the given role(s) Parameters: Name Type Description Default roles Union[str, int, dis_snek.models.discord_objects.role.Role] The role(s) to check whether the user has it. () Source code in dis_snek/models/discord_objects/user.py async def has_role ( self , * roles : Union [ Snowflake_Type , Role ]) -> bool : \"\"\" Checks if the user has the given role(s) Args: roles: The role(s) to check whether the user has it. \"\"\" for role in roles : role_id = to_snowflake ( role ) if role_id not in self . _role_ids : return False return True async kick ( self , reason = MISSING ) \u00b6 Remove a member from the guild. Parameters: Name Type Description Default reason str The reason for this removal MISSING Source code in dis_snek/models/discord_objects/user.py async def kick ( self , reason : str = MISSING ): \"\"\" Remove a member from the guild. Args: reason: The reason for this removal \"\"\" return await self . _client . http . remove_guild_member ( self . _guild_id , self . id ) async ban ( self , delete_message_days = 0 , reason = MISSING ) \u00b6 Ban a member from the guild. Parameters: Name Type Description Default delete_message_days The number of days of messages to delete 0 reason str The reason for this ban MISSING Source code in dis_snek/models/discord_objects/user.py async def ban ( self , delete_message_days = 0 , reason : str = MISSING ): \"\"\" Ban a member from the guild. Args: delete_message_days: The number of days of messages to delete reason: The reason for this ban \"\"\" return await self . _client . http . create_guild_ban ( self . _guild_id , self . id , delete_message_days , reason = reason ) WebhookTypes ( IntEnum ) \u00b6 An enumeration. Source code in dis_snek/models/discord_objects/webhooks.py class WebhookTypes ( IntEnum ): INCOMING = 1 \"\"\"Incoming Webhooks can post messages to channels with a generated token\"\"\" CHANNEL_FOLLOWER = 2 \"\"\"Channel Follower Webhooks are internal webhooks used with Channel Following to post new messages into channels\"\"\" APPLICATION = 3 \"\"\"Application webhooks are webhooks used with Interactions\"\"\" APPLICATION \u00b6 Application webhooks are webhooks used with Interactions CHANNEL_FOLLOWER \u00b6 Channel Follower Webhooks are internal webhooks used with Channel Following to post new messages into channels INCOMING \u00b6 Incoming Webhooks can post messages to channels with a generated token Webhook ( DiscordObject , SendMixin ) attrs \u00b6 Source code in dis_snek/models/discord_objects/webhooks.py @define class Webhook ( DiscordObject , SendMixin ): type : WebhookTypes = attr . ib () \"\"\"The type of webhook\"\"\" application_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the bot/OAuth2 application that created this webhook\"\"\" guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the guild id this webhook is for, if any\"\"\" channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the channel id this webhook is for, if any\"\"\" user_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the user this webhook was created by\"\"\" name : Optional [ str ] = attr . ib ( default = None ) \"\"\"the default name of the webhook\"\"\" avatar : Optional [ str ] = attr . ib ( default = None ) \"\"\"the default user avatar hash of the webhook\"\"\" token : str = attr . ib () \"\"\"the secure token of the webhook (returned for Incoming Webhooks)\"\"\" url : Optional [ str ] = attr . ib ( default = None ) \"\"\"the url used for executing the webhook (returned by the webhooks OAuth2 flow)\"\"\" source_guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the guild of the channel that this webhook is following (returned for Channel Follower Webhooks)\"\"\" source_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the channel that this webhook is following (returned for Channel Follower Webhooks)\"\"\" @classmethod async def create ( cls , client : \"Snake\" , channel : Union [ \"Snowflake_Type\" , \"TYPE_MESSAGEABLE_CHANNEL\" ], name : str , avatar : Optional [ bytes ] = MISSING , ) -> \"Webhook\" : \"\"\" Create a webhook. Args: client: The bot's client channel: The channel to create the webhook in name: The name of the webhook avatar: An optional default avatar to use Returns: New webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" if name . lower () == \"clyde\" : raise ValueError ( 'Webhook names cannot be \"Clyde\"' ) if not isinstance ( channel , ( str , int )): channel = to_snowflake ( channel ) if avatar : avatar = _bytes_to_base64_data ( avatar ) data = await client . http . create_webhook ( channel , name , avatar ) new_cls = cls . from_dict ( data , client ) return new_cls @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: if data . get ( \"user\" ): user = client . cache . place_user_data ( data . pop ( \"user\" )) data [ \"user_id\" ] = user . id return data async def delete ( self ) -> None : \"\"\"Delete this webhook\"\"\" await self . _client . http . delete_webhook ( self . id , self . token ) async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : wait = message_payload . pop ( \"wait\" ) return await self . _client . http . execute_webhook ( self . id , self . token , message_payload , wait ) async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , username : str = None , avatar_url : str = None , wait : bool = False , ) -> Optional [ \"Message\" ]: \"\"\" Send a message as this webhook Args: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. username: The username to use avatar_url: The url of an image to use as the avatar wait: Waits for confirmation of delivery. Set this to True if you intend to edit the message Returns: New message object that was sent if `wait` is set to True \"\"\" return await super () . send ( content , embeds , components , stickers , allowed_mentions , reply_to , file , tts , flags , username = username , avatar_url = avatar_url , wait = wait , ) async def edit_message ( self , message : Union [ \"Message\" , \"Snowflake_Type\" ], content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ): message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) msg_data = await self . _client . http . edit_webhook_message ( self . id , self . token , to_snowflake ( message ), message_payload ) if msg_data : return self . _client . cache . place_message_data ( msg_data ) attrs-field kw_only application_id : Optional [ Snowflake_Type ] \u00b6 the bot/OAuth2 application that created this webhook attrs-field kw_only avatar : Optional [ str ] \u00b6 the default user avatar hash of the webhook attrs-field kw_only channel_id : Optional [ Snowflake_Type ] \u00b6 the channel id this webhook is for, if any attrs-field kw_only guild_id : Optional [ Snowflake_Type ] \u00b6 the guild id this webhook is for, if any attrs-field kw_only name : Optional [ str ] \u00b6 the default name of the webhook attrs-field kw_only source_channel_id : Optional [ Snowflake_Type ] \u00b6 the channel that this webhook is following (returned for Channel Follower Webhooks) attrs-field kw_only source_guild_id : Optional [ Snowflake_Type ] \u00b6 the guild of the channel that this webhook is following (returned for Channel Follower Webhooks) attrs-field kw_only token : str \u00b6 the secure token of the webhook (returned for Incoming Webhooks) attrs-field kw_only type : WebhookTypes \u00b6 The type of webhook attrs-field kw_only url : Optional [ str ] \u00b6 the url used for executing the webhook (returned by the webhooks OAuth2 flow) attrs-field kw_only user_id : Optional [ Snowflake_Type ] \u00b6 the user this webhook was created by inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord_objects/webhooks.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) async classmethod create ( client , channel , name , avatar = MISSING ) \u00b6 Create a webhook. Parameters: Name Type Description Default client Snake The bot's client required channel Union[Snowflake_Type, TYPE_MESSAGEABLE_CHANNEL] The channel to create the webhook in required name str The name of the webhook required avatar Optional[bytes] An optional default avatar to use MISSING Returns: Type Description Webhook New webhook Exceptions: Type Description ValueError If you try to name the webhook \"Clyde\" Source code in dis_snek/models/discord_objects/webhooks.py @classmethod async def create ( cls , client : \"Snake\" , channel : Union [ \"Snowflake_Type\" , \"TYPE_MESSAGEABLE_CHANNEL\" ], name : str , avatar : Optional [ bytes ] = MISSING , ) -> \"Webhook\" : \"\"\" Create a webhook. Args: client: The bot's client channel: The channel to create the webhook in name: The name of the webhook avatar: An optional default avatar to use Returns: New webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" if name . lower () == \"clyde\" : raise ValueError ( 'Webhook names cannot be \"Clyde\"' ) if not isinstance ( channel , ( str , int )): channel = to_snowflake ( channel ) if avatar : avatar = _bytes_to_base64_data ( avatar ) data = await client . http . create_webhook ( channel , name , avatar ) new_cls = cls . from_dict ( data , client ) return new_cls inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord_objects/webhooks.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) async delete ( self ) \u00b6 Delete this webhook Source code in dis_snek/models/discord_objects/webhooks.py async def delete ( self ) -> None : \"\"\"Delete this webhook\"\"\" await self . _client . http . delete_webhook ( self . id , self . token ) async send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , username = None , avatar_url = None , wait = False ) \u00b6 Send a message as this webhook Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None username str The username to use None avatar_url str The url of an image to use as the avatar None wait bool Waits for confirmation of delivery. Set this to True if you intend to edit the message False Returns: Type Description Optional[Message] New message object that was sent if wait is set to True Source code in dis_snek/models/discord_objects/webhooks.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , username : str = None , avatar_url : str = None , wait : bool = False , ) -> Optional [ \"Message\" ]: \"\"\" Send a message as this webhook Args: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. username: The username to use avatar_url: The url of an image to use as the avatar wait: Waits for confirmation of delivery. Set this to True if you intend to edit the message Returns: New message object that was sent if `wait` is set to True \"\"\" return await super () . send ( content , embeds , components , stickers , allowed_mentions , reply_to , file , tts , flags , username = username , avatar_url = avatar_url , wait = wait , )","title":"Discord Models"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.application.Application","text":"Represents a discord application. Attributes: Name Type Description name str The name of the application. icon str The icon of the application description str The description of the application rpc_origins List[str] an array of rpc origin urls, if rpc is enabled bot_public bool when false only app owner can join the app's bot to guilds bot_require_code_grant bool when true the app's bot will only join upon completion of the full oauth2 code grant flow terms_of_service_url str the url of the app's terms of service privacy_policy_url str the url of the app's privacy policy owner User partial user object containing info on the owner of the application summary str if this application is a game sold on Discord, this field will be the summary field for the store page of its primary sku verify_key str the hex encoded key for verification in interactions and the GameSDK's GetTicket team Team if the application belongs to a team, this will be a list of the members of that team guild_id Snowflake_Type if this application is a game sold on Discord, this field will be the guild to which it has been linked primary_sku_id Snowflake_Type if this application is a game sold on Discord, this field will be the id of the \"Game SKU\" that is created, if exists slug str if this application is a game sold on Discord, this field will be the URL slug that links to the store page cover_image str the application's default rich presence invite cover image hash flags int the application's public flags Source code in dis_snek/models/discord_objects/application.py @attr . s ( slots = True , kw_only = True ) class Application ( DiscordObject ): \"\"\" Represents a discord application. Attributes: name str: The name of the application. icon str: The icon of the application description str: The description of the application rpc_origins List[str]: an array of rpc origin urls, if rpc is enabled bot_public bool: when false only app owner can join the app's bot to guilds bot_require_code_grant bool: when true the app's bot will only join upon completion of the full oauth2 code grant flow terms_of_service_url str: the url of the app's terms of service privacy_policy_url str: the url of the app's privacy policy owner User : partial user object containing info on the owner of the application summary str: if this application is a game sold on Discord, this field will be the summary field for the store page of its primary sku verify_key str: the hex encoded key for verification in interactions and the GameSDK's GetTicket team Team: if the application belongs to a team, this will be a list of the members of that team guild_id Snowflake_Type: if this application is a game sold on Discord, this field will be the guild to which it has been linked primary_sku_id Snowflake_Type: if this application is a game sold on Discord, this field will be the id of the \"Game SKU\" that is created, if exists slug str: if this application is a game sold on Discord, this field will be the URL slug that links to the store page cover_image str: the application's default rich presence invite cover image hash flags int: the application's public flags \"\"\" name : str = attr . ib () icon : Optional [ Asset ] = attr . ib ( default = None ) description : Optional [ str ] = attr . ib () rpc_origins : Optional [ List [ str ]] = attr . ib ( default = None ) bot_public : bool = attr . ib ( default = True ) bot_require_code_grant : bool = attr . ib ( default = False ) terms_of_service_url : Optional [ str ] = attr . ib ( default = None ) privacy_policy_url : Optional [ str ] = attr . ib ( default = None ) owner_id : Optional [ Snowflake_Type ] = attr . ib ( default = None , converter = optional ( to_snowflake )) summary : str = attr . ib () verify_key : Optional [ str ] = attr . ib ( default = MISSING ) team : Optional [ \"Team\" ] = attr . ib ( default = None ) guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) primary_sku_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) slug : Optional [ str ] = attr . ib ( default = None ) cover_image : Optional [ str ] = attr . ib ( default = None ) flags : Optional [ \"ApplicationFlags\" ] = attr . ib ( default = None , converter = optional ( ApplicationFlags )) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: if data . get ( \"team\" ): data [ \"team\" ] = Team . from_dict ( data [ \"team\" ], client ) data [ \"owner_id\" ] = data [ \"team\" ] . owner_user_id else : if \"owner\" in data : owner = client . cache . place_user_data ( data . pop ( \"owner\" )) data [ \"owner_id\" ] = owner . id if data [ \"icon\" ]: data [ \"icon\" ] = Asset . from_path_hash ( client , f \"app-icons/ { data [ 'id' ] } / {{}} .png\" , data [ \"icon\" ]) return data @property def owner ( self ): return self . _client . cache . user_cache . get ( self . owner_id )","title":"Application"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.asset.Asset","text":"Represents a discord asset. Attributes: Name Type Description BASE str The cdn address for assets url str The URL of this asset hash Optional[str] The hash of this asset Source code in dis_snek/models/discord_objects/asset.py @attr . s ( slots = True ) class Asset : \"\"\" Represents a discord asset. Attributes: BASE str: The `cdn` address for assets url str: The URL of this asset hash Optional[str]: The hash of this asset \"\"\" BASE = \"https://cdn.discordapp.com\" _client : \"Snake\" = attr . field () url : str = attr . field () hash : Optional [ str ] = attr . field ( default = None ) @classmethod def from_path_hash ( cls , client : \"Snake\" , path : str , asset_hash : str ) -> \"Asset\" : url = f \" { cls . BASE } / { path . format ( asset_hash ) } \" return cls ( client = client , url = url , hash = asset_hash ) @property def animated ( self ) -> bool : \"\"\"True if this asset is animated\"\"\" if not self . hash : return None return self . hash . startswith ( \"a_\" ) async def get ( self , extension : Optional [ str ] = None , size : Optional [ int ] = None ) -> bytes : \"\"\" Get the asset from the Discord CDN Args: extension: File extension size: File size Returns: Raw byte array of the file Raises: ValueError: Incorrect file size if not power of 2 between 16 and 4096 \"\"\" if not extension : extension = \".gif\" if self . animated else \".png\" url = self . url if size : if not (( size != 0 ) and ( size & ( size - 1 ) == 0 )): # if not power of 2 raise ValueError ( \"Size should be a power of 2\" ) if not 16 <= size <= 4096 : raise ValueError ( \"Size should be between 16 and 4096\" ) url = f \" { url } ?size= { size } \" url = url + extension return await self . _client . http . request_cdn ( url , self ) async def save ( self , fd : Union [ str , bytes , \"PathLike\" , int ], extension : Optional [ str ] = None , size : Optional [ int ] = None ) -> int : \"\"\" Save the asset to a file Args: fd: File destination extention: File extension size: File size Return: Status code \"\"\" content = await self . get ( extension = extension , size = size ) with open ( fd , \"wb\" ) as f : return f . write ( content )","title":"Asset"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.ChannelHistory","text":"An async iterator for searching through a channel's history Parameters: Name Type Description Default channel BaseChannel The channel to search through required limit The maximum number of messages to return (set to 0 for no limit) 50 before get messages before this message ID None after get messages after this message ID None around get messages \"around\" this message ID None Source code in dis_snek/models/discord_objects/channel.py class ChannelHistory ( AsyncIterator ): \"\"\" An async iterator for searching through a channel's history Args: channel: The channel to search through limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID \"\"\" def __init__ ( self , channel : \"BaseChannel\" , limit = 50 , before = None , after = None , around = None ): self . channel : \"BaseChannel\" = channel self . before : \"Snowflake_Type\" = before self . after : \"Snowflake_Type\" = after self . around : \"Snowflake_Type\" = around super () . __init__ ( limit ) async def fetch ( self ): if self . after : if not self . last : self . last = namedtuple ( \"temp\" , \"id\" ) self . last . id = self . after messages = await self . channel . get_messages ( limit = self . get_limit , after = self . last . id ) messages . sort ( key = lambda x : x . id ) elif self . around : messages = await self . channel . get_messages ( limit = self . get_limit , around = self . around ) # todo: decide how getting *more* messages from `around` would work self . _limit = 1 # stops history from getting more messages else : if self . before and not self . last : self . last = namedtuple ( \"temp\" , \"id\" ) self . last . id = self . before messages = await self . channel . get_messages ( limit = self . get_limit , before = self . last . id ) messages . sort ( key = lambda x : x . id , reverse = True ) return messages","title":"ChannelHistory"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.PermissionOverwrite","text":"Channel Permissions Overwrite object Attributes: Name Type Description type OverwriteTypes Permission overwrite type (role or member) allow Permissions Permissions to allow deny Permissions Permissions to deny Source code in dis_snek/models/discord_objects/channel.py @define () class PermissionOverwrite ( SnowflakeObject ): \"\"\" Channel Permissions Overwrite object Attributes: type: Permission overwrite type (role or member) allow: Permissions to allow deny: Permissions to deny \"\"\" type : \"OverwriteTypes\" = field ( repr = True , converter = OverwriteTypes ) allow : \"Permissions\" = field ( repr = True , converter = Permissions ) deny : \"Permissions\" = field ( repr = True , converter = Permissions )","title":"PermissionOverwrite"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.MessageableMixin","text":"Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class MessageableMixin ( SendMixin ): last_message_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) # TODO May need to think of dynamically updating this. default_auto_archive_duration : int = attr . ib ( default = AutoArchiveDuration . ONE_DAY ) last_pin_timestamp : Optional [ Timestamp ] = attr . ib ( default = None , converter = optional_c ( timestamp_converter )) async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : return await self . _client . http . create_message ( message_payload , self . id ) async def get_message ( self , message_id : \"Snowflake_Type\" ) -> \"Message\" : \"\"\" Fetch a message from the channel. Args: message_id: ID of message to retrieve. Returns: The message object fetched. \"\"\" message_id = to_snowflake ( message_id ) message : \"Message\" = await self . _client . cache . get_message ( self . id , message_id ) return message def history ( self , limit = 100 , before : \"Snowflake_Type\" = None , after : \"Snowflake_Type\" = None , around : \"Snowflake_Type\" = None , ): \"\"\" Get an async iterator for the history of this channel Paramters: limit: The maximum number of messages to return (set to 0 for no limit) before: get messages before this message ID after: get messages after this message ID around: get messages \"around\" this message ID ??? Hint \"Example Usage:\" ```python async for message in channel.history(limit=0): if message.author.id == 174918559539920897: print(\"Found author's message\") # ... break ``` or ```python history = channel.history(limit=250) # Flatten the async iterator into a list messages = await history.flatten() ``` Returns: ChannelHistory (AsyncIterator) \"\"\" return ChannelHistory ( self , limit , before , after , around ) async def get_messages ( self , limit : int = 50 , around : \"Snowflake_Type\" = MISSING , before : \"Snowflake_Type\" = MISSING , after : \"Snowflake_Type\" = MISSING , ) -> List [ \"Message\" ]: \"\"\" Fetch multiple messages from the channel. Args: limit: Max number of messages to return, default `50`, max `100` around: Message to get messages around before: Message to get messages before after: Message to get messages after Returns: A list of messages fetched. \"\"\" if limit > 100 : raise ValueError ( \"You cannot fetch more than 100 messages at once.\" ) if around : around = to_snowflake ( around ) elif before : before = to_snowflake ( before ) elif after : after = to_snowflake ( after ) messages_data = await self . _client . http . get_channel_messages ( self . id , limit , around , before , after ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async def get_pinned_messages ( self ) -> List [ \"Message\" ]: \"\"\" Fetch pinned messages from the channel. Returns: A list of messages fetched. \"\"\" messages_data = await self . _client . http . get_pinned_messages ( self . id ) return [ self . _client . cache . place_message_data ( message_data ) for message_data in messages_data ] async def delete_messages ( self , messages : List [ Union [ \"Snowflake_Type\" , \"Message\" ]], reason : Optional [ str ] = MISSING ) -> None : \"\"\" Bulk delete messages from channel. Args: messages: List of messages or message IDs to delete. reason: The reason for this action. Used for audit logs. \"\"\" message_ids = [ to_snowflake ( message ) for message in messages ] # TODO Add check for min/max and duplicates. if len ( message_ids ) == 1 : # bulk delete messages will throw a http error if only 1 message is passed await self . delete_message ( message_ids [ 0 ], reason ) else : await self . _client . http . bulk_delete_messages ( self . id , message_ids , reason ) async def delete_message ( self , message : Union [ \"Snowflake_Type\" , \"Message\" ], reason : str = None ) -> None : \"\"\" Delete a single message from a channel. Args: message: The message to delete reason: The reason for this action \"\"\" message = to_snowflake ( message ) await self . _client . http . delete_message ( self . id , message , reason = reason ) async def purge ( self , deletion_limit : int = 50 , search_limit : int = 100 , predicate : Callable [[ \"Message\" ], bool ] = MISSING , before : Optional [ \"Snowflake_Type\" ] = MISSING , after : Optional [ \"Snowflake_Type\" ] = MISSING , around : Optional [ \"Snowflake_Type\" ] = MISSING , reason : Optional [ str ] = MISSING , ) -> int : \"\"\" Bulk delete messages within a channel. If a `predicate` is provided, it will be used to determine which messages to delete, otherwise all messages will be deleted within the `deletion_limit` ??? Hint \"Example Usage:\" ```python # this will delete the last 20 messages sent by a user with the given ID deleted = await channel.purge(deletion_limit=20, predicate=lambda m: m.author.id == 174918559539920897) await channel.send(f\"{deleted} messages deleted\") ``` Args: deletion_limit: The target amount of messages to delete search_limit: How many messages to search through predicate: A function that returns True or False, and takes a message as an argument before: Search messages before this ID after: Search messages after this ID around: Search messages around this ID reason: The reason for this deletion Returns: The total amount of messages deleted \"\"\" if not predicate : def predicate ( m ): return True # noqa to_delete = [] # 1209600 14 days ago in seconds, 1420070400000 is used to convert to snowflake fourteen_days_ago = int (( time . time () - 1209600 ) * 1000.0 - DISCORD_EPOCH ) << 22 async for message in self . history ( limit = search_limit , before = before , after = after , around = around ): if deletion_limit != 0 and len ( to_delete ) == deletion_limit : break if not predicate ( message ): # fails predicate continue if message . id < fourteen_days_ago : # message is too old to be purged continue to_delete . append ( message . id ) count = len ( to_delete ) while len ( to_delete ): iteration = [ to_delete . pop () for i in range ( min ( 100 , len ( to_delete )))] await self . delete_messages ( iteration , reason = reason ) return count async def trigger_typing ( self ) -> None : await self . _client . http . trigger_typing_indicator ( self . id )","title":"MessageableMixin"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.InvitableMixin","text":"Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class InvitableMixin : async def create_invite ( self , max_age : int = 86400 , max_uses : int = 0 , temporary : bool = False , unique : bool = False , target_type : Optional [ \"InviteTargetTypes\" ] = None , target_user : Optional [ Union [ \"Snowflake_Type\" , \"User\" ]] = None , target_application : Optional [ Union [ \"Snowflake_Type\" , \"Application\" ]] = None , reason : Optional [ str ] = None , ) -> \"Invite\" : \"\"\" Create channel invite. Args: max_age: Max age of invite in seconds, default 86400 (24 hours). max_uses: Max uses of invite, default 0. temporary: Grants temporary membership, default False. unique: Invite is unique, default false. target_type: Target type for streams and embedded applications. target_user_id: Target User ID for Stream target type. target_application_id: Target Application ID for Embedded App target type. reason: The reason for creating this invite. Returns: Newly created Invite object. \"\"\" if target_type : if target_type == InviteTargetTypes . STREAM and not target_user : raise ValueError ( \"Stream target must include target user id.\" ) elif target_type == InviteTargetTypes . EMBEDDED_APPLICATION and not target_application : raise ValueError ( \"Embedded Application target must include target application id.\" ) if target_user and target_application : raise ValueError ( \"Invite target must be either User or Embedded Application, not both.\" ) elif target_user : target_user = to_snowflake ( target_user ) target_type = InviteTargetTypes . STREAM elif target_application : target_application = to_snowflake ( target_application ) target_type = InviteTargetTypes . EMBEDDED_APPLICATION invite_data = await self . _client . http . create_channel_invite ( self . id , max_age , max_uses , temporary , unique , target_type , target_user , target_application , reason ) return Invite . from_dict ( invite_data , self . _client ) async def get_invites ( self ) -> List [ \"Invite\" ]: \"\"\" Gets all invites (with invite metadata) for the channel. \"\"\" invites_data = await self . _client . http . get_channel_invites ( self . id ) return Invite . from_list ( invites_data , self . _client )","title":"InvitableMixin"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.ThreadableMixin","text":"Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class ThreadableMixin : async def create_thread_with_message ( self , name : str , message : Union [ \"Snowflake_Type\" , \"Message\" ], auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildNewsThread\" , \"GuildPublicThread\" ]: \"\"\" Create a thread connected to a message Args: name: 1-100 character thread name message: The message to connect this thread to auto_archive_duration: Time before the thread will be automatically archived reason: The reason for creating this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , auto_archive_duration = auto_archive_duration , message_id = to_snowflake ( message ), reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async def create_thread_without_message ( self , name : str , thread_type : Union [ ChannelTypes , int ], invitable : Optional [ bool ] = None , auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ) -> Union [ \"GuildPrivateThread\" , \"GuildPublicThread\" ]: \"\"\" Creates a thread without a message source. Args: name: 1-100 character thread name thread_type: Is the thread private or public invitable: whether non-moderators can add other non-moderators to a thread; only available when creating a private thread auto_archive_duration: Time before the thread will be automatically archived reason: The reason to create this thread Returns: The created thread, if successful \"\"\" thread_data = await self . _client . http . create_thread ( channel_id = self . id , name = name , thread_type = thread_type , auto_archive_duration = auto_archive_duration , invitable = invitable , reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async def get_public_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **public** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_public_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async def get_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of **private** threads available in this channel. Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async def get_joined_private_archived_threads ( self , limit : int = None , before : Union [ \"Timestamp\" ] = None ) -> ThreadList : \"\"\" Get a `ThreadList` of threads the bot is a participant of in this channel Args: limit: optional maximum number of threads to return before: Returns threads before this timestamp \"\"\" threads_data = await self . _client . http . list_joined_private_archived_threads ( channel_id = self . id , limit = limit , before = before ) threads_data [ \"id\" ] = self . id return ThreadList . from_dict ( threads_data , self . _client ) async def get_active_threads ( self ) -> List [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\"Returns all active threads in the channel, including public and private threads\"\"\" raw_threads = await self . guild . get_active_threads () if hasattr ( raw_threads , \"threads\" ): return [ t for t in raw_threads . threads if t . parent_channel . id == self . id ] return []","title":"ThreadableMixin"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.WebhookMixin","text":"Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class WebhookMixin : async def create_webhook ( self , name : str , avatar : Optional [ bytes ] = MISSING ) -> Webhook : \"\"\" Create a webhook in this channel Args: name: The name of the webhook avatar: An optional default avatar to use Returns: The created webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" return await Webhook . create ( self . _client , self , name , avatar ) # type: ignore async def delete_webhook ( self , webhook : Webhook ) -> None : \"\"\" Delete a given webhook in this channel Args: webhook: The webhook to delete \"\"\" return await webhook . delete ()","title":"WebhookMixin"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.BaseChannel","text":"Source code in dis_snek/models/discord_objects/channel.py @define ( slots = False ) class BaseChannel ( DiscordObject ): name : Optional [ str ] = field ( default = None ) type : Union [ ChannelTypes , int ] = field ( converter = ChannelTypes ) @classmethod def from_dict_factory ( cls , data : dict , client : \"Snake\" ) -> \"TYPE_ALL_CHANNEL\" : \"\"\" Creates a channel object of the appropriate type Args: data: The channel data. client: The bot. Returns: The new channel object. \"\"\" channel_type = data . get ( \"type\" , None ) channel_class = TYPE_CHANNEL_MAPPING . get ( channel_type , None ) if not channel_class : raise TypeError ( f \"Unsupported channel type for { data } ( { channel_type } ), please consult the docs.\" ) return channel_class . from_dict ( data , client ) @property def mention ( self ) -> str : \"\"\"Returns a string that would mention the channel\"\"\" return f \"<# { self . id } >\" async def _edit ( self , payload : dict , reason : Optional [ str ] = MISSING ) -> None : \"\"\" # TODO Args: payload: reason: Returns: \"\"\" channel_data = self . _client . http . modify_channel ( self . id , payload , reason ) self . update_from_dict ( channel_data ) async def delete ( self , reason : Optional [ str ] = MISSING ) -> None : \"\"\" Delete this channel. Args: reason: The reason for deleting this channel \"\"\" await self . _client . http . delete_channel ( self . id , reason )","title":"BaseChannel"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.DMChannel","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class DMChannel ( BaseChannel , MessageableMixin ): @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data = super () . _process_dict ( data , client ) data [ \"recipients\" ] = [ client . cache . place_user_data ( recipient ) for recipient in data [ \"recipients\" ]] return data async def edit ( self , name : Optional [ str ] = MISSING , icon : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , reason : Optional [ str ] = MISSING , ): payload = dict ( name = name , icon = to_image_data ( icon )) await self . _edit ( payload = payload , reason = reason )","title":"DMChannel"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.DM","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class DM ( DMChannel ): recipient : \"User\" = field () @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data = super () . _process_dict ( data , client ) data [ \"recipient\" ] = data . pop ( \"recipients\" )[ 0 ] client . cache . place_dm_channel_id ( data [ \"recipient\" ], data [ \"id\" ]) return data","title":"DM"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.DMGroup","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class DMGroup ( DMChannel ): owner_id : \"Snowflake_Type\" = attr . ib () application_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) recipients : List [ \"User\" ] = field ( factory = list ) async def get_owner ( self ) -> \"User\" : return await self . _client . cache . get_user ( self . owner_id ) async def add_recipient ( self , user : Union [ \"User\" , \"Snowflake_Type\" ], access_token : str , nickname : Optional [ str ] = MISSING ): user = await self . _client . cache . get_user ( user ) await self . _client . http . group_dm_add_recipient ( self . id , user . id , access_token , nickname ) self . recipients . append ( user ) async def remove_recipient ( self , user : Union [ \"User\" , \"Snowflake_Type\" ]): user = await self . _client . cache . get_user ( user ) await self . _client . http . group_dm_remove_recipient ( self . id , user . id ) self . recipients . remove ( user )","title":"DMGroup"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildChannel","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildChannel ( BaseChannel ): position : Optional [ int ] = attr . ib ( default = 0 ) nsfw : bool = attr . ib ( default = False ) parent_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) _guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) _permission_overwrites : Dict [ \"Snowflake_Type\" , \"PermissionOverwrite\" ] = attr . ib ( factory = list ) @property def guild ( self ): return self . _client . cache . guild_cache . get ( self . _guild_id ) @property def category ( self ): return self . _client . cache . channel_cache . get ( self . parent_id ) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: permission_overwrites = data . get ( \"permission_overwrites\" , []) data [ \"permission_overwrites\" ] = { obj . id : obj for obj in ( PermissionOverwrite ( ** permission ) for permission in permission_overwrites ) } return data async def edit_permission ( self , overwrite : PermissionOverwrite , reason : Optional [ str ] = None ) -> None : await self . _client . http . edit_channel_permission ( self . id , overwrite . id , overwrite . allow , overwrite . deny , overwrite . type , reason # TODO Convert to str...? ) async def delete_permission ( self , target : Union [ \"PermissionOverwrite\" , \"Role\" , \"User\" ], reason : Optional [ str ] = MISSING ): target = to_snowflake ( target ) await self . _client . http . delete_channel_permission ( self . id , target , reason )","title":"GuildChannel"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildCategory","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildCategory ( GuildChannel ): async def edit ( self , name , position , permission_overwrites , reason ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , ) await self . _edit ( payload = payload , reason = reason )","title":"GuildCategory"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildStore","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildStore ( GuildChannel ): async def edit ( self , name , position , permission_overwrites , parent_id , nsfw , reason ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , parent_id = parent_id , nsfw = nsfw , ) await self . _edit ( payload = payload , reason = reason )","title":"GuildStore"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildNews","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildNews ( GuildChannel , MessageableMixin , InvitableMixin , ThreadableMixin , WebhookMixin ): topic : Optional [ str ] = attr . ib ( default = None ) async def edit ( self , name , position , permission_overwrites , parent_id , nsfw , topic , channel_type , default_auto_archive_duration , reason , ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , parent_id = parent_id , nsfw = nsfw , topic = topic , channel_type = channel_type , default_auto_archive_duration = default_auto_archive_duration , ) await self . _edit ( payload = payload , reason = reason ) async def follow ( self , webhook_channel_id : \"Snowflake_Type\" ): await self . _client . http . follow_news_channel ( self . id , webhook_channel_id )","title":"GuildNews"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildText","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildText ( GuildChannel , MessageableMixin , InvitableMixin , ThreadableMixin , WebhookMixin ): topic : Optional [ str ] = attr . ib ( default = None ) rate_limit_per_user : int = attr . ib ( default = 0 ) async def edit ( self , name , position , permission_overwrites , parent_id , nsfw , topic , channel_type , default_auto_archive_duration , rate_limit_per_user , reason , ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , parent_id = parent_id , nsfw = nsfw , topic = topic , channel_type = channel_type , rate_limit_per_user = rate_limit_per_user , default_auto_archive_duration = default_auto_archive_duration , ) await self . _edit ( payload = payload , reason = reason ) async def follow ( self , webhook_channel_id : \"Snowflake_Type\" ): await self . _client . http . follow_news_channel ( self . id , webhook_channel_id )","title":"GuildText"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.ThreadChannel","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class ThreadChannel ( GuildChannel , MessageableMixin , WebhookMixin ): owner_id : \"Snowflake_Type\" = attr . ib ( default = None ) topic : Optional [ str ] = attr . ib ( default = None ) message_count : int = attr . ib ( default = 0 ) member_count : int = attr . ib ( default = 0 ) archived : bool = attr . ib ( default = False ) auto_archive_duration : int = attr . ib ( default = attr . Factory ( lambda self : self . default_auto_archive_duration , takes_self = True ) ) locked : bool = attr . ib ( default = False ) archive_timestamp : Optional [ Timestamp ] = attr . ib ( default = None , converter = optional_c ( timestamp_converter )) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data = super () . _process_dict ( data , client ) thread_metadata : dict = data . get ( \"thread_metadata\" , {}) data . update ( thread_metadata ) return data @property def is_private ( self ) -> bool : return self . type == ChannelTypes . GUILD_PRIVATE_THREAD @property def parent_channel ( self ) -> GuildText : \"\"\"The channel this thread is a child of\"\"\" return self . _client . cache . channel_cache . get ( self . parent_id ) @property def mention ( self ) -> str : return f \"<# { self . id } >\" async def get_members ( self ) -> List [ \"ThreadMember\" ]: members_data = await self . _client . http . list_thread_members ( self . id ) members = [] for member_data in members_data : members . append ( ThreadMember . from_dict ( member_data , self . _client )) return members async def add_member ( self , member : Union [ \"Member\" , \"Snowflake_Type\" ]) -> None : await self . _client . http . add_thread_member ( self . id , to_snowflake ( member )) async def remove_member ( self , member : Union [ \"Member\" , \"Snowflake_Type\" ]) -> None : await self . _client . http . remove_thread_member ( self . id , to_snowflake ( member )) async def join ( self ): await self . _client . http . join_thread ( self . id ) async def leave ( self ): await self . _client . http . leave_thread ( self . id )","title":"ThreadChannel"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildNewsThread","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildNewsThread ( ThreadChannel ): async def edit ( self , name , archived , auto_archive_duration , locked , rate_limit_per_user , reason ): payload = dict ( # TODO Proper processing name = name , archived = archived , auto_archive_duration = auto_archive_duration , locked = locked , rate_limit_per_user = rate_limit_per_user , ) await self . _edit ( payload = payload , reason = reason )","title":"GuildNewsThread"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildPublicThread","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildPublicThread ( ThreadChannel ): async def edit ( self , name , archived , auto_archive_duration , locked , rate_limit_per_user , reason ): payload = dict ( # TODO Proper processing name = name , archived = archived , auto_archive_duration = auto_archive_duration , locked = locked , rate_limit_per_user = rate_limit_per_user , ) await self . _edit ( payload = payload , reason = reason )","title":"GuildPublicThread"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildPrivateThread","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildPrivateThread ( ThreadChannel ): invitable : bool = field ( default = False ) async def edit ( self , name , archived , auto_archive_duration , locked , rate_limit_per_user , invitable , reason ): payload = dict ( # TODO Proper processing name = name , archived = archived , auto_archive_duration = auto_archive_duration , locked = locked , rate_limit_per_user = rate_limit_per_user , invitable = invitable , ) await self . _edit ( payload = payload , reason = reason )","title":"GuildPrivateThread"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.VoiceChannel","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class VoiceChannel ( GuildChannel ): # TODO May not be needed, can be directly just GuildVoice. bitrate : int = attr . ib () user_limit : int = attr . ib () rtc_region : str = attr . ib ( default = \"auto\" ) video_quality_mode : Union [ VideoQualityModes , int ] = attr . ib ( default = VideoQualityModes . AUTO ) async def edit ( self , name , position , permission_overwrites , parent_id , bitrate , user_limit , rtc_region , video_quality_mode , reason , ): payload = dict ( # TODO Proper processing name = name , position = position , permission_overwrites = permission_overwrites , parent_id = parent_id , bitrate = bitrate , user_limit = user_limit , rtc_region = rtc_region , video_quality_mode = video_quality_mode , ) await self . _edit ( payload = payload , reason = reason )","title":"VoiceChannel"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildVoice","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildVoice ( VoiceChannel , InvitableMixin ): pass","title":"GuildVoice"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.channel.GuildStageVoice","text":"Source code in dis_snek/models/discord_objects/channel.py @define () class GuildStageVoice ( GuildVoice ): stage_instance : \"StageInstance\" = attr . ib ( default = MISSING ) # todo: Listeners and speakers properties (needs voice state caching) async def get_stage_instance ( self ): \"\"\"Gets the stage instance associated with this channel. If no stage is live, will return None.\"\"\" self . stage_instance = StageInstance . from_dict ( await self . _client . http . get_stage_instance ( self . id ), self . _client ) return self . stage_instance async def create_stage_instance ( self , topic : str , privacy_level : StagePrivacyLevel = StagePrivacyLevel . GUILD_ONLY , reason : Optional [ str ] = MISSING , ): \"\"\" Create a stage instance in this channel. Arguments: topic: The topic of the stage (1-120 characters) privacy_level: The privacy level of the stage reason: The reason for creating this instance \"\"\" self . stage_instance = StageInstance . from_dict ( await self . _client . http . create_stage_instance ( self . id , topic , privacy_level , reason ), self . _client ) return self . stage_instance async def close_stage ( self , reason : Optional [ str ] = MISSING ): \"\"\" Closes the live stage instance Arguments: reason: The reason for closing the stage \"\"\" if not self . stage_instance : # we dont know of an active stage instance, so lets check for one if not await self . get_stage_instance (): raise ValueError ( \"No stage instance found\" ) await self . stage_instance . delete ( reason = reason )","title":"GuildStageVoice"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.components.BaseComponent","text":"A base component class. This should never be instantiated. Source code in dis_snek/models/discord_objects/components.py class BaseComponent ( DictSerializationMixin ): \"\"\" A base component class. This should never be instantiated. \"\"\" def __init__ ( self ) -> None : raise NotImplementedError @classmethod def from_dict_factory ( cls , data : dict ) -> \"TYPE_ALL_COMPONENT\" : data . pop ( \"hash\" , None ) # TODO Zero clue why discord sometimes include a hash attribute... component_type = data . pop ( \"type\" , None ) component_class = TYPE_COMPONENT_MAPPING . get ( component_type , None ) if not component_class : raise TypeError ( f \"Unsupported component type for { data } ( { component_type } ), please consult the docs.\" ) return component_class . from_dict ( data )","title":"BaseComponent"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.components.InteractiveComponent","text":"A base interactive component class. This should never be instantiated. Source code in dis_snek/models/discord_objects/components.py class InteractiveComponent ( BaseComponent ): \"\"\" A base interactive component class. This should never be instantiated. \"\"\" def __eq__ ( self , other : Any ) -> bool : if isinstance ( other , dict ): other = BaseComponent . from_dict_factory ( other ) return self . custom_id == other . custom_id and self . type == other . type return False","title":"InteractiveComponent"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.components.Button","text":"Represents a discord ui button Attributes: Name Type Description style optional[ButtonStyles, int] Buttons come in a variety of styles to convey different types of actions. label optional[str] The text that appears on the button, max 80 characters. emoji optional[Union[Emoji, dict, str]] The emoji that appears on the button. custom_id Optional[str] A developer-defined identifier for the button, max 100 characters. url Optional[str] A url for link-style buttons. disabled bool Disable the button and make it not interactable, default false. Source code in dis_snek/models/discord_objects/components.py @attr . s ( slots = True , eq = False ) class Button ( InteractiveComponent ): \"\"\" Represents a discord ui button Attributes: style optional[ButtonStyles, int]: Buttons come in a variety of styles to convey different types of actions. label optional[str]: The text that appears on the button, max 80 characters. emoji optional[Union[Emoji, dict, str]]: The emoji that appears on the button. custom_id Optional[str]: A developer-defined identifier for the button, max 100 characters. url Optional[str]: A url for link-style buttons. disabled bool: Disable the button and make it not interactable, default false. \"\"\" style : Union [ ButtonStyles , int ] = attr . ib () label : Optional [ str ] = attr . ib ( default = None ) emoji : Optional [ Union [ \"Emoji\" , dict , str ]] = attr . ib ( default = None , metadata = export_converter ( process_emoji )) custom_id : Optional [ str ] = attr . ib ( default = MISSING , validator = str_validator ) url : Optional [ str ] = attr . ib ( default = None ) disabled : bool = attr . ib ( default = False ) type : Union [ ComponentTypes , int ] = attr . ib ( default = ComponentTypes . BUTTON , init = False , on_setattr = attr . setters . frozen ) @style . validator def _style_validator ( self , attribute : str , value : int ): if not isinstance ( value , ButtonStyles ) and value not in ButtonStyles . __members__ . values (): raise ValueError ( f 'Button style type of \" { value } \" not recognized, please consult the docs.' ) def __attrs_post_init__ ( self ): if self . style != ButtonStyles . URL : # handle adding a custom id to any button that requires a custom id if self . custom_id is MISSING : self . custom_id = str ( uuid . uuid4 ()) def _check_object ( self ): if self . style == ButtonStyles . URL : if self . custom_id not in ( None , MISSING ): raise TypeError ( \"A link button cannot have a `custom_id`!\" ) if not self . url : raise TypeError ( \"A link button must have a `url`!\" ) else : if self . url : raise TypeError ( \"You can't have a URL on a non-link button!\" ) if not self . label and not self . emoji : raise TypeError ( \"You must have at least a label or emoji on a button.\" )","title":"Button"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.components.SelectOption","text":"Represents a select option. Attributes: Name Type Description label str The label (max 80 characters) value str The value of the select, this is whats sent to your bot description Optional[str] A description of this option emoji Optional[Union[Emoji, dict, str] An emoji to show in this select option default bool Is this option selected by default Source code in dis_snek/models/discord_objects/components.py @attr . s ( slots = True ) class SelectOption ( BaseComponent ): \"\"\" Represents a select option. Attributes: label str: The label (max 80 characters) value str: The value of the select, this is whats sent to your bot description Optional[str]: A description of this option emoji Optional[Union[Emoji, dict, str]: An emoji to show in this select option default bool: Is this option selected by default \"\"\" label : str = attr . ib ( validator = str_validator ) value : str = attr . ib ( validator = str_validator ) description : Optional [ str ] = attr . ib ( default = None ) emoji : Optional [ Union [ \"Emoji\" , dict , str ]] = attr . ib ( default = None , metadata = export_converter ( process_emoji )) default : bool = attr . ib ( default = False ) @label . validator def _label_validator ( self , attribute : str , value : str ): if not value or len ( value ) > SELECT_MAX_NAME_LENGTH : raise ValueError ( \"Label length should be between 1 and 100.\" ) @value . validator def _value_validator ( self , attribute : str , value : str ): if not value or len ( value ) > SELECT_MAX_NAME_LENGTH : raise ValueError ( \"Value length should be between 1 and 100.\" ) @description . validator def _description_validator ( self , attribute : str , value : str ): if value is not None and len ( value ) > SELECT_MAX_NAME_LENGTH : raise ValueError ( \"Description length must be 100 or lower.\" )","title":"SelectOption"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.components.Select","text":"Represents a select component. Attributes: Name Type Description options List[dict] The choices in the select, max 25. custom_id str A developer-defined identifier for the button, max 100 characters. placeholder str The custom placeholder text to show if nothing is selected, max 100 characters. min_values Optional[int] The minimum number of items that must be chosen. (default 1, min 0, max 25) max_values Optional[int] The maximum number of items that can be chosen. (default 1, max 25) disabled bool Disable the select and make it not intractable, default false. type Union[ComponentTypes, int] The action role type number defined by discord. This cannot be modified. Source code in dis_snek/models/discord_objects/components.py @attr . s ( slots = True , eq = False ) class Select ( InteractiveComponent ): \"\"\" Represents a select component. Attributes: options List[dict]: The choices in the select, max 25. custom_id str: A developer-defined identifier for the button, max 100 characters. placeholder str: The custom placeholder text to show if nothing is selected, max 100 characters. min_values Optional[int]: The minimum number of items that must be chosen. (default 1, min 0, max 25) max_values Optional[int]: The maximum number of items that can be chosen. (default 1, max 25) disabled bool: Disable the select and make it not intractable, default false. type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified. \"\"\" options : List [ Union [ SelectOption , Dict ]] = attr . ib ( factory = list ) custom_id : str = attr . ib ( factory = uuid . uuid4 , validator = str_validator ) placeholder : str = attr . ib ( default = None ) min_values : Optional [ int ] = attr . ib ( default = 1 ) max_values : Optional [ int ] = attr . ib ( default = 1 ) disabled : bool = attr . ib ( default = False ) type : Union [ ComponentTypes , int ] = attr . ib ( default = ComponentTypes . SELECT , init = False , on_setattr = attr . setters . frozen ) def __len__ ( self ) -> int : return len ( self . options ) @placeholder . validator def _placeholder_validator ( self , attribute : str , value : str ): if value is not None and len ( value ) > SELECT_MAX_NAME_LENGTH : raise ValueError ( \"Placeholder length must be 100 or lower.\" ) @min_values . validator def _min_values_validator ( self , attribute : str , value : int ): if value < 0 : raise ValueError ( \"Select min value cannot be a negative number.\" ) @max_values . validator def _max_values_validator ( self , attribute : str , value : int ): if value < 0 : raise ValueError ( \"Select max value cannot be a negative number.\" ) @options . validator def _options_validator ( self , attribute : str , value : List [ Union [ SelectOption , Dict ]]): if not all ( isinstance ( x , ( SelectOption , Dict )) for x in value ): raise ValueError ( f \"Select options must be of type `SelectOption`\" ) def _check_object ( self ): if not self . custom_id : raise TypeError ( \"You need to have a custom id to identify the select.\" ) if not self . options : raise TypeError ( \"Selects needs to have at least 1 option.\" ) if len ( self . options ) > SELECTS_MAX_OPTIONS : raise TypeError ( \"Selects can only hold 25 options\" ) if self . max_values < self . min_values : raise TypeError ( \"Selects max value cannot be less than min value.\" ) def add_option ( self , option : Union [ SelectOption ]): if not isinstance ( option , ( SelectOption , Dict )): raise ValueError ( f \"Select option must be of `SelectOption` type, not { type ( option ) } \" ) self . options . append ( option )","title":"Select"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.components.ActionRow","text":"Represents an action row Attributes: Name Type Description components List[Union[dict, Select, Button]] The components within this action row type Union[ComponentTypes, int] The action role type number defined by discord. This cannot be modified. Source code in dis_snek/models/discord_objects/components.py @attr . s ( slots = True , init = False ) class ActionRow ( BaseComponent ): \"\"\" Represents an action row Attributes: components List[Union[dict, Select, Button]]: The components within this action row type Union[ComponentTypes, int]: The action role type number defined by discord. This cannot be modified. \"\"\" _max_items = ACTION_ROW_MAX_ITEMS components : List [ Union [ dict , Select , Button ]] = attr . ib ( factory = list ) type : Union [ ComponentTypes , int ] = attr . ib ( default = ComponentTypes . ACTION_ROW , init = False , on_setattr = attr . setters . frozen ) def __init__ ( self , * components : Union [ dict , Select , Button ]) -> None : self . __attrs_init__ ( components ) self . components = [ self . _component_checks ( c ) for c in self . components ] def __len__ ( self ) -> int : return len ( self . components ) @classmethod def from_dict ( cls , data ): return cls ( * data [ \"components\" ]) def _component_checks ( self , component : Union [ dict , Select , Button ]): if isinstance ( component , dict ): component = BaseComponent . from_dict_factory ( component ) if not issubclass ( type ( component ), InteractiveComponent ): raise TypeError ( \"You can only add select or button to the action row.\" ) component . _check_object () return component def _check_object ( self ): if not ( 0 < len ( self . components ) <= ActionRow . _max_items ): raise TypeError ( f \"Number of components in one row should be between 1 and { ActionRow . _max_items } .\" ) if any ( x . type == ComponentTypes . SELECT for x in self . components ) and len ( self . components ) != 1 : raise TypeError ( \"Action row must have only one select component and nothing else.\" ) def add_components ( self , * components : Union [ dict , Button , Select ]): \"\"\" Add one or more component(s) to this action row Args: components: The components to add \"\"\" for c in components : self . components . append ( self . _component_checks ( c ))","title":"ActionRow"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.components.process_components","text":"Process the passed components into a format discord will understand. Parameters: Name Type Description Default components Union[List[List[Union[dis_snek.models.discord_objects.components.BaseComponent, Dict]]], List[Union[dis_snek.models.discord_objects.components.BaseComponent, Dict]], dis_snek.models.discord_objects.components.BaseComponent, Dict] List of dict / components to process required Returns: Type Description List[Dict] formatted dictionary for discord Exceptions: Type Description ValueError Invalid components Source code in dis_snek/models/discord_objects/components.py def process_components ( components : Optional [ Union [ List [ List [ Union [ BaseComponent , Dict ]]], List [ Union [ BaseComponent , Dict ]], BaseComponent , Dict ] ] ) -> List [ Dict ]: \"\"\" Process the passed components into a format discord will understand. Args: components: List of dict / components to process Returns: formatted dictionary for discord Raises: ValueError: Invalid components \"\"\" if not components : # Its just empty, so nothing to process. return components if isinstance ( components , dict ): # If a naked dictionary is passed, assume the user knows what they're doing and send it blindly # after wrapping it in a list for discord return [ components ] if issubclass ( type ( components ), BaseComponent ): # Naked component was passed components = [ components ] if isinstance ( components , list ): if all ( isinstance ( c , dict ) for c in components ): # user has passed a list of dicts, this is the correct format, blindly send it return components if all ( isinstance ( c , list ) for c in components ): # list of lists... actionRow-less sending return [ ActionRow ( * row ) . to_dict () for row in components ] if all ( issubclass ( type ( c ), InteractiveComponent ) for c in components ): # list of naked components return [ ActionRow ( * components ) . to_dict ()] if all ( isinstance ( c , ActionRow ) for c in components ): # we have a list of action rows return [ action_row . to_dict () for action_row in components ] raise ValueError ( f \"Invalid components: { components } \" )","title":"process_components()"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.components.spread_to_rows","text":"A helper function that spreads your components into ActionRow s of a set size Parameters: Name Type Description Default *components Union[dis_snek.models.discord_objects.components.ActionRow, dis_snek.models.discord_objects.components.Button, dis_snek.models.discord_objects.components.Select] The components to spread, use None to explicit start a new row () max_in_row The maximum number of components in each row 5 Returns: Type Description List[dis_snek.models.discord_objects.components.ActionRow] List[ActionRow] of components spread to rows Exceptions: Type Description ValueError Too many or few components or rows Source code in dis_snek/models/discord_objects/components.py def spread_to_rows ( * components : Union [ ActionRow , Button , Select ], max_in_row = 5 ) -> List [ ActionRow ]: \"\"\" A helper function that spreads your components into `ActionRow`s of a set size Args: *components: The components to spread, use `None` to explicit start a new row max_in_row: The maximum number of components in each row Returns: List[ActionRow] of components spread to rows Raises: ValueError: Too many or few components or rows \"\"\" # todo: incorrect format errors if not components or len ( components ) > 25 : raise ValueError ( \"Number of components should be between 1 and 25.\" ) if not 1 <= max_in_row <= 5 : raise ValueError ( \"max_in_row should be between 1 and 5.\" ) rows = [] button_row = [] for component in list ( components ): if component is not None and component . type == ComponentTypes . BUTTON : button_row . append ( component ) if len ( button_row ) == max_in_row : rows . append ( ActionRow ( * button_row )) button_row = [] continue if button_row : rows . append ( ActionRow ( * button_row )) button_row = [] if component is not None : if component . type == ComponentTypes . ACTION_ROW : rows . append ( component ) elif component . type == ComponentTypes . SELECT : rows . append ( ActionRow ( component )) if button_row : rows . append ( ActionRow ( * button_row )) if len ( rows ) > 5 : raise ValueError ( \"Number of rows exceeds 5.\" ) return rows","title":"spread_to_rows()"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.components.get_components_ids","text":"Returns generator with the custom_id of a component or list of components. Parameters: Name Type Description Default component Union[str, dict, list, dis_snek.models.discord_objects.components.InteractiveComponent] Objects to get custom_id s from required Exceptions: Type Description ValueError Unknown component type Source code in dis_snek/models/discord_objects/components.py def get_components_ids ( component : Union [ str , dict , list , InteractiveComponent ]) -> Iterator [ str ]: \"\"\" Returns generator with the `custom_id` of a component or list of components. Args: component: Objects to get `custom_id`s from Raises: ValueError: Unknown component type \"\"\" if isinstance ( component , str ): yield component elif isinstance ( component , dict ): if component [ \"type\" ] == ComponentTypes . actionrow : yield from ( comp [ \"custom_id\" ] for comp in component [ \"components\" ] if \"custom_id\" in comp ) elif \"custom_id\" in component : yield component [ \"custom_id\" ] elif c_id := getattr ( component , \"custom_id\" , None ): yield c_id elif isinstance ( component , ActionRow ): yield from ( comp_id for comp in component . components for comp_id in get_components_ids ( comp )) elif isinstance ( component , list ): yield from ( comp_id for comp in component for comp_id in get_components_ids ( comp )) else : raise ValueError ( f \"Unknown component type of { component } ( { type ( component ) } ). \" f \"Expected str, dict or list\" )","title":"get_components_ids()"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.embed.EmbedField","text":"Representation of an embed field. Attributes: Name Type Description name str Field name value str Field value inline bool If the field should be inline Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedField ( DictSerializationMixin ): \"\"\"Representation of an embed field. Attributes: name: Field name value: Field value inline: If the field should be inline \"\"\" name : str = attr . ib () value : str = attr . ib () inline : bool = attr . ib ( default = False ) def __len__ ( self ): return len ( self . name ) + len ( self . value )","title":"EmbedField"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.embed.EmbedAuthor","text":"Representation of an embed author Attributes: Name Type Description name Optional[str] Name to show on embed url Optional[str] Url to go to when name is clicked icon_url Optional[str] Icon to show next to name proxy_icon_url Optional[str] Proxy icon url Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedAuthor : \"\"\"Representation of an embed author Attributes: name: Name to show on embed url: Url to go to when name is clicked icon_url: Icon to show next to name proxy_icon_url: Proxy icon url \"\"\" name : Optional [ str ] = attr . ib ( default = None ) url : Optional [ str ] = attr . ib ( default = None ) icon_url : Optional [ str ] = attr . ib ( default = None ) proxy_icon_url : Optional [ str ] = attr . ib ( default = None , metadata = no_export_meta ) def __len__ ( self ): return len ( self . name )","title":"EmbedAuthor"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.embed.EmbedAttachment","text":"Representation of an attachment Attributes: Name Type Description url Optional[str] Attachment url proxy_url Optional[str] Proxy url height Optional[int] Attachment height width Optional[int] Attachment width Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedAttachment : # thumbnail or image or video \"\"\"Representation of an attachment Attributes: url: Attachment url proxy_url: Proxy url height: Attachment height width: Attachment width \"\"\" url : Optional [ str ] = attr . ib ( default = None ) proxy_url : Optional [ str ] = attr . ib ( default = None , metadata = no_export_meta ) height : Optional [ int ] = attr . ib ( default = None , metadata = no_export_meta ) width : Optional [ int ] = attr . ib ( default = None , metadata = no_export_meta ) @property def size ( self ): return self . height , self . width","title":"EmbedAttachment"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.embed.EmbedFooter","text":"Representation of an Embed Footer Attributes: Name Type Description text str Footer text icon_url Optional[str] Footer icon url proxy_icon_url Optional[str] Proxy icon url Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedFooter : \"\"\"Representation of an Embed Footer Attributes: text: Footer text icon_url: Footer icon url proxy_icon_url: Proxy icon url \"\"\" text : str = attr . ib () icon_url : Optional [ str ] = attr . ib ( default = None ) proxy_icon_url : Optional [ str ] = attr . ib ( default = None , metadata = no_export_meta ) def __len__ ( self ): return len ( self . text )","title":"EmbedFooter"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.embed.EmbedProvider","text":"Represents an embed's provider. Note Only used by system embeds, not bots Attributes: Name Type Description name Optional[str] Provider name url Optional[str] Provider url Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class EmbedProvider : \"\"\" Represents an embed's provider. Note: Only used by system embeds, not bots Attributes: name: Provider name url: Provider url \"\"\" name : Optional [ str ] = attr . ib ( default = None ) url : Optional [ str ] = attr . ib ( default = None )","title":"EmbedProvider"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.embed.Embed","text":"Represents a discord embed object. Source code in dis_snek/models/discord_objects/embed.py @attr . s ( slots = True ) class Embed ( DictSerializationMixin ): \"\"\"Represents a discord embed object.\"\"\" title : Optional [ str ] = field ( default = None , repr = True ) \"\"\"The title of the embed\"\"\" description : Optional [ str ] = field ( default = None , repr = True ) \"\"\"The description of the embed\"\"\" color : Optional [ Union [ str , int , Color ]] = field ( default = None , repr = True ) \"\"\"The colour of the embed\"\"\" url : Optional [ str ] = field ( default = None , validator = v_optional ( instance_of ( str )), repr = True ) \"\"\"The url the embed should direct to when clicked\"\"\" timestamp : Optional [ Timestamp ] = field ( default = None , converter = c_optional ( timestamp_converter ), on_setattr = setters . convert , validator = v_optional ( instance_of (( datetime , float , int ))), repr = True , ) \"\"\"Timestamp of embed content\"\"\" fields : List [ EmbedField ] = field ( factory = list , converter = list_converter ( EmbedField . from_dict ), repr = True ) \"\"\"A list of [fields][dis_snek.models.discord_objects.embed.EmbedField] to go in the embed\"\"\" author : Optional [ EmbedAuthor ] = field ( default = None , converter = c_optional ( EmbedAuthor )) \"\"\"The author of the embed\"\"\" thumbnail : Optional [ EmbedAttachment ] = field ( default = None , converter = c_optional ( EmbedAttachment )) \"\"\"The thumbnail of the embed\"\"\" image : Optional [ EmbedAttachment ] = field ( default = None , converter = c_optional ( EmbedAttachment )) \"\"\"The image of the embed\"\"\" video : Optional [ EmbedAttachment ] = field ( default = None , converter = c_optional ( EmbedAttachment ), metadata = no_export_meta ) \"\"\"The video of the embed, only used by system embeds\"\"\" footer : Optional [ EmbedFooter ] = field ( default = None , converter = c_optional ( EmbedFooter )) \"\"\"The footer of the embed\"\"\" provider : Optional [ EmbedProvider ] = field ( default = None , converter = c_optional ( EmbedProvider ), metadata = no_export_meta ) \"\"\"The provider of the embed, only used for system embeds\"\"\" @title . validator def _name_validation ( self , attribute : str , value : Any ) -> None : \"\"\"Validate the embed title.\"\"\" if value is not None : if isinstance ( value , str ): if len ( value ) > EMBED_MAX_NAME_LENGTH : raise ValueError ( f \"Title cannot exceed { EMBED_MAX_NAME_LENGTH } characters\" ) return raise TypeError ( \"Title must be of type String\" ) @description . validator def _description_validation ( self , attribute : str , value : Any ) -> None : \"\"\"Validate the description.\"\"\" if value is not None : if isinstance ( value , str ): if len ( value ) > EMBED_MAX_DESC_LENGTH : raise ValueError ( f \"Description cannot exceed { EMBED_MAX_DESC_LENGTH } characters\" ) return raise TypeError ( \"Description must be of type String\" ) @fields . validator def _fields_validation ( self , attribute : str , value : Any ) -> None : \"\"\"Validate the fields.\"\"\" if isinstance ( value , list ): if len ( value ) > EMBED_MAX_FIELDS : raise ValueError ( f \"Embeds can only hold { EMBED_MAX_FIELDS } fields\" ) def _check_object ( self ): self . _name_validation ( \"title\" , self . title ) self . _description_validation ( \"description\" , self . description ) self . _fields_validation ( \"fields\" , self . fields ) if len ( self ) > EMBED_TOTAL_MAX : raise ValueError ( \"Your embed is too large, more info at https://discord.com/developers/docs/resources/channel#embed-limits\" ) def to_dict ( self ) -> Dict [ str , Any ]: data = super () . to_dict () if color := data . get ( \"color\" ): if isinstance ( color , dict ): color = color [ \"value\" ] elif not isinstance ( color , int ): color = Color ( color ) . value data [ \"color\" ] = color return data def __len__ ( self ): # yes i know there are far more optimal ways to write this # its written like this for readability total = 0 total += len ( self . title ) if self . title else 0 total += len ( self . description ) if self . description else 0 total += len ( self . footer ) if self . footer else 0 total += len ( self . author ) if self . author else 0 for _field in self . fields : total += len ( _field ) return total def set_author ( self , name : str , url : Optional [ str ] = None , icon_url : Optional [ str ] = None , ) -> None : \"\"\" Set the author field of the embed. Args: name: The text to go in the title section url: A url link to the author icon_url: A url of an image to use as the icon \"\"\" self . author = EmbedAuthor ( name = name , url = url , icon_url = icon_url ) def set_thumbnail ( self , url : str ) -> None : \"\"\" Set the thumbnail of the embed. Args: url: the url of the image to use \"\"\" self . thumbnail = EmbedAttachment ( url = url ) def set_image ( self , url : str ) -> None : \"\"\" Set the image of the embed. Args: url: the url of the image to use \"\"\" self . image = EmbedAttachment ( url = url ) def set_footer ( self , text : str , icon_url : Optional [ str ] = None ) -> None : \"\"\" Set the footer field of the embed. Args: text: The text to go in the title section icon_url: A url of an image to use as the icon \"\"\" self . footer = EmbedFooter ( text = text , icon_url = icon_url ) def add_field ( self , name : str , value : str , inline : bool = False ) -> None : \"\"\" Add a field to the embed. Args: name: The title of this field value: The value in this field inline: Should this field be inline with other fields? \"\"\" self . fields . append ( EmbedField ( name , value , inline )) self . _fields_validation ( \"fields\" , self . fields )","title":"Embed"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.embed.process_embeds","text":"Process the passed embeds into a format discord will understand. Parameters: Name Type Description Default embeds Union[List[Union[dis_snek.models.discord_objects.embed.Embed, Dict]], dis_snek.models.discord_objects.embed.Embed, Dict] List of dict / embeds to process required Source code in dis_snek/models/discord_objects/embed.py def process_embeds ( embeds : Optional [ Union [ List [ Union [ Embed , Dict ]], Union [ Embed , Dict ]]]) -> Optional [ List [ dict ]]: \"\"\" Process the passed embeds into a format discord will understand. Args: embeds: List of dict / embeds to process \"\"\" if not embeds : # Its just empty, so nothing to process. return embeds if isinstance ( embeds , Embed ): # Single embed, convert it to dict and wrap it into a list for discord. return [ embeds . to_dict ()] if isinstance ( embeds , dict ): # We assume the dict correctly represents a single discord embed and just send it blindly # after wrapping it in a list for discord return [ embeds ] if isinstance ( embeds , list ): # A list of embeds, convert Embed to dict representation if needed. return [ embed . to_dict () if isinstance ( embed , Embed ) else embed for embed in embeds ] raise ValueError ( f \"Invalid embeds: { embeds } \" )","title":"process_embeds()"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.emoji.Emoji","text":"Represent a basic emoji used in discord. Source code in dis_snek/models/discord_objects/emoji.py @define () class Emoji ( SnowflakeObject , DictSerializationMixin ): \"\"\"Represent a basic emoji used in discord.\"\"\" id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake ) ) # can be None for Standard Emoji \"\"\"The custom emoji id. Leave empty if you are using standard unicode emoji.\"\"\" name : Optional [ str ] = attr . ib ( default = None ) \"\"\"The custom emoji name, or standard unicode emoji in string\"\"\" animated : bool = attr . ib ( default = False ) \"\"\"Whether this emoji is animated\"\"\" @classmethod def unicode ( cls , emoji : str ): return cls ( name = emoji ) def __str__ ( self ) -> str : return f \"< { 'a:' if self . animated else '' }{ self . name } : { self . id } >\" # <:thinksmart:623335224318754826> def __eq__ ( self , other ): if self . id : return self . id == other . id return self . name == other . name @property def req_format ( self ) -> str : \"\"\" Format used for web request. \"\"\" if self . id : return f \" { self . name } : { self . id } \" else : return self . name","title":"Emoji"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.emoji.CustomEmoji","text":"Represent a custom emoji in a guild with all its properties. Source code in dis_snek/models/discord_objects/emoji.py @define () class CustomEmoji ( Emoji ): \"\"\"Represent a custom emoji in a guild with all its properties.\"\"\" _client : \"Snake\" = field ( metadata = no_export_meta ) require_colons : bool = attr . ib ( default = False ) \"\"\"Whether this emoji must be wrapped in colons\"\"\" managed : bool = attr . ib ( default = False ) \"\"\"Whether this emoji is managed\"\"\" available : bool = attr . ib ( default = False ) \"\"\"Whether this emoji can be used, may be false due to loss of Server Boosts.\"\"\" _creator_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) _role_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list , converter = optional ( list_converter ( to_snowflake ))) _guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: creator_dict = data . pop ( \"user\" , None ) data [ \"creator_id\" ] = client . cache . place_user_data ( creator_dict ) . id if creator_dict else None if \"roles\" in data : data [ \"role_ids\" ] = data . pop ( \"roles\" ) return data @classmethod def from_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> \"CustomEmoji\" : data = cls . _process_dict ( data , client ) return cls ( client = client , ** cls . _filter_kwargs ( data , cls . _get_init_keys ())) @property def is_usable ( self ) -> bool : \"\"\" Determines if this emoji is usable by the current user. \"\"\" if not self . available : return False # todo: check roles return True async def get_creator ( self ) -> \"User\" : \"\"\" Get the user who created this emoji Returns: User object \"\"\" return await self . _client . cache . get_user ( self . _creator_id ) async def get_roles ( self ) -> List [ \"Role\" ]: \"\"\" Gets the roles allowed to use this emoji Returns: List of roles \"\"\" return [ await self . _client . cache . get_role ( self . _guild_id , r_id ) for r_id in self . _role_ids ] async def get_guild ( self ) -> \"Guild\" : \"\"\" Get the guild associated with this emoji Returns: Guild object \"\"\" return await self . _client . cache . get_guild ( self . _guild_id ) async def edit ( self , name : Optional [ str ] = None , roles : Optional [ List [ Union [ \"Snowflake_Type\" , \"Role\" ]]] = None , reason : Optional [ str ] = None , ) -> \"CustomEmoji\" : \"\"\" Modify the custom emoji information. Args: name: The name of the emoji. roles: The roles allowed to use this emoji. reason: Attach a reason to this action, used for audit logs. Returns: The newly modified custom emoji. \"\"\" data_payload = dict_filter_none ( dict ( name = name , roles = roles , ) ) updated_data = await self . _client . http . modify_guild_emoji ( data_payload , self . _guild_id , self . id , reason = reason ) self . update_from_dict ( updated_data ) return self async def delete ( self , reason : Optional [ str ] = None ) -> None : \"\"\" Deletes the custom emoji from the guild. Args: reason: Attach a reason to this action, used for audit logs. \"\"\" if not self . _guild_id : raise ValueError ( \"Cannot delete emoji, no guild id set.\" ) await self . _client . http . delete_guild_emoji ( self . _guild_id , self . id , reason = reason )","title":"CustomEmoji"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.guild.Guild","text":"Guilds in Discord represent an isolated collection of users and channels, and are often referred to as \"servers\" in the UI. Source code in dis_snek/models/discord_objects/guild.py @define () class Guild ( DiscordObject ): \"\"\"Guilds in Discord represent an isolated collection of users and channels, and are often referred to as \"servers\" in the UI.\"\"\" unavailable : bool = attr . ib ( default = False ) \"\"\"True if this guild is unavailable due to an outage.\"\"\" name : str = attr . ib () \"\"\"Name of guild. (2-100 characters, excluding trailing and leading whitespace)\"\"\" splash : Optional [ str ] = attr . ib ( default = None ) \"\"\"Hash for splash image.\"\"\" discovery_splash : Optional [ str ] = attr . ib ( default = None ) \"\"\"Hash for discovery splash image. Only present for guilds with the \"DISCOVERABLE\" feature.\"\"\" # owner: bool = attr.ib(default=False) # we get this from api but it's kinda useless to store permissions : Optional [ Permissions ] = attr . ib ( default = None , converter = optional ( Permissions )) \"\"\"Total permissions for the user in the guild. (excludes overwrites)\"\"\" afk_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The channel id for afk.\"\"\" afk_timeout : Optional [ int ] = attr . ib ( default = None ) \"\"\"afk timeout in seconds.\"\"\" widget_enabled : bool = attr . ib ( default = False ) \"\"\"True if the server widget is enabled.\"\"\" widget_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The channel id that the widget will generate an invite to, or None if set to no invite.\"\"\" verification_level : Union [ VerificationLevels , int ] = attr . ib ( default = VerificationLevels . NONE ) \"\"\"The verification level required for the guild.\"\"\" default_message_notifications : Union [ DefaultNotificationLevels , int ] = attr . ib ( default = DefaultNotificationLevels . ALL_MESSAGES ) \"\"\"The default message notifications level.\"\"\" explicit_content_filter : Union [ ExplicitContentFilterLevels , int ] = attr . ib ( default = ExplicitContentFilterLevels . DISABLED ) \"\"\"The explicit content filter level.\"\"\" mfa_level : Union [ MFALevels , int ] = attr . ib ( default = MFALevels . NONE ) \"\"\"The required MFA (Multi Factor Authentication) level for the guild.\"\"\" system_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The id of the channel where guild notices such as welcome messages and boost events are posted.\"\"\" system_channel_flags : Union [ SystemChannelFlags , int ] = attr . ib ( default = SystemChannelFlags . NONE ) \"\"\"The system channel flags.\"\"\" rules_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The id of the channel where Community guilds can display rules and/or guidelines.\"\"\" joined_at : str = attr . ib ( default = None , converter = optional ( timestamp_converter )) \"\"\"When this guild was joined at.\"\"\" large : bool = attr . ib ( default = False ) \"\"\"True if this is considered a large guild.\"\"\" member_count : int = attr . ib ( default = 0 ) \"\"\"The total number of members in this guild.\"\"\" voice_states : List [ dict ] = attr . ib ( factory = list ) \"\"\"The states of members currently in voice channels. Lacks the guild_id key.\"\"\" presences : List [ dict ] = attr . ib ( factory = list ) \"\"\"The presences of the members in the guild, will only include non-offline members if the size is greater than large threshold.\"\"\" max_presences : Optional [ int ] = attr . ib ( default = None ) \"\"\"The maximum number of presences for the guild. (None is always returned, apart from the largest of guilds)\"\"\" max_members : Optional [ int ] = attr . ib ( default = None ) \"\"\"The maximum number of members for the guild.\"\"\" vanity_url_code : Optional [ str ] = attr . ib ( default = None ) \"\"\"The vanity url code for the guild.\"\"\" description : Optional [ str ] = attr . ib ( default = None ) \"\"\"The description of a Community guild.\"\"\" banner : Optional [ str ] = attr . ib ( default = None ) \"\"\"Hash for banner image.\"\"\" premium_tier : Optional [ str ] = attr . ib ( default = None ) \"\"\"The premium tier level. (Server Boost level)\"\"\" premium_subscription_count : int = attr . ib ( default = 0 ) \"\"\"The number of boosts this guild currently has.\"\"\" preferred_locale : str = attr . ib () \"\"\"The preferred locale of a Community guild. Used in server discovery and notices from Discord. Defaults to \\\"en-US\\\"\"\" \" public_updates_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"The id of the channel where admins and moderators of Community guilds receive notices from Discord.\"\"\" max_video_channel_users : int = attr . ib ( default = 0 ) \"\"\"The maximum amount of users in a video channel.\"\"\" welcome_screen : Optional [ dict ] = attr . ib ( factory = list ) # TODO welcome screen object. \"\"\"The welcome screen of a Community guild, shown to new members, returned in an Invite's guild object.\"\"\" nsfw_level : Union [ NSFWLevels , int ] = attr . ib ( default = NSFWLevels . DEFAULT ) \"\"\"The guild NSFW level.\"\"\" stage_instances : List [ dict ] = attr . ib ( factory = list ) # TODO stage instance objects \"\"\"Stage instances in the guild.\"\"\" _owner_id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) _channel_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _thread_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _member_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _role_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _features : List [ str ] = attr . ib ( factory = list ) _icon : Optional [ str ] = attr . ib ( default = None ) # todo merge, convert to asset _icon_hash : Optional [ str ] = attr . ib ( default = None ) # TODO Not storing these for now, get accurate data from api when needed instead. # _emojis: List[dict] = attr.ib(factory=list) # _stickers: List[Sticker] = attr.ib(factory=list) @classmethod def _process_dict ( cls , data , client ): guild_id = data [ \"id\" ] channels_data = data . pop ( \"channels\" , []) for c in channels_data : c [ \"guild_id\" ] = guild_id data [ \"channel_ids\" ] = [ client . cache . place_channel_data ( channel_data ) . id for channel_data in channels_data ] threads_data = data . pop ( \"threads\" , []) data [ \"thread_ids\" ] = [ client . cache . place_channel_data ( thread_data ) . id for thread_data in threads_data ] members_data = data . pop ( \"members\" , []) data [ \"member_ids\" ] = [ client . cache . place_member_data ( guild_id , member_data ) . id for member_data in members_data ] roles_data = data . pop ( \"roles\" , []) data [ \"role_ids\" ] = list ( client . cache . place_role_data ( guild_id , roles_data ) . keys ()) return data @property def channels ( self ) -> List [ \"TYPE_GUILD_CHANNEL\" ]: \"\"\"Returns a list of channels associated with this guild.\"\"\" return [ self . _client . cache . channel_cache . get ( c_id ) for c_id in self . _channel_ids ] @property def threads ( self ) -> List [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\"Returns a list of threads associated with this guild.\"\"\" return [ self . _client . cache . channel_cache . get ( t_id ) for t_id in self . _thread_ids ] @property def members ( self ) -> List [ \"Member\" ]: \"\"\"A generator that yields all members of this guild.\"\"\" return [ self . _client . cache . member_cache . get (( self . id , m_id )) for m_id in self . _member_ids ] @property def roles ( self ) -> List [ \"Role\" ]: \"\"\"Returns a list of roles associated with this guild\"\"\" return [ self . _client . cache . role_cache . get ( r_id ) for r_id in self . _role_ids ] @property def me ( self ) -> \"Member\" : \"\"\"Returns this bots member object within this guild.\"\"\" return self . _client . cache . member_cache . get (( self . id , self . _client . user . id )) @property def system_channel ( self ) -> Optional [ \"GuildText\" ]: \"\"\"Returns the channel this guild uses for system messages.\"\"\" return self . _client . cache . channel_cache . get ( self . system_channel_id ) @property def rules_channel ( self ) -> Optional [ \"GuildText\" ]: \"\"\"Returns the channel declared as a rules channel\"\"\" return self . _client . cache . channel_cache . get ( self . rules_channel_id ) @property def public_updates_channel ( self ) -> Optional [ \"GuildText\" ]: \"\"\"Returns the channel where server staff receive notices from Discord\"\"\" return self . _client . cache . channel_cache . get ( self . public_updates_channel_id ) @property def emoji_limit ( self ) -> int : \"\"\"The maximum number of emoji this guild can have\"\"\" base = 200 if \"MORE_EMOJI\" in self . _features else 50 return max ( base , PREMIUM_GUILD_LIMITS [ self . premium_tier ][ \"emoji\" ]) @property def sticker_limit ( self ) -> int : \"\"\"The maximum number of stickers this guild can have\"\"\" base = 60 if \"MORE_sTICKERS\" in self . _features else 0 return max ( base , PREMIUM_GUILD_LIMITS [ self . premium_tier ][ \"stickers\" ]) @property def bitrate_limit ( self ) -> int : \"\"\"The maximum bitrate for this guild\"\"\" base = 128000 if \"VIP_REGIONS\" in self . _features else 96000 return max ( base , PREMIUM_GUILD_LIMITS [ self . premium_tier ][ \"bitrate\" ]) @property def filesize_limit ( self ) -> int : \"\"\"The maximum filesize that may be uploaded within this guild\"\"\" return PREMIUM_GUILD_LIMITS [ self . premium_tier ][ \"filesize\" ] @property def default_role ( self ) -> \"Role\" : \"\"\"The `@everyone` role in this guild\"\"\" return self . _client . cache . role_cache . get ( self . id ) # type: ignore @property def premium_subscriber_role ( self ) -> Optional [ \"Role\" ]: \"\"\"The role given to boosters of this server, if set\"\"\" for role in self . roles : if role . premium_subscriber : return role return None @property def my_role ( self ) -> Optional [ \"Role\" ]: \"\"\"The role associated with this client, if set\"\"\" m_r_id = self . _client . user . id for role in self . roles : if role . _bot_id == m_r_id : return role return None async def get_owner ( self ) -> \"Member\" : # maybe precache owner instead of using `get_owner` return await self . _client . cache . get_member ( self . id , self . _owner_id ) def is_owner ( self , member : \"Member\" ) -> bool : return self . _owner_id == member . id async def edit ( self , name : Optional [ str ] = MISSING , description : Optional [ str ] = MISSING , verification_level : Optional [ \"VerificationLevels\" ] = MISSING , default_message_notifications : Optional [ \"DefaultNotificationLevels\" ] = MISSING , explicit_content_filter : Optional [ \"ExplicitContentFilterLevels\" ] = MISSING , afk_channel : Optional [ Union [ \"GuildVoice\" , \"Snowflake_Type\" ]] = MISSING , afk_timeout : Optional [ int ] = MISSING , system_channel : Optional [ Union [ \"GuildText\" , \"Snowflake_Type\" ]] = MISSING , system_channel_flags : Optional [ SystemChannelFlags ] = MISSING , # ToDo: these are not tested. Mostly, since I do not have access to those features owner : Optional [ Union [ \"Member\" , \"Snowflake_Type\" ]] = MISSING , icon : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , splash : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , discovery_splash : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , banner : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , rules_channel : Optional [ Union [ \"GuildText\" , \"Snowflake_Type\" ]] = MISSING , public_updates_channel : Optional [ Union [ \"GuildText\" , \"Snowflake_Type\" ]] = MISSING , preferred_locale : Optional [ str ] = MISSING , # ToDo: validate voice region region : Optional [ str ] = MISSING , # ToDo: Fill in guild features. No idea how this works - https://discord.com/developers/docs/resources/guild#guild-object-guild-features features : Optional [ list [ str ]] = MISSING , reason : Optional [ str ] = MISSING , ): \"\"\" Edit the guild. Parameters: name: The new name of the guild. description: The new description of the guild. region: ToDo verification_level: The new verification level for the guild. default_message_notifications: The new notification level for the guild. explicit_content_filter: The new explicit content filter level for the guild. afk_channel: The voice channel that should be the new AFK channel. afk_timeout: How many seconds does a member need to be afk before they get moved to the AFK channel. Must be either `60`, `300`, `900`, `1800` or `3600`, otherwise HTTPException will be raised. icon: The new icon. Requires a bytes like object or a path to an image. owner: The new owner of the guild. You, the bot, need to be owner for this to work. splash: The new invite splash image. Requires a bytes like object or a path to an image. discovery_splash: The new discovery image. Requires a bytes like object or a path to an image. banner: The new banner image. Requires a bytes like object or a path to an image. system_channel: The text channel where new system messages should appear. This includes boosts and welcome messages. system_channel_flags: The new settings for the system channel. rules_channel: The text channel where your rules and community guidelines are displayed. public_updates_channel: The text channel where updates from discord should appear. preferred_locale: The new preferred locale of the guild. Must be an ISO 639 code. features: ToDo reason: An optional reason for the audit log. \"\"\" await self . _client . http . modify_guild ( guild_id = self . id , name = name , description = description , region = region , verification_level = int ( verification_level ) if verification_level else MISSING , default_message_notifications = int ( default_message_notifications ) if default_message_notifications else MISSING , explicit_content_filter = int ( explicit_content_filter ) if explicit_content_filter else MISSING , afk_channel_id = to_snowflake ( afk_channel ) if afk_channel else MISSING , afk_timeout = afk_timeout , icon = to_image_data ( icon ) if icon else MISSING , owner_id = to_snowflake ( owner ) if owner else MISSING , splash = to_image_data ( splash ) if splash else MISSING , discovery_splash = to_image_data ( discovery_splash ) if discovery_splash else MISSING , banner = to_image_data ( banner ) if banner else MISSING , system_channel_id = to_snowflake ( system_channel ) if system_channel else MISSING , system_channel_flags = int ( system_channel_flags ) if system_channel_flags else MISSING , rules_channel_id = to_snowflake ( rules_channel ) if rules_channel else MISSING , public_updates_channel_id = to_snowflake ( public_updates_channel ) if public_updates_channel else MISSING , preferred_locale = preferred_locale , features = features , reason = reason , ) async def create_custom_emoji ( self , name : str , imagefile : Union [ str , \"Path\" , \"IOBase\" ], roles : Optional [ List [ Union [ \"Snowflake_Type\" , \"Role\" ]]] = None , reason : Optional [ str ] = MISSING , ) -> \"CustomEmoji\" : \"\"\" Create a new custom emoji for the guild. parameters: name: Name of the emoji imagefile: The emoji image. (Supports PNG, JPEG, WebP, GIF) roles: Roles allowed to use this emoji. reason: An optional reason for the audit log. returns: The new custom emoji created. \"\"\" data_payload = dict_filter_none ( dict ( name = name , image = to_image_data ( imagefile ), roles = roles , ) ) emoji_data = await self . _client . http . create_guild_emoji ( data_payload , self . id , reason = reason ) emoji_data [ \"guild_id\" ] = self . id return CustomEmoji . from_dict ( emoji_data , self . _client ) # TODO Probably cache it async def create_guild_template ( self , name : str , description : str = None ) -> \"GuildTemplate\" : template = await self . _client . http . create_guild_template ( self . id , name , description ) return GuildTemplate . from_dict ( template , self . _client ) async def get_guild_templates ( self ): templates = await self . _client . http . get_guild_templates ( self . id ) return [ GuildTemplate . from_dict ( t , self . _client ) for t in templates ] async def get_all_custom_emojis ( self ) -> List [ CustomEmoji ]: \"\"\" Gets all the custom emoji present for this guild. returns: A list of custom emoji objects. \"\"\" emojis_data = await self . _client . http . get_all_guild_emoji ( self . id ) return [ CustomEmoji . from_dict ( emoji_data , self . _client ) for emoji_data in emojis_data ] async def get_custom_emoji ( self , emoji_id : \"Snowflake_Type\" ) -> CustomEmoji : \"\"\" Gets the custom emoji present for this guild, based on the emoji id. parameters: emoji_id: The target emoji to get data of. returns: The custom emoji object. \"\"\" emoji_data = await self . _client . http . get_guild_emoji ( self . id , emoji_id ) return CustomEmoji . from_dict ( emoji_data , self . _client ) async def create_channel ( self , channel_type : Union [ ChannelTypes , int ], name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = None , nsfw : bool = False , bitrate : int = 64000 , user_limit : int = 0 , slowmode_delay : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"TYPE_GUILD_CHANNEL\" : \"\"\" Create a guild channel, allows for explicit channel type setting. parameters: channel_type: The type of channel to create name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within nsfw: Should this channel be marked nsfw bitrate: The bitrate of this channel, only for voice user_limit: The max users that can be in this channel, only for voice slowmode_delay: The time users must wait between sending messages reason: The reason for creating this channel returns: The newly created channel. \"\"\" if category : category = to_snowflake ( category ) channel_data = await self . _client . http . create_guild_channel ( self . id , name , channel_type , topic , position , permission_overwrites , category , nsfw , bitrate , user_limit , slowmode_delay , reason , ) return self . _client . cache . place_channel_data ( channel_data ) async def create_text_channel ( self , name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = None , nsfw : bool = False , slowmode_delay : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"GuildText\" : \"\"\" Create a text channel in this guild. parameters: name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within nsfw: Should this channel be marked nsfw slowmode_delay: The time users must wait between sending messages reason: The reason for creating this channel returns: The newly created text channel. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_TEXT , name = name , topic = topic , position = position , permission_overwrites = permission_overwrites , category = category , nsfw = nsfw , slowmode_delay = slowmode_delay , reason = reason , ) async def create_voice_channel ( self , name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = None , nsfw : bool = False , bitrate : int = 64000 , user_limit : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"GuildVoice\" : \"\"\" Create a guild voice channel. parameters: name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within nsfw: Should this channel be marked nsfw bitrate: The bitrate of this channel, only for voice user_limit: The max users that can be in this channel, only for voice reason: The reason for creating this channel returns: The newly created voice channel. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_VOICE , name = name , topic = topic , position = position , permission_overwrites = permission_overwrites , category = category , nsfw = nsfw , bitrate = bitrate , user_limit = user_limit , reason = reason , ) async def create_stage_channel ( self , name : str , topic : Optional [ str ] = MISSING , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , category : Union [ \"Snowflake_Type\" , \"GuildCategory\" ] = MISSING , bitrate : int = 64000 , user_limit : int = 0 , reason : Optional [ str ] = MISSING , ) -> \"GuildStageVoice\" : \"\"\" Create a guild stage channel. parameters: name: The name of the channel topic: The topic of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel category: The category this channel should be within bitrate: The bitrate of this channel, only for voice user_limit: The max users that can be in this channel, only for voice reason: The reason for creating this channel returns: The newly created stage channel. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_STAGE_VOICE , name = name , topic = topic , position = position , permission_overwrites = permission_overwrites , category = category , bitrate = bitrate , user_limit = user_limit , reason = reason , ) async def create_category ( self , name : str , position : int = 0 , permission_overwrites : Optional [ List [ Union [ \"PermissionOverwrite\" , dict ]]] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"GuildCategory\" : \"\"\" Create a category within this guild. parameters: name: The name of the channel position: The position of the channel in the channel list permission_overwrites: Permission overwrites to apply to the channel reason: The reason for creating this channel returns: The newly created category. \"\"\" return await self . create_channel ( channel_type = ChannelTypes . GUILD_CATEGORY , name = name , position = position , permission_overwrites = permission_overwrites , reason = reason , ) async def delete_channel ( self , channel : Union [ \"TYPE_GUILD_CHANNEL\" , \"Snowflake_Type\" ], reason : str = None ) -> None : \"\"\" Delete the given channel, can handle either a snowflake or channel object This is effectively just an alias for `channel.delete()` Args: channel: The channel to be deleted reason: The reason for this deletion \"\"\" if isinstance ( channel , ( str , int )): channel = await self . _client . get_channel ( channel ) if not channel : raise ValueError ( \"Unable to find requested channel\" ) # TODO self._channel_ids is not updated properly when new guild channels are created so this check is # disabled for now # if channel.id not in self._channel_ids: # raise ValueError(\"This guild does not hold the requested channel\") await channel . delete ( reason ) async def create_custom_sticker ( self , name : str , imagefile : Union [ str , \"Path\" , \"IOBase\" ], description : Optional [ str ] = MISSING , tags : Optional [ str ] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"Sticker\" : \"\"\" Creates a custom sticker for a guild Args: name: Sticker name imagefile: Sticker image file description: Sticker description tags: Sticker tags reason: Reason for creating the sticker Returns: New Sticker instance \"\"\" payload = FormData () payload . add_field ( \"name\" , name ) # TODO Validate image type? if isinstance ( imagefile , IOBase ): payload . add_field ( \"file\" , name ) else : payload . add_field ( \"file\" , open ( str ( imagefile ))) if description : payload . add_field ( \"description\" , description ) if tags : payload . add_field ( \"tags\" , tags ) sticker_data = await self . _client . http . create_guild_sticker ( payload , self . id , reason ) return Sticker . from_dict ( sticker_data , self . _client ) async def get_all_custom_stickers ( self ) -> List [ \"Sticker\" ]: \"\"\" Gets all custom stickers for a guild. Returns: List of Sticker objects \"\"\" stickers_data = await self . _client . http . list_guild_stickers ( self . id ) return Sticker . from_list ( stickers_data , self . _client ) async def get_custom_sticker ( self , sticker_id : \"Snowflake_Type\" ) -> \"Sticker\" : \"\"\" Gets a specific custom sticker for a guild Args: sticker_id: ID of sticker to get Returns: Requested Sticker \"\"\" sticker_data = await self . _client . http . get_guild_sticker ( self . id , to_snowflake ( sticker_id )) return Sticker . from_dict ( sticker_data , self . _client ) async def get_active_threads ( self ) -> \"ThreadList\" : \"\"\" Gets all active threads in the guild, including public and private threads. Threads are ordered by their id, in descending order. returns: List of active threads and thread member object for each returned thread the bot user has joined. \"\"\" threads_data = await self . _client . http . list_active_threads ( self . id ) return ThreadList . from_dict ( threads_data , self . _client ) async def get_role ( self , role_id : \"Snowflake_Type\" ) -> Optional [ \"Role\" ]: \"\"\" Get the specified role by ID. Args: role_id: The ID of the role to get Returns: A role object or None if the role is not found. \"\"\" return await self . _client . cache . get_role ( self . id , role_id ) async def create_role ( self , name : Optional [ str ] = MISSING , permissions : Optional [ Permissions ] = MISSING , colour : Optional [ Union [ Color , int ]] = MISSING , color : Optional [ Union [ Color , int ]] = MISSING , hoist : Optional [ bool ] = False , mentionable : Optional [ bool ] = False , # ToDo: icon needs testing. I have to access to that icon : Optional [ Union [ str , \"Path\" , \"IOBase\" ]] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"Role\" : \"\"\" Create a new role for the guild. You must have the `manage roles` permission. Args: name: The name the role should have. `Default: new role` permissions: The permissions the role should have. `Default: @everyone permissions` colour: The colour of the role. Can be either `Color` or an RGB integer. `Default: BrandColors.BLACK` color: Alias for `colour` icon: Can be either a bytes like object or a path to an image, or a unicode emoji which is supported by discord. hoist: Whether the role is shown separately in the members list. `Default: False` mentionable: Whether the role can be mentioned. `Default: False` reason: An optional reason for the audit log. Returns: A role object or None if the role is not found. \"\"\" payload = {} if name : payload . update ({ \"name\" : name }) if permissions : payload . update ({ \"permissions\" : str ( int ( permissions ))}) colour = colour or color if colour : payload . update ({ \"color\" : colour . value }) if hoist : payload . update ({ \"hoist\" : True }) if mentionable : payload . update ({ \"mentionable\" : True }) if icon : # test if the icon is probably a unicode emoji (str and len() == 1) or a path / bytes obj if isinstance ( icon , str ) and len ( icon ) == 1 : payload . update ({ \"unicode_emoji\" : icon }) else : payload . update ({ \"icon\" : to_image_data ( icon )}) result = await self . _client . http . create_guild_role ( guild_id = self . id , payload = payload , reason = reason ) return self . _client . cache . place_role_data ( guild_id = self . id , data = [ result ])[ to_snowflake ( result [ \"id\" ])] async def get_channel ( self , channel_id : \"Snowflake_Type\" ) -> Optional [ Union [ \"TYPE_GUILD_CHANNEL\" , \"TYPE_THREAD_CHANNEL\" ]]: \"\"\" Returns a channel with the given `channel_id` Args: channel_id: The ID of the channel to get Returns: Channel object if found, otherwise None \"\"\" if channel_id in self . _channel_ids and channel_id not in self . _thread_ids : # theoretically, this could get any channel the client can see, # but to make it less confusing to new programmers, # i intentionally check that the guild contains the channel first return await self . _client . cache . get_channel ( channel_id ) return None async def get_thread ( self , thread_id : \"Snowflake_Type\" ) -> Optional [ \"TYPE_THREAD_CHANNEL\" ]: \"\"\" Returns a Thread with the given `thread_id` Args: thread_id: The ID of the thread to get Returns: Channel object if found, otherwise None \"\"\" # get_channel can retrieve threads, so this is basically an alias with extra steps for that if thread_id in self . _thread_ids : return await self . get_channel ( thread_id ) return None async def prune_members ( self , days : int = 7 , roles : List [ Union [ \"Snowflake_Type\" , \"Role\" ]] = MISSING , compute_prune_count : bool = True , reason : str = MISSING , ) -> Optional [ int ]: \"\"\" Begin a guild prune. Removes members from the guild who who have not interacted for the last `days` days. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles` Requires `kick members` permission. Args: days: number of days to prune (1-30) roles: list of roles to include in the prune compute_prune_count: Whether the number of members pruned should be calculated (disable this for large guilds) reason: The reason for this prune Returns: The total number of members pruned, if `compute_prune_count` is set to True, otherwise None \"\"\" if roles is not MISSING : roles = [ r . id if isinstance ( r , Role ) else r for r in roles ] else : roles = [] resp = await self . _client . http . begin_guild_prune ( self . id , days , include_roles = roles , compute_prune_count = compute_prune_count , reason = reason ) return resp [ \"pruned\" ] async def estimate_prune_members ( self , days : int = 7 , roles : List [ Union [ \"Snowflake_Type\" , \"Role\" ]] = MISSING ) -> int : \"\"\" Calculate how many members would be pruned, should `guild.prune_members` be used. By default, members with roles are excluded from pruning, to include them, pass their role (or role id) in `roles` Args: days: number of days to prune (1-30) roles: list of roles to include in the prune Returns: Total number of members that would be pruned \"\"\" if roles is not MISSING : roles = [ r . id if isinstance ( r , Role ) else r for r in roles ] else : roles = [] resp = await self . _client . http . get_guild_prune_count ( self . id , days = days , include_roles = roles ) return resp [ \"pruned\" ] async def leave ( self ) -> None : \"\"\"Leave this guild\"\"\" await self . _client . http . leave_guild ( self . id ) async def delete ( self ) -> None : \"\"\"Delete the guild. You must own this guild to do this.\"\"\" await self . _client . http . delete_guild ( self . id ) async def kick ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ], reason : str = MISSING ) -> None : \"\"\" Kick a user from the guild. You must have the `kick members` permission Args: user: The user to kick reason: The reason for the kick \"\"\" await self . _client . http . remove_guild_member ( self . id , to_snowflake ( user ), reason = reason ) async def ban ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ], delete_message_days : int = 0 , reason : str = MISSING ) -> None : \"\"\" Ban a user from the guild. You must have the `ban members` permission Args: user: The user to ban delete_message_days: How many days worth of messages to remove reason: The reason for the ban \"\"\" await self . _client . http . create_guild_ban ( self . id , to_snowflake ( user ), delete_message_days , reason = reason ) async def get_ban ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ]) -> GuildBan : \"\"\" Get's the ban information for the specified user in the guild. You must have the `ban members` permission Args: user: The user to look up. Raises: NotFound: If the user is not banned in the guild. Returns: The ban information. \"\"\" ban_info = await self . _client . http . get_guild_ban ( self . id , to_snowflake ( user )) return GuildBan ( reason = ban_info [ \"reason\" ], user = self . _client . cache . place_user_data ( ban_info [ \"user\" ])) async def get_bans ( self ) -> list [ GuildBan ]: \"\"\" Get's all bans for the guild. You must have the `ban members` permission Returns: A list containing all bans and information about them. \"\"\" ban_infos = await self . _client . http . get_guild_bans ( self . id ) return [ GuildBan ( reason = ban_info [ \"reason\" ], user = self . _client . cache . place_user_data ( ban_info [ \"user\" ])) for ban_info in ban_infos ] async def unban ( self , user : Union [ \"User\" , \"Member\" , \"Snowflake_Type\" ], reason : str = MISSING ) -> None : \"\"\" Unban a user from the guild. You must have the `ban members` permission Args: user: The user to unban reason: The reason for the ban \"\"\" await self . _client . http . remove_guild_ban ( self . id , to_snowflake ( user ), reason = reason ) async def get_widget_image ( self , style : str = None ) -> str : \"\"\" Get a guilds widget image For a list of styles, look here: https://discord.com/developers/docs/resources/guild#get-guild-widget-image-widget-style-options Args: style: The style to use for the widget image \"\"\" return await self . _client . http . get_guild_widget_image ( self . id , style ) async def get_widget ( self ) -> dict : \"\"\" Gets the guilds widget \"\"\" # todo: Guild widget object return await self . _client . http . get_guild_widget ( self . id ) async def modify_widget ( self , enabled : bool = None , channel : Union [ \"TYPE_GUILD_CHANNEL\" , \"Snowflake_Type\" ] = None ) -> dict : \"\"\" Modify the guild's widget. Args: enabled: Should the widget be enabled? channel: The channel to use in the widget \"\"\" if channel : if isinstance ( channel , DiscordObject ): channel = channel . id return await self . _client . http . modify_guild_widget ( self . id , enabled , channel ) async def get_invites ( self ) -> List [ \"Invite\" ]: invites_data = await self . _client . http . get_guild_invites ( self . id ) return Invite . from_list ( invites_data , self . _client ) async def get_guild_integrations ( self ) -> List [ \"GuildIntegration\" ]: data = await self . _client . http . get_guild_integrations ( self . id ) return [ GuildIntegration . from_dict ( d | { \"guild_id\" : self . id }, self . _client ) for d in data ]","title":"Guild"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.guild.GuildTemplate","text":"Source code in dis_snek/models/discord_objects/guild.py @define () class GuildTemplate ( ClientObject ): code : str = attr . ib ( metadata = docs ( \"the template code (unique ID)\" )) name : str = attr . ib ( metadata = docs ( \"the name\" )) description : Optional [ str ] = attr . ib ( default = None , metadata = docs ( \"the description\" )) usage_count : int = attr . ib ( default = 0 , metadata = docs ( \"number of times this template has been used\" )) creator_id : \"Snowflake_Type\" = attr . ib ( metadata = docs ( \"The ID of the user who created this template\" )) creator : Optional [ \"User\" ] = attr . ib ( default = None , metadata = docs ( \"the user who created this template\" )) created_at : \"Timestamp\" = attr . ib ( metadata = docs ( \"When this template was created\" )) updated_at : \"Timestamp\" = attr . ib ( metadata = docs ( \"When this template was last synced to the source guild\" )) source_guild_id : \"Snowflake_Type\" = attr . ib ( metadata = docs ( \"The ID of the guild this template is based on\" )) guild_snapshot : \"Guild\" = attr . ib ( metadata = docs ( \"A snapshot of the guild this template contains\" )) is_dirty : bool = attr . ib ( default = False , metadata = docs ( \"Whether this template has un-synced changes\" )) @classmethod def _process_dict ( cls , data , client ): data [ \"creator\" ] = client . cache . place_user_data ( data [ \"creator\" ]) # todo: partial guild obj that **isn't** cached data [ \"guild_snapshot\" ] = data . pop ( \"serialized_source_guild\" ) return data async def synchronise ( self ) -> \"GuildTemplate\" : \"\"\"Synchronise the template to the source guild's current state\"\"\" data = await self . _client . http . sync_guild_template ( self . source_guild_id , self . code ) self . update_from_dict ( data ) return self async def modify ( self , name : Optional [ str ] = None , description : Optional [ str ] = None ) -> \"GuildTemplate\" : \"\"\" Modify the template's metadata. Arguments: name: The name for the template description: The description for the template \"\"\" data = await self . _client . http . modify_guild_template ( self . source_guild_id , self . code , name = name , description = description ) self . update_from_dict ( data ) return self async def delete ( self ) -> None : \"\"\"Delete the guild template\"\"\" await self . _client . http . delete_guild_template ( self . source_guild_id , self . code )","title":"GuildTemplate"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.guild.GuildWelcomeChannel","text":"Source code in dis_snek/models/discord_objects/guild.py @define () class GuildWelcomeChannel ( ClientObject ): channel_id : \"Snowflake_Type\" = attr . ib ( metadata = docs ( \"Welcome Channel ID\" )) description : str = attr . ib ( metadata = docs ( \"Welcome Channel description\" )) emoji_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , metadata = docs ( \"Welcome Channel emoji ID if the emoji is custom\" ) ) emoji_name : Optional [ str ] = attr . ib ( default = None , metadata = docs ( \"Emoji name if custom, unicode character if standard\" ) )","title":"GuildWelcomeChannel"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.guild.GuildWelcome","text":"Source code in dis_snek/models/discord_objects/guild.py @define () class GuildWelcome ( ClientObject ): description : Optional [ str ] = attr . ib ( default = None , metadata = docs ( \"Welcome Screen server description\" )) welcome_channels : List [ \"GuildWelcomeChannel\" ] = attr . ib ( metadata = docs ( \"List of Welcome Channel objects, up to 5\" ))","title":"GuildWelcome"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.guild.GuildIntegration","text":"Source code in dis_snek/models/discord_objects/guild.py class GuildIntegration ( DiscordObject ): name : str = attr . ib () type : str = attr . ib () enabled : bool = attr . ib () account : dict = attr . ib () application : Optional [ Application ] = attr . ib ( default = None ) _guild_id : \"Snowflake_Type\" = attr . ib () syncing : Optional [ bool ] = attr . ib ( default = MISSING ) role_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = MISSING ) enable_emoticons : bool = attr . ib ( default = MISSING ) expire_behavior : IntegrationExpireBehaviour = attr . ib ( default = MISSING , converter = optional ( IntegrationExpireBehaviour ) ) expire_grace_period : int = attr . ib ( default = MISSING ) user : \"BaseUser\" = attr . ib ( default = MISSING ) synced_at : \"Timestamp\" = attr . ib ( default = MISSING , converter = optional ( timestamp_converter )) subscriber_count : int = attr . ib ( default = MISSING ) revoked : bool = attr . ib ( default = MISSING ) @classmethod def from_dict ( cls , data , client ): if app := data . get ( \"application\" , None ): data [ \"application\" ] = Application . from_dict ( app , client ) if user := data . get ( \"user\" , None ): data [ \"user\" ] = client . cache . place_user_data ( user ) return super () . from_dict ( data , client ) async def delete ( self , reason : str = MISSING ): \"\"\"Delete this guild integration\"\"\" await self . _client . http . delete_guild_integration ( self . _guild_id , self . id , reason )","title":"GuildIntegration"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.Attachment","text":"Source code in dis_snek/models/discord_objects/message.py @define () class Attachment ( DiscordObject ): filename : str = attr . ib () content_type : Optional [ str ] = attr . ib ( default = None ) size : int = attr . ib () url : str = attr . ib () proxy_url : str = attr . ib () height : Optional [ int ] = attr . ib ( default = None ) width : Optional [ int ] = attr . ib ( default = None ) @property def size ( self ): return self . height , self . width","title":"Attachment"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.ChannelMention","text":"Source code in dis_snek/models/discord_objects/message.py @define () class ChannelMention ( DiscordObject ): guild_id : \"Snowflake_Type\" = attr . ib () type : ChannelTypes = attr . ib ( converter = ChannelTypes ) name : str = attr . ib ()","title":"ChannelMention"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.MessageActivity","text":"MessageActivity(type: dis_snek.models.enums.MessageActivityTypes, party_id: str = None) Source code in dis_snek/models/discord_objects/message.py @dataclass class MessageActivity : type : MessageActivityTypes party_id : str = None","title":"MessageActivity"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.MessageReference","text":"Reference to an originating message. Can be used for replies. Source code in dis_snek/models/discord_objects/message.py @attr . s ( slots = True ) class MessageReference ( DictSerializationMixin ): \"\"\"Reference to an originating message. Can be used for replies.\"\"\" message_id : int = attr . ib ( default = None , converter = optional_c ( to_snowflake )) \"\"\"id of the originating message.\"\"\" channel_id : Optional [ int ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) \"\"\"id of the originating message's channel.\"\"\" guild_id : Optional [ int ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) \"\"\"id of the originating message's guild.\"\"\" fail_if_not_exists : bool = attr . ib ( default = True ) \"\"\"When sending a message, whether to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message, default true.\"\"\" @classmethod def for_message ( cls , message : \"Message\" , fail_if_not_exists : bool = True ) -> \"MessageReference\" : return cls ( message_id = message . id , channel_id = message . channel . id , guild_id = message . guild . id , fail_if_not_exists = fail_if_not_exists , )","title":"MessageReference"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.MessageInteraction","text":"Source code in dis_snek/models/discord_objects/message.py @define class MessageInteraction ( DiscordObject ): type : InteractionTypes = attr . ib ( converter = InteractionTypes ) name : str = attr . ib () _user_id : \"Snowflake_Type\" = attr . ib () @classmethod def _process_dict ( cls , data , client ): user_data = data [ \"user\" ] data [ \"user_id\" ] = client . cache . place_user_data ( user_data ) . id return data async def user ( self ) -> \"User\" : \"\"\" Get the user associated with this interaction. \"\"\" return await self . get_user ( self . _user_id )","title":"MessageInteraction"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.AllowedMentions","text":"The allowed mention field allows for more granular control over mentions without various hacks to the message content. This will always validate against message content to avoid phantom pings, and check against user/bot permissions. Source code in dis_snek/models/discord_objects/message.py @attr . s ( slots = True ) class AllowedMentions : \"\"\" The allowed mention field allows for more granular control over mentions without various hacks to the message content. This will always validate against message content to avoid phantom pings, and check against user/bot permissions. \"\"\" parse : Optional [ List [ str ]] = attr . ib ( factory = list ) \"\"\"An array of allowed mention types to parse from the content.\"\"\" roles : Optional [ List [ \"Snowflake_Type\" ]] = attr . ib ( factory = list ) \"\"\"Array of role_ids to mention. (Max size of 100)\"\"\" users : Optional [ List [ \"Snowflake_Type\" ]] = attr . ib ( factory = list ) \"\"\"Array of user_ids to mention. (Max size of 100)\"\"\" replied_user = attr . ib ( default = False ) \"\"\"For replies, whether to mention the author of the message being replied to. (default false)\"\"\" def add_roles ( self , * roles : Union [ \"Role\" , \"Snowflake_Type\" ]): for role in roles : if isinstance ( role , DiscordObject ): role = role . id self . roles . append ( role ) def add_users ( self , * users : Union [ \"Member\" , \"BaseUser\" , \"Snowflake_Type\" ]): for user in users : if isinstance ( user , DiscordObject ): user = user . id self . users . append ( user ) def to_dict ( self ) -> dict : return attr . asdict ( self , filter = lambda key , value : isinstance ( value , bool ) or value ) @classmethod def all ( cls ): return cls ( parse = list ( MentionTypes . __members__ . values ()), replied_user = True ) @classmethod def none ( cls ): return cls ()","title":"AllowedMentions"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.Message","text":"Source code in dis_snek/models/discord_objects/message.py @define () class Message ( DiscordObject ): content : str = attr . ib () timestamp : Timestamp = attr . ib ( converter = timestamp_converter ) edited_timestamp : Optional [ Timestamp ] = attr . ib ( default = None , converter = optional_c ( timestamp_converter )) tts : bool = attr . ib ( default = False ) mention_everyone : bool = attr . ib ( default = False ) mention_channels : Optional [ List [ ChannelMention ]] = attr . ib ( default = None ) attachments : List [ Attachment ] = attr . ib ( factory = list ) embeds : List [ Embed ] = attr . ib ( factory = list ) reactions : List [ Reaction ] = attr . ib ( factory = list ) nonce : Optional [ Union [ int , str ]] = attr . ib ( default = None ) pinned : bool = attr . ib ( default = False ) webhook_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) type : MessageTypes = attr . ib ( converter = MessageTypes ) activity : Optional [ MessageActivity ] = attr . ib ( default = None , converter = optional_c ( MessageActivity )) application : Optional [ \"Application\" ] = attr . ib ( default = None ) # TODO: partial application application_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) message_reference : Optional [ MessageReference ] = attr . ib ( default = None , converter = optional_c ( MessageReference . from_dict ) ) flags : Optional [ MessageFlags ] = attr . ib ( default = None , converter = optional_c ( MessageFlags )) interaction : Optional [ \"MessageInteraction\" ] = attr . ib ( default = None ) components : Optional [ List [ \"ActionRow\" ]] = attr . ib ( default = None ) sticker_items : Optional [ List [ StickerItem ]] = attr . ib ( default = None ) # TODO: Perhaps automatically get the full sticker data. _channel_id : \"Snowflake_Type\" = attr . ib ( converter = optional_c ( to_snowflake )) _guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) _author_id : \"Snowflake_Type\" = attr . ib ( converter = optional_c ( to_snowflake ) ) # TODO: create override for detecting PartialMember _mention_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _mention_roles : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) _referenced_message_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) _thread_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional_c ( to_snowflake )) channel : \"TextChannel\" = attr . ib ( default = None ) thread : \"Thread\" = attr . ib ( default = None ) guild : \"Guild\" = attr . ib ( default = None ) author : Union [ \"Member\" , \"User\" ] = attr . ib ( default = None ) @property async def mention_users ( self ) -> AsyncGenerator [ \"Member\" , None ]: for u_id in self . _mention_ids : yield await self . _client . cache . get_member ( self . _guild_id , u_id ) @property async def mention_roles ( self ) -> AsyncGenerator [ \"Role\" , None ]: for r_id in self . _mention_roles : yield await self . _client . cache . get_role ( self . _guild_id , r_id ) async def get_referenced_message ( self ) -> Optional [ \"Message\" ]: \"\"\" Get the message this message is referencing, if any Returns: The referenced message, if found \"\"\" if self . _referenced_message_id is None : return None return await self . _client . cache . get_message ( self . _channel_id , self . _referenced_message_id ) @classmethod def _process_dict ( cls , data : dict , client : \"Snake\" ) -> dict : # TODO: Is there a way to dynamically do this instead of hard coding? try : author_data = data . pop ( \"author\" ) except KeyError : # todo: properly handle message updates that change flags (ie recipient add) return data if \"guild_id\" in data and \"member\" in data : author_data [ \"member\" ] = data . pop ( \"member\" ) data [ \"author_id\" ] = client . cache . place_member_data ( data [ \"guild_id\" ], author_data ) . id else : data [ \"author_id\" ] = client . cache . place_user_data ( author_data ) . id mention_ids = [] for user_data in data . pop ( \"mentions\" , {}): if \"guild_id\" in data and \"member\" in user_data : mention_ids . append ( client . cache . place_member_data ( data [ \"guild_id\" ], user_data ) . id ) else : mention_ids . append ( client . cache . place_user_data ( user_data ) . id ) data [ \"mention_ids\" ] = mention_ids if \"mention_channels\" in data : mention_channels = [] for channel_data in data [ \"mention_channels\" ]: mention_channels . append ( ChannelMention . from_dict ( channel_data , client )) data [ \"mention_channels\" ] = mention_channels attachments = [] for attachment_data in data [ \"attachments\" ]: attachments . append ( Attachment . from_dict ( attachment_data , client )) data [ \"attachments\" ] = attachments embeds = [] for embed_data in data [ \"embeds\" ]: embeds . append ( Embed . from_dict ( embed_data )) data [ \"embeds\" ] = embeds if \"reactions\" in data : reactions = [] for reaction_data in data [ \"reactions\" ]: reactions . append ( Reaction . from_dict ( reaction_data | { \"message_id\" : data [ \"id\" ], \"channel_id\" : data [ \"channel_id\" ]}, client ) ) data [ \"reactions\" ] = reactions # TODO: Convert to application object ref_message_data = data . pop ( \"referenced_message\" , None ) if ref_message_data : data [ \"referenced_message_id\" ] = client . cache . place_message_data ( ref_message_data ) if \"interaction\" in data : data [ \"interaction\" ] = MessageInteraction . from_dict ( data [ \"interaction\" ], client ) thread_data = data . pop ( \"thread\" , None ) if thread_data : data [ \"thread_channel_id\" ] = client . cache . place_channel_data ( thread_data ) . id if \"components\" in data : components = [] for component_data in data [ \"components\" ]: components . append ( BaseComponent . from_dict_factory ( component_data )) data [ \"components\" ] = components if \"sticker_items\" in data : data [ \"sticker_items\" ] = StickerItem . from_list ( data [ \"sticker_items\" ], client ) return data @property def jump_url ( self ) -> str : \"\"\"A url that allows the client to *jump* to this message\"\"\" return f \"https://discord.com/channels/ { self . _guild_id or '@me' } / { self . _channel_id } / { self . id } \" @property def proto_url ( self ) -> str : \"\"\"A URL like `jump_url` that uses protocols\"\"\" return f \"discord://-/channels/ { self . _guild_id or '@me' } / { self . _channel_id } / { self . id } \" async def edit ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ Embed , dict ]], Union [ Embed , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , allowed_mentions : Optional [ Union [ AllowedMentions , dict ]] = None , attachments : Optional [ Optional [ List [ Union [ Attachment , dict ]]]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , MessageFlags ]] = None , ) -> \"Message\" : \"\"\" Edits the message. Args: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. allowed_mentions: Allowed mentions for the message. attachments: The attachments to keep, only used when editing message. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. Returns: New message object with edits applied \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , attachments = attachments , file = file , tts = tts , flags = flags , ) if self . flags == MessageFlags . EPHEMERAL : raise EphemeralEditException () message_data = await self . _client . http . edit_message ( message_payload , self . _channel_id , self . id ) if message_data : return self . _client . cache . place_message_data ( message_data ) async def delete ( self , delay : Optional [ int ] = MISSING ): \"\"\" Delete message. Args: delay: Seconds to wait before deleting message. \"\"\" if delay and delay > 0 : async def delayed_delete (): await asyncio . sleep ( delay ) try : await self . _client . http . delete_message ( self . _channel_id , self . id ) except Exception : pass # No real way to handle this asyncio . ensure_future ( delayed_delete ()) else : await self . _client . http . delete_message ( self . _channel_id , self . id ) async def reply ( self , content : Optional [ str ], ** kwargs ) -> \"Message\" : \"\"\"Reply to this message, takes all the same attributes as `send`\"\"\" return await self . channel . send ( content = content , reply_to = self , ** kwargs ) async def create_thread ( self , name : str , auto_archive_duration : Union [ AutoArchiveDuration , int ] = AutoArchiveDuration . ONE_DAY , reason : Optional [ str ] = None , ): \"\"\" Create a thread from this message Args: name: The name of this thread auto_archive_duration: duration in minutes to automatically archive the thread after recent activity, can be set to: 60, 1440, 4320, 10080 reason: The optional reason for creating this thread Returns: The created thread object Raises: ThreadOutsideOfGuild: if this is invoked on a message outside of a guild \"\"\" if not isinstance ( await self . channel , GuildText ): raise ThreadOutsideOfGuild () thread_data = await self . _client . http . create_thread ( channel_id = self . _channel_id , name = name , auto_archive_duration = auto_archive_duration , message_id = self . id , reason = reason , ) return self . _client . cache . place_channel_data ( thread_data ) async def get_reaction ( self , emoji : Union [ \"Emoji\" , dict , str ]) -> List [ \"User\" ]: \"\"\" Get reactions of a specific emoji from this message Args: emoji: The emoji to get Returns: list of users who have reacted with that emoji \"\"\" reaction_data = await self . _client . http . get_reactions ( self . _channel_id , self . id , emoji ) return [ self . _client . cache . place_user_data ( user_data ) for user_data in reaction_data ] async def add_reaction ( self , emoji : Union [ \"Emoji\" , dict , str ]): \"\"\" Add a reaction to this message. Args: emoji: the emoji to react with \"\"\" emoji = process_emoji_req_format ( emoji ) await self . _client . http . create_reaction ( self . _channel_id , self . id , emoji ) async def remove_reaction ( self , emoji : Union [ \"Emoji\" , dict , str ], member : Optional [ Union [ \"Member\" , \"User\" , \"Snowflake_Type\" ]] = MISSING ): \"\"\" Remove a specific reaction that a user reacted with Args: emoji: Emoji to remove member: Member to remove reaction of. Default's to snake bot user. \"\"\" emoji_str = process_emoji_req_format ( emoji ) if not member : member = self . _client . user user_id = to_snowflake ( member ) await self . _client . http . remove_user_reaction ( self . _channel_id , self . id , emoji_str , user_id ) async def clear_reactions ( self , emoji : Union [ \"Emoji\" , dict , str ]): # TODO Should we combine this with clear_all_reactions? \"\"\" Clear a specific reaction from message Args: emoji: The emoji to clear \"\"\" emoji = process_emoji_req_format ( emoji ) await self . _client . http . clear_reaction ( self . _channel_id , self . id , emoji ) async def clear_all_reactions ( self ): \"\"\"Clear all emojis from a message.\"\"\" await self . _client . http . clear_reactions ( self . channel . id , self . id ) async def pin ( self ): \"\"\"Pin message\"\"\" await self . _client . http . pin_message ( self . _channel_id , self . id ) self . pinned = True async def unpin ( self ): \"\"\"Unpin message\"\"\" await self . _client . http . unpin_message ( self . _channel_id , self . id ) self . pinned = False async def publish ( self ): \"\"\"Publish this message. (Discord api calls it \"crosspost\")\"\"\" await self . _client . http . crosspost_message ( self . _channel_id , self . id )","title":"Message"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.process_allowed_mentions","text":"Process allowed mentions into a dictionary Parameters: Name Type Description Default allowed_mentions Union[dis_snek.models.discord_objects.message.AllowedMentions, dict] Allowed mentions object or dictionary required Returns: Type Description Optional[dict] Dictionary of allowed mentions Exceptions: Type Description ValueError Invalid allowed mentions Source code in dis_snek/models/discord_objects/message.py def process_allowed_mentions ( allowed_mentions : Optional [ Union [ AllowedMentions , dict ]]) -> Optional [ dict ]: \"\"\" Process allowed mentions into a dictionary Args: allowed_mentions: Allowed mentions object or dictionary Returns: Dictionary of allowed mentions Raises: ValueError: Invalid allowed mentions \"\"\" if not allowed_mentions : return allowed_mentions if isinstance ( allowed_mentions , dict ): return allowed_mentions if isinstance ( allowed_mentions , AllowedMentions ): return allowed_mentions . to_dict () raise ValueError ( f \"Invalid allowed mentions: { allowed_mentions } \" )","title":"process_allowed_mentions()"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.process_message_reference","text":"Process mention references into a dictionary Parameters: Name Type Description Default message_reference Union[dis_snek.models.discord_objects.message.MessageReference, dis_snek.models.discord_objects.message.Message, dict, Snowflake_Type] Message reference object required Returns: Type Description Optional[dict] Message reference dictionary Exceptions: Type Description ValueError Invalid message reference Source code in dis_snek/models/discord_objects/message.py def process_message_reference ( message_reference : Optional [ Union [ MessageReference , Message , dict , \"Snowflake_Type\" ]] ) -> Optional [ dict ]: \"\"\" Process mention references into a dictionary Args: message_reference: Message reference object Returns: Message reference dictionary Raises: ValueError: Invalid message reference \"\"\" if not message_reference : return message_reference if isinstance ( message_reference , dict ): return message_reference if isinstance ( message_reference , ( str , int )): message_reference = MessageReference ( message_id = message_reference ) if isinstance ( message_reference , Message ): message_reference = MessageReference . for_message ( message_reference ) if isinstance ( message_reference , MessageReference ): return message_reference . to_dict () raise ValueError ( f \"Invalid message reference: { message_reference } \" )","title":"process_message_reference()"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.message.process_message_payload","text":"Format message content for it to be ready to send discord. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[dis_snek.models.discord_objects.embed.Embed, dict]], dis_snek.models.discord_objects.embed.Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[dis_snek.models.discord_objects.components.BaseComponent, dict]]], List[Union[dis_snek.models.discord_objects.components.BaseComponent, dict]], dis_snek.models.discord_objects.components.BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[dis_snek.models.discord_objects.message.AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[dis_snek.models.discord_objects.message.MessageReference, dis_snek.models.discord_objects.message.Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None attachments Optional[List[Union[dis_snek.models.discord_objects.message.Attachment, dict]]] The attachments to keep, only used when editing message. None file Union[File, IOBase, Path, str] Location of file to send, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, dis_snek.models.enums.MessageFlags] Message flags to apply. None Returns: Type Description Union[Dict, aiohttp.formdata.FormData] Dictionary or multipart data form. Source code in dis_snek/models/discord_objects/message.py def process_message_payload ( content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ Embed , dict ]], Union [ Embed , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ BaseComponent , dict ]]], List [ Union [ BaseComponent , dict ]], BaseComponent , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ AllowedMentions , dict ]] = None , reply_to : Optional [ Union [ MessageReference , Message , dict , \"Snowflake_Type\" ]] = None , attachments : Optional [ List [ Union [ Attachment , dict ]]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , MessageFlags ]] = None , ) -> Union [ Dict , FormData ]: \"\"\" Format message content for it to be ready to send discord. Args: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. attachments: The attachments to keep, only used when editing message. file: Location of file to send, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. Returns: Dictionary or multipart data form. \"\"\" content = content embeds = process_embeds ( embeds ) components = process_components ( components ) if stickers : stickers = [ to_snowflake ( sticker ) for sticker in stickers ] allowed_mentions = process_allowed_mentions ( allowed_mentions ) message_reference = process_message_reference ( reply_to ) if attachments : attachments = [ attachment . to_dict () for attachment in attachments ] message_data = dict_filter_none ( dict ( content = content , embeds = embeds , components = components , sticker_ids = stickers , allowed_mentions = allowed_mentions , message_reference = message_reference , attachments = attachments , tts = tts , flags = flags , ) ) if file : # We need to use multipart/form-data for file sending here. form = FormData () form . add_field ( \"payload_json\" , OverriddenJson . dumps ( message_data )) if isinstance ( file , File ): if isinstance ( file . file , IOBase ): form . add_field ( \"file\" , file . file , filename = file . file_name ) else : form . add_field ( \"file\" , open ( str ( file . file ), \"rb\" ), filename = file . file_name ) elif isinstance ( file , IOBase ): form . add_field ( \"file\" , file ) else : form . add_field ( \"file\" , open ( str ( file ), \"rb\" )) return form else : return message_data","title":"process_message_payload()"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.reaction.ReactionUsers","text":"An async iterator for searching through a channel's history Parameters: Name Type Description Default channel_id The ID of the channel to search through required limit The maximum number of users to return (set to 0 for no limit) 50 after get users after this message ID None Source code in dis_snek/models/discord_objects/reaction.py class ReactionUsers ( AsyncIterator ): \"\"\" An async iterator for searching through a channel's history Args: channel_id: The ID of the channel to search through limit: The maximum number of users to return (set to 0 for no limit) after: get users after this message ID \"\"\" def __init__ ( self , reaction : \"Reaction\" , limit = 50 , after = None ): self . reaction : \"Reaction\" = reaction self . after : \"Snowflake_Type\" = after self . _more = True super () . __init__ ( limit ) async def fetch ( self ): if self . _more : expected = self . get_limit if self . after and not self . last : self . last = namedtuple ( \"temp\" , \"id\" ) self . last . id = self . after users = await self . reaction . _client . http . get_reactions ( self . reaction . _channel_id , self . reaction . _message_id , self . reaction . emoji . req_format , limit = expected , after = self . last . id or MISSING , ) if not users : raise QueueEmpty () self . _more = len ( users ) == expected return [ self . reaction . _client . cache . place_user_data ( u ) for u in users ] else : raise QueueEmpty ()","title":"ReactionUsers"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.reaction.Reaction","text":"Source code in dis_snek/models/discord_objects/reaction.py @define () class Reaction ( ClientObject ): count : int = attr . ib () me : bool = attr . ib ( default = False ) emoji : \"Emoji\" = attr . ib ( converter = Emoji . from_dict ) _channel_id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) _message_id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) def users ( self , limit : int = 0 , after = None ) -> ReactionUsers : return ReactionUsers ( self , limit , after ) @property def message ( self ): return self . _client . cache . message_cache . get (( self . _channel_id , self . _message_id )) @property def channel ( self ): return self . _client . cache . channel_cache . get ( self . _channel_id ) async def remove ( self ): \"\"\"Remove all this emoji's reactions from the message\"\"\" await self . _client . http . clear_reaction ( self . _channel_id , self . _message_id , self . emoji . req_format )","title":"Reaction"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.role.Role","text":"Source code in dis_snek/models/discord_objects/role.py @define () class Role ( DiscordObject ): _sentinel = object () name : str = field ( repr = True ) color : \"Color\" = field ( converter = Color ) hoist : bool = field ( default = False ) position : int = field ( repr = True ) permissions : \"Permissions\" = field ( converter = Permissions ) managed : bool = field ( default = False ) mentionable : bool = field ( default = True ) premium_subscriber : bool = field ( default = _sentinel , converter = partial ( sentinel_converter , sentinel = _sentinel )) guild : \"Guild\" = field ( default = None ) _guild_id : \"Snowflake_Type\" = field () _bot_id : Optional [ \"Snowflake_Type\" ] = field ( default = None ) integration_id : Optional [ \"Snowflake_Type\" ] = field ( default = None ) # todo integration object? @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data . update ( data . pop ( \"tags\" , {})) return data async def get_bot ( self ) -> Optional [ \"Member\" ]: \"\"\" Get the bot associated with this role if any. Returns: Member object if any \"\"\" if self . _bot_id is None : return None return await self . _client . cache . get_member ( self . _guild_id , self . _bot_id ) @property def default ( self ) -> bool : \"\"\"Is this the `@everyone` role\"\"\" return self . id == self . _guild_id @property def bot_managed ( self ) -> bool : \"\"\"Is this role owned/managed by a bot\"\"\" return self . bot_id is not None @property def mention ( self ) -> str : \"\"\"Returns a string that would mention the role\"\"\" return f \"<@& { self . id } >\" @property def integration ( self ) -> bool : \"\"\"Is this role owned/managed by a integration\"\"\" return self . tags . integration_id is not None async def is_assignable ( self ) -> bool : \"\"\"Can this role be assigned or removed by this bot? !!! note: This does not account for permissions, only the role hierarchy\"\"\" me = await self . guild . me if ( self . default or await me . top_role . position > self . position ) and not self . managed : return True return False async def delete ( self , reason : str = None ): \"\"\" Delete this role Args: reason: An optional reason for this deletion \"\"\" await self . _client . http . delete_guild_role ( self . _guild_id , self . id , reason ) async def edit ( self , name : str = MISSING , permissions : str = MISSING , color : Union [ int , Color ] = MISSING , hoist : bool = MISSING , mentionable : bool = MISSING , ) -> \"Role\" : \"\"\" Edit this role, all arguments are optional. Args: name: name of the role permissions: New permissions to use color: The color of the role hoist: whether the role should be displayed separately in the sidebar mentionable: whether the role should be mentionable Returns: Role with updated information \"\"\" if isinstance ( color , Color ): color = color . value payload = dict_filter_missing ( dict ( name = name , permissions = permissions , color = color , hoist = hoist , mentionable = mentionable ) ) r_data = await self . _client . http . modify_guild_role ( self . _guild_id , self . id , payload ) r_data [ \"guild_id\" ] = self . _guild_id return self . from_dict ( r_data , self . _client )","title":"Role"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.sticker.StickerTypes","text":"Types of sticker. Source code in dis_snek/models/discord_objects/sticker.py class StickerTypes ( IntEnum ): \"\"\"Types of sticker.\"\"\" STANDARD = 1 \"\"\"An official sticker in a pack, part of Nitro or in a removed purchasable pack.\"\"\" GUILD = 2 \"\"\"A sticker uploaded to a Boosted guild for the guild's members.\"\"\"","title":"StickerTypes"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.sticker.StickerFormatTypes","text":"File formats for stickers. Source code in dis_snek/models/discord_objects/sticker.py class StickerFormatTypes ( IntEnum ): \"\"\"File formats for stickers.\"\"\" PNG = 1 APNG = 2 LOTTIE = 3","title":"StickerFormatTypes"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.sticker.StickerItem","text":"Source code in dis_snek/models/discord_objects/sticker.py @define ( kw_only = False ) class StickerItem ( DiscordObject ): name : str = attr . ib () \"\"\"Name of the sticker.\"\"\" format_type : StickerFormatTypes = attr . ib ( converter = StickerFormatTypes ) \"\"\"Type of sticker image format.\"\"\"","title":"StickerItem"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.sticker.Sticker","text":"Represents a sticker that can be sent in messages. Source code in dis_snek/models/discord_objects/sticker.py @define () class Sticker ( StickerItem ): \"\"\"Represents a sticker that can be sent in messages.\"\"\" pack_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) \"\"\"For standard stickers, id of the pack the sticker is from.\"\"\" description : Optional [ str ] = attr . ib ( default = None ) \"\"\"Description of the sticker.\"\"\" tags : str = attr . ib () \"\"\"autocomplete/suggestion tags for the sticker (max 200 characters)\"\"\" type : Union [ StickerTypes , int ] = attr . ib ( converter = StickerTypes ) \"\"\"Type of sticker.\"\"\" available : Optional [ bool ] = attr . ib ( default = True ) \"\"\"Whether this guild sticker can be used, may be false due to loss of Server Boosts.\"\"\" sort_value : Optional [ int ] = attr . ib ( default = None ) \"\"\"The standard sticker's sort order within its pack.\"\"\" _user_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) _guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None , converter = optional ( to_snowflake )) async def get_creator ( self ) -> \"User\" : \"\"\" Get the user who created this emoji Returns: User object \"\"\" return await self . _client . cache . get_user ( self . _user_id ) async def get_guild ( self ) -> \"Guild\" : \"\"\" Get the guild associated with this emoji Returns: Guild object \"\"\" return await self . _client . cache . get_guild ( self . _guild_id ) async def edit ( self , name : Optional [ str ] = MISSING , description : Optional [ str ] = MISSING , tags : Optional [ str ] = MISSING , reason : Optional [ str ] = MISSING , ) -> \"Sticker\" : \"\"\" Edit a sticker Args: name: New name of the sticker description: New description of the sticker tags: New tags of the sticker reason: Reason for the edit Returns: The updated sticker instance \"\"\" if not self . _guild_id : raise ValueError ( \"You can only edit guild stickers.\" ) payload = dict_filter_none ( dict ( name = name , description = description , tags = tags )) sticker_data = await self . _client . http . modify_guild_sticker ( payload , self . _guild_id , self . id , reason ) return self . update_from_dict ( sticker_data ) async def delete ( self , reason : Optional [ str ] = MISSING ): \"\"\" Delete a sticker Args: reason: Reason for the deletion Raises: ValueError: If you attempt to delete a non-guild sticker \"\"\" if not self . _guild_id : raise ValueError ( \"You can only delete guild stickers.\" ) await self . _client . http . delete_guild_sticker ( self . _guild_id , self . id , reason )","title":"Sticker"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.sticker.StickerPack","text":"Represents a pack of standard stickers. Source code in dis_snek/models/discord_objects/sticker.py @define () class StickerPack ( DiscordObject ): \"\"\"Represents a pack of standard stickers.\"\"\" stickers : List [ \"Sticker\" ] = attr . ib ( factory = list ) \"\"\"The stickers in the pack.\"\"\" name : str = attr . ib () \"\"\"Name of the sticker pack.\"\"\" sku_id : \"Snowflake_Type\" = attr . ib () \"\"\"id of the pack's SKU.\"\"\" cover_sticker_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"id of a sticker in the pack which is shown as the pack's icon.\"\"\" description : str = attr . ib () \"\"\"Description of the sticker pack.\"\"\" banner_asset_id : \"Snowflake_Type\" = attr . ib () # TODO CDN Asset \"\"\"id of the sticker pack's banner image.\"\"\"","title":"StickerPack"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.team.TeamMember","text":"Source code in dis_snek/models/discord_objects/team.py @define () class TeamMember ( ClientObject ): membership_state : TeamMembershipState = attr . ib ( converter = TeamMembershipState ) # permissions: List[str] = attr.ib(default=[\"*\"]) # disabled until discord adds more team roles team_id : \"Snowflake_Type\" = attr . ib () user : \"User\" = attr . ib () # TODO: cache partial user (avatar, discrim, id, username) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data [ \"user\" ] = client . cache . place_user_data ( data [ \"user\" ]) return data","title":"TeamMember"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.team.Team","text":"Source code in dis_snek/models/discord_objects/team.py @define () class Team ( DiscordObject ): icon : Optional [ Asset ] = attr . ib ( default = None ) members : List [ TeamMember ] = attr . ib ( factory = list ) name : str = attr . ib () owner_user_id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data [ \"members\" ] = [ TeamMember . from_dict ( member , client ) for member in data [ \"members\" ]] if data [ \"icon\" ]: data [ \"icon\" ] = Asset . from_path_hash ( client , f \"team-icons/ { data [ 'id' ] } / {{}} .png\" , data [ \"icon\" ]) return data @property def owner ( self ) -> \"User\" : return self . _client . cache . user_cache . get ( self . owner_user_id ) def is_in_team ( self , user : Union [ \"SnowflakeObject\" , \"Snowflake_Type\" ]) -> bool : \"\"\" Returns True if the passed user or ID is a member within the team. Args: user: The user or user ID to check Returns: Boolean indicating whether the user is in the team \"\"\" return to_snowflake ( user ) in [ m . id for m in self . members ]","title":"Team"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.thread.ThreadMember","text":"A thread member is used to indicate whether a user has joined a thread or not. Source code in dis_snek/models/discord_objects/thread.py @define () class ThreadMember ( DiscordObject , SendMixin ): \"\"\"A thread member is used to indicate whether a user has joined a thread or not.\"\"\" join_timestamp : Timestamp = field ( converter = timestamp_converter ) \"\"\"The time the current user last joined the thread.\"\"\" flags : int = field () \"\"\"Any user-thread settings, currently only used for notifications.\"\"\" _user_id : \"Snowflake_Type\" = field ( converter = optional ( to_snowflake )) async def get_thread ( self ) -> \"TYPE_THREAD_CHANNEL\" : \"\"\" Gets the thread associated with with this member. Returns: The thread in question \"\"\" return await self . _client . get_channel ( self . id ) async def get_user ( self ) -> \"User\" : \"\"\" Get the user associated with this thread member. Returns: The user object \"\"\" return await self . _client . get_user ( self . _user_id ) async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : dm_id = await self . _client . cache . get_dm_channel_id ( self . _user_id ) return await self . _client . http . create_message ( message_payload , dm_id )","title":"ThreadMember"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.thread.ThreadList","text":"Represents a list of one or more threads. Source code in dis_snek/models/discord_objects/thread.py @define class ThreadList ( ClientObject ): \"\"\"Represents a list of one or more threads.\"\"\" threads : List [ \"TYPE_THREAD_CHANNEL\" ] = field ( factory = list ) # TODO Reference the cache or store actual object? \"\"\"The active threads.\"\"\" members : List [ ThreadMember ] = field ( factory = list ) \"\"\"A thread member object for each returned thread the current user has joined.\"\"\" has_more : bool = field ( default = False ) \"\"\"Whether there are potentially additional threads that could be returned on a subsequent call.\"\"\" @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: threads = [] for thread_data in data [ \"threads\" ]: threads . append ( client . cache . place_channel_data ( thread_data )) data [ \"threads\" ] = threads members = [] for member_data in data [ \"members\" ]: members . append ( ThreadMember . from_dict ( member_data , client )) data [ \"members\" ] = threads return data","title":"ThreadList"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.user.BaseUser","text":"Base class for User, essentially partial user discord model Source code in dis_snek/models/discord_objects/user.py @define () class BaseUser ( DiscordObject , _SendDMMixin ): \"\"\"Base class for User, essentially partial user discord model\"\"\" username : str = field ( repr = True , metadata = docs ( \"The user's username, not unique across the platform\" )) discriminator : int = field ( repr = True , metadata = docs ( \"The user's 4-digit discord-tag\" )) avatar : \"Asset\" = field ( metadata = docs ( \"The user's default avatar\" )) def __str__ ( self ): return self . tag @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data [ \"avatar\" ] = Asset . from_path_hash ( client , f \"avatars/ { data [ 'id' ] } / {{}} \" , data [ \"avatar\" ]) return data @property def tag ( self ) -> str : \"\"\"Returns the user's Discord tag\"\"\" return f \" { self . username } # { self . discriminator } \" @property def mention ( self ) -> str : \"\"\"Returns a string that would mention the user\"\"\" return f \"<@ { self . id } >\" @property def display_name ( self ) -> str : \"\"\"The users display name, will return nickname if one is set, otherwise will return username\"\"\" return self . username # for duck-typing compatibility with Member async def get_dm ( self ) -> \"DM\" : \"\"\"Get the DM channel associated with this user.\"\"\" return await self . _client . cache . get_channel ( self . id ) # noqa @property def mutual_guilds ( self ) -> List [ \"Guild\" ]: \"\"\"Get a list of mutual guilds shared between this user and the client.\"\"\" # should user_guilds be its own property? return [ g for g in self . _client . guilds if g . id in self . user_guilds ]","title":"BaseUser"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.user.User","text":"Source code in dis_snek/models/discord_objects/user.py @define () class User ( BaseUser ): bot : bool = field ( repr = True , default = False , metadata = docs ( \"Is this user a bot?\" )) system : bool = field ( default = False , metadata = docs ( \"whether the user is an Official Discord System user (part of the urgent message system)\" ), ) public_flags : \"UserFlags\" = field ( repr = True , default = 0 , converter = UserFlags , metadata = docs ( \"The flags associated with this user\" ) ) premium_type : \"PremiumTypes\" = field ( default = 0 , converter = PremiumTypes , metadata = docs ( \"The type of nitro subscription on a user's account\" ) ) banner : Optional [ \"Asset\" ] = field ( default = None , metadata = docs ( \"The user's banner\" )) accent_color : Optional [ \"Color\" ] = field ( default = None , converter = optional_c ( Color ), metadata = docs ( \"The user's banner color\" ), ) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: data = super () . _process_dict ( data , client ) if \"banner\" in data : data [ \"banner\" ] = Asset . from_path_hash ( client , f \"banners/ { data [ 'id' ] } / {{}} \" , data [ \"banner\" ]) return data","title":"User"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.user.SnakeBotUser","text":"Source code in dis_snek/models/discord_objects/user.py @define () class SnakeBotUser ( User ): verified : bool = field ( repr = True , metadata = { \"docs\" : \"\" }) mfa_enabled : bool = field ( default = False , metadata = { \"docs\" : \"\" }) email : Optional [ str ] = field ( default = None , metadata = { \"docs\" : \"\" }) # needs special permissions? locale : Optional [ str ] = field ( default = None , metadata = { \"docs\" : \"\" }) bio : Optional [ str ] = field ( default = None , metadata = { \"docs\" : \"\" }) flags : \"UserFlags\" = field ( default = 0 , converter = UserFlags , metadata = { \"docs\" : \"\" }) _guild_ids : Set [ str ] = field ( factory = set , metadata = { \"docs\" : \"\" }) def _add_guilds ( self , guild_ids : Set [ \"Snowflake_Type\" ]): self . _guild_ids |= guild_ids @property def guilds ( self ) -> List [ \"Guild\" ]: return [ self . _client . cache . guild_cache . get ( g_id ) for g_id in self . _guild_ids ] async def edit ( self , username : Optional [ str ] = None , avatar : Optional [ bytes ] = MISSING ): \"\"\" Edit the client's user. You can either change the username, or avatar, or both at once. `avatar` may be set to `None` to remove your bot's avatar ??? Hint \"Example Usage:\" ```python f = open(\"path_to_file\", \"rb\") await self.user.edit(avatar=f.read()) ``` or ```python await self.user.edit(username=\"hello world\") ``` Args: username: The username you want to use avatar: The avatar to use, must be `bytes` (see example) Raises: TooManyChanges: If you change the profile too many times \"\"\" payload = {} if username : payload [ \"username\" ] = username if avatar : payload [ \"avatar\" ] = _bytes_to_base64_data ( avatar ) # noqa elif avatar is None : payload [ \"avatar\" ] = None try : resp = await self . _client . http . modify_client_user ( payload ) except HTTPException : raise TooManyChanges ( \"You have changed your profile too frequently, you need to wait a while before trying again.\" ) from None if resp : self . _client . cache . place_user_data ( resp )","title":"SnakeBotUser"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.user.Member","text":"Source code in dis_snek/models/discord_objects/user.py @attr . s ( ** { k : v for k , v in class_defaults . items () if k != \"on_setattr\" }) class Member ( DiscordObject , _SendDMMixin ): bot : bool = field ( repr = True , default = False , metadata = docs ( \"Is this user a bot?\" )) nick : Optional [ str ] = field ( repr = True , default = None , metadata = docs ( \"The user's nickname in this guild'\" )) deaf : bool = field ( default = False , metadata = docs ( \"Has this user been deafened in voice channels?\" )) mute : bool = field ( default = False , metadata = docs ( \"Has this user been muted in voice channels?\" )) joined_at : \"Timestamp\" = field ( converter = timestamp_converter , metadata = docs ( \"When the user joined this guild\" )) premium_since : Optional [ \"Timestamp\" ] = field ( default = None , converter = optional_c ( timestamp_converter ), metadata = docs ( \"When the user started boosting the guild\" ), ) pending : Optional [ bool ] = field ( default = None , metadata = docs ( \"Whether the user has **not** passed guild's membership screening requirements\" ) ) guild_avatar : \"Asset\" = field ( default = None , metadata = docs ( \"The user's guild avatar\" )) _guild_id : \"Snowflake_Type\" = field ( repr = True , metadata = docs ( \"The ID of the guild\" )) _role_ids : List [ \"Snowflake_Type\" ] = field ( factory = list , converter = list_converter ( to_snowflake ), metadata = docs ( \"The roles IDs this user has\" ) ) @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: if \"user\" in data : user_data = data . pop ( \"user\" ) client . cache . place_user_data ( user_data ) data [ \"id\" ] = user_data [ \"id\" ] data [ \"bot\" ] = user_data . get ( \"bot\" , False ) elif \"member\" in data : member_data = data . pop ( \"member\" ) client . cache . place_user_data ( data ) member_data [ \"id\" ] = data [ \"id\" ] member_data [ \"bot\" ] = data . get ( \"bot\" , False ) if \"guild_id\" not in member_data : member_data [ \"guild_id\" ] = data . get ( \"guild_id\" ) data = member_data if data . get ( \"avatar\" ): try : data [ \"guild_avatar\" ] = Asset . from_path_hash ( client , f \"guilds/ { data [ 'guild_id' ] } /users/ { data [ 'id' ] } /avatars/ {{}} \" , data . pop ( \"avatar\" , None ) ) except Exception as e : log . warning ( f \"[DEBUG NEEDED - REPORT THIS] Incomplete dictionary has been passed to member object: { e } \" ) raise data [ \"role_ids\" ] = data . pop ( \"roles\" , []) return data def update_from_dict ( self , data ): if \"guild_id\" not in data : data [ \"guild_id\" ] = self . _guild_id data [ \"_role_ids\" ] = data . pop ( \"roles\" , []) return super () . update_from_dict ( data ) @property def user ( self ): \"\"\"Returns this member's user object\"\"\" return self . _client . cache . user_cache . get ( self . id ) def __str__ ( self ): return self . user . tag def __getattr__ ( self , name ): # this allows for transparent access to user attributes try : return getattr ( self . user , name ) except AttributeError : raise AttributeError ( f \"Neither `User` or `Member` have attribute { name } \" ) def __setattr__ ( self , key , value ): # this allows for transparent access to user attributes if attrib := getattr ( self . __attrs_attrs__ , key ): value = attr . setters . convert ( self , attrib , value ) value = attr . setters . validate ( self , attrib , value ) super ( Member , self ) . __setattr__ ( key , value ) @property def nickname ( self ): \"\"\"alias for nick\"\"\" return self . nick @nickname . setter def nickname ( self , nickname ): self . nick = nickname @property def guild ( self ) -> \"Guild\" : return self . _client . cache . guild_cache . get ( self . _guild_id ) @property def roles ( self ) -> List [ \"Role\" ]: return [ r for r in self . guild . roles if r . id in self . _role_ids ] @property def top_role ( self ) -> \"Role\" : return self . _client . cache . role_cache . get ( self . _role_ids [ - 1 ]) @property def display_name ( self ) -> str : \"\"\"The users display name, will return nickname if one is set, otherwise will return username\"\"\" return self . nickname or self . username @property def display_avatar ( self ): \"\"\"The users displayed avatar, will return `guild_avatar` if one is set, otherwise will return user avatar\"\"\" return self . guild_avatar or self . user . avatar @property def premium ( self ) -> bool : \"\"\"Is this member a server booster?\"\"\" return self . premium_since is not None async def guild_permissions ( self ) -> Permissions : \"\"\" Returns the permissions this member has in the guild Returns: Permission data \"\"\" guild = self . guild if guild . is_owner ( self ): return Permissions . ALL role_everyone = guild . default_role # get @everyone role permissions = role_everyone . permissions for role in self . roles : permissions |= role . permissions if Permissions . ADMINISTRATOR in permissions : return Permissions . ALL return permissions async def has_permission ( self , * permissions : Permissions ) -> bool : \"\"\" Checks if the member has all the given permission(s). ??? Hint \"Example Usage:\" Two different styles can be used to call this method. ```python await member.has_permission(Permissions.KICK_MEMBERS, Permissions.BAN_MEMBERS) ``` ```python await member.has_permission(Permissions.KICK_MEMBERS | Permissions.BAN_MEMBERS) ``` If `member` has both permissions, `True` gets returned. Args: permissions: The permission(s) to check whether the user has it. \"\"\" # Get the user's permissions guild_permissions = await self . guild_permissions () # Check all permissions separately for permission in permissions : if permission not in guild_permissions : return False return True async def channel_permissions ( self , channel : \"TYPE_GUILD_CHANNEL\" ) -> Permissions : \"\"\" Returns the permissions this member has in a channel. Args: channel: The channel in question Returns: Permissions data \"\"\" permissions = await self . guild_permissions () if Permissions . ADMINISTRATOR in permissions : return Permissions . ALL # Find (@everyone) role overwrite and apply it. overwrites = channel . _permission_overwrites if overwrite_everyone := overwrites . get ( channel . _guild_id ): permissions &= ~ overwrite_everyone . deny permissions |= overwrite_everyone . allow # Apply role specific overwrites. allow = Permissions . NONE deny = Permissions . NONE for role_id in self . roles . ids : if overwrite_role := overwrites . get ( role_id ): allow |= overwrite_role . allow deny |= overwrite_role . deny permissions &= ~ deny permissions |= allow # Apply member specific overwrite if it exist. if overwrite_member := overwrites . get ( self . id ): permissions &= ~ overwrite_member . deny permissions |= overwrite_member . allow return permissions async def edit_nickname ( self , new_nickname : str ): \"\"\" Change the user's nickname. Args: new_nickname: The new nickname to apply. \"\"\" return await self . _client . http . modify_guild_member ( self . _guild_id , self . id , nickname = new_nickname ) async def add_role ( self , role : Union [ Snowflake_Type , Role ], reason : str = MISSING ): \"\"\" Add a role to this member. Args: role: The role to add reason: The reason for adding this role \"\"\" role = to_snowflake ( role ) return await self . _client . http . add_guild_member_role ( self . _guild_id , self . id , role , reason = reason ) async def remove_role ( self , role : Union [ Snowflake_Type , Role ], reason : str = MISSING ): \"\"\" Remove a role from this user. Args: role: The role to remove reason: The reason for this removal \"\"\" if isinstance ( role , Role ): role = role . id return await self . _client . http . remove_guild_member_role ( self . _guild_id , self . id , role , reason = reason ) async def has_role ( self , * roles : Union [ Snowflake_Type , Role ]) -> bool : \"\"\" Checks if the user has the given role(s) Args: roles: The role(s) to check whether the user has it. \"\"\" for role in roles : role_id = to_snowflake ( role ) if role_id not in self . _role_ids : return False return True async def kick ( self , reason : str = MISSING ): \"\"\" Remove a member from the guild. Args: reason: The reason for this removal \"\"\" return await self . _client . http . remove_guild_member ( self . _guild_id , self . id ) async def ban ( self , delete_message_days = 0 , reason : str = MISSING ): \"\"\" Ban a member from the guild. Args: delete_message_days: The number of days of messages to delete reason: The reason for this ban \"\"\" return await self . _client . http . create_guild_ban ( self . _guild_id , self . id , delete_message_days , reason = reason )","title":"Member"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.webhooks.WebhookTypes","text":"An enumeration. Source code in dis_snek/models/discord_objects/webhooks.py class WebhookTypes ( IntEnum ): INCOMING = 1 \"\"\"Incoming Webhooks can post messages to channels with a generated token\"\"\" CHANNEL_FOLLOWER = 2 \"\"\"Channel Follower Webhooks are internal webhooks used with Channel Following to post new messages into channels\"\"\" APPLICATION = 3 \"\"\"Application webhooks are webhooks used with Interactions\"\"\"","title":"WebhookTypes"},{"location":"API%20Reference/models/Discord%20Models/#dis_snek.models.discord_objects.webhooks.Webhook","text":"Source code in dis_snek/models/discord_objects/webhooks.py @define class Webhook ( DiscordObject , SendMixin ): type : WebhookTypes = attr . ib () \"\"\"The type of webhook\"\"\" application_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the bot/OAuth2 application that created this webhook\"\"\" guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the guild id this webhook is for, if any\"\"\" channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the channel id this webhook is for, if any\"\"\" user_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the user this webhook was created by\"\"\" name : Optional [ str ] = attr . ib ( default = None ) \"\"\"the default name of the webhook\"\"\" avatar : Optional [ str ] = attr . ib ( default = None ) \"\"\"the default user avatar hash of the webhook\"\"\" token : str = attr . ib () \"\"\"the secure token of the webhook (returned for Incoming Webhooks)\"\"\" url : Optional [ str ] = attr . ib ( default = None ) \"\"\"the url used for executing the webhook (returned by the webhooks OAuth2 flow)\"\"\" source_guild_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the guild of the channel that this webhook is following (returned for Channel Follower Webhooks)\"\"\" source_channel_id : Optional [ \"Snowflake_Type\" ] = attr . ib ( default = None ) \"\"\"the channel that this webhook is following (returned for Channel Follower Webhooks)\"\"\" @classmethod async def create ( cls , client : \"Snake\" , channel : Union [ \"Snowflake_Type\" , \"TYPE_MESSAGEABLE_CHANNEL\" ], name : str , avatar : Optional [ bytes ] = MISSING , ) -> \"Webhook\" : \"\"\" Create a webhook. Args: client: The bot's client channel: The channel to create the webhook in name: The name of the webhook avatar: An optional default avatar to use Returns: New webhook Raises: ValueError: If you try to name the webhook \"Clyde\" \"\"\" if name . lower () == \"clyde\" : raise ValueError ( 'Webhook names cannot be \"Clyde\"' ) if not isinstance ( channel , ( str , int )): channel = to_snowflake ( channel ) if avatar : avatar = _bytes_to_base64_data ( avatar ) data = await client . http . create_webhook ( channel , name , avatar ) new_cls = cls . from_dict ( data , client ) return new_cls @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: if data . get ( \"user\" ): user = client . cache . place_user_data ( data . pop ( \"user\" )) data [ \"user_id\" ] = user . id return data async def delete ( self ) -> None : \"\"\"Delete this webhook\"\"\" await self . _client . http . delete_webhook ( self . id , self . token ) async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : wait = message_payload . pop ( \"wait\" ) return await self . _client . http . execute_webhook ( self . id , self . token , message_payload , wait ) async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , username : str = None , avatar_url : str = None , wait : bool = False , ) -> Optional [ \"Message\" ]: \"\"\" Send a message as this webhook Args: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. username: The username to use avatar_url: The url of an image to use as the avatar wait: Waits for confirmation of delivery. Set this to True if you intend to edit the message Returns: New message object that was sent if `wait` is set to True \"\"\" return await super () . send ( content , embeds , components , stickers , allowed_mentions , reply_to , file , tts , flags , username = username , avatar_url = avatar_url , wait = wait , ) async def edit_message ( self , message : Union [ \"Message\" , \"Snowflake_Type\" ], content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ): message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) msg_data = await self . _client . http . edit_webhook_message ( self . id , self . token , to_snowflake ( message ), message_payload ) if msg_data : return self . _client . cache . place_message_data ( msg_data )","title":"Webhook"},{"location":"API%20Reference/models/Internal%20Models/Context/","text":"Resolved attrs \u00b6 Represents resolved data in an interaction Source code in dis_snek/models/context.py @attr . s class Resolved : \"\"\"Represents resolved data in an interaction\"\"\" channels : Dict [ \"Snowflake_Type\" , \"TYPE_MESSAGEABLE_CHANNEL\" ] = attr . ib ( factory = dict , metadata = docs ( \"A dictionary of channels mentioned in the interaction\" ) ) members : Dict [ \"Snowflake_Type\" , \"Member\" ] = attr . ib ( factory = dict , metadata = docs ( \"A dictionary of members mentioned in the interaction\" ) ) users : Dict [ \"Snowflake_Type\" , \"User\" ] = attr . ib ( factory = dict , metadata = docs ( \"A dictionary of users mentioned in the interaction\" ) ) roles : Dict [ \"Snowflake_Type\" , \"Role\" ] = attr . ib ( factory = dict , metadata = docs ( \"A dictionary of roles mentioned in the interaction\" ) ) @classmethod def from_dict ( cls , client : \"Snake\" , data : dict , guild_id : Optional [ \"Snowflake_Type\" ] = None ): new_cls = cls () if channels := data . get ( \"channels\" ): for key , _channel in channels . items (): new_cls . channels [ key ] = client . cache . place_channel_data ( _channel ) if members := data . get ( \"members\" ): for key , _member in members . items (): new_cls . members [ key ] = client . cache . place_member_data ( guild_id , { ** _member , \"user\" : { ** data [ \"users\" ][ key ]}} ) if users := data . get ( \"users\" ): for key , _user in users . items (): new_cls . users [ key ] = client . cache . place_user_data ( _user ) if roles := data . get ( \"roles\" ): for key , _role in roles . items (): new_cls . roles [ key ] = client . cache . role_cache . get ( to_snowflake ( key )) return new_cls attrs-field channels : Dict [ Snowflake_Type , TYPE_MESSAGEABLE_CHANNEL ] \u00b6 A dictionary of channels mentioned in the interaction attrs-field members : Dict [ Snowflake_Type , Member ] \u00b6 A dictionary of members mentioned in the interaction attrs-field users : Dict [ Snowflake_Type , User ] \u00b6 A dictionary of users mentioned in the interaction attrs-field roles : Dict [ Snowflake_Type , Role ] \u00b6 A dictionary of roles mentioned in the interaction Context attrs \u00b6 Represents the context of a command Source code in dis_snek/models/context.py @define class Context : \"\"\"Represents the context of a command\"\"\" _client : \"Snake\" = attr . ib ( default = None ) invoked_name : str = attr . ib ( default = None , metadata = docs ( \"The name of the command to be invoked\" )) args : List = attr . ib ( factory = list , metadata = docs ( \"The list of arguments to be passed to the command\" )) kwargs : Dict = attr . ib ( factory = dict , metadata = docs ( \"The list of keyword arguments to be passed\" )) author : Union [ \"Member\" , \"User\" ] = attr . ib ( default = None , metadata = docs ( \"The author of the message\" )) channel : \"TYPE_MESSAGEABLE_CHANNEL\" = attr . ib ( default = None , metadata = docs ( \"The channel this was sent within\" )) guild_id : \"Snowflake_Type\" = attr . ib ( default = None , converter = to_snowflake , metadata = docs ( \"The guild this was sent within, if not a DM\" ) ) message : \"Message\" = attr . ib ( default = None , metadata = docs ( \"The message associated with this context\" )) @property def guild ( self ): return self . _client . cache . guild_cache . get ( self . guild_id ) @property def bot ( self ): \"\"\"A reference to the bot instance\"\"\" return self . _client attrs-field kw_only args : List \u00b6 The list of arguments to be passed to the command attrs-field kw_only author : Union [ Member , User ] \u00b6 The author of the message attrs-field kw_only channel : TYPE_MESSAGEABLE_CHANNEL \u00b6 The channel this was sent within attrs-field kw_only guild_id : Snowflake_Type \u00b6 The guild this was sent within, if not a DM attrs-field kw_only invoked_name : str \u00b6 The name of the command to be invoked attrs-field kw_only kwargs : Dict \u00b6 The list of keyword arguments to be passed attrs-field kw_only message : Message \u00b6 The message associated with this context property readonly bot \u00b6 A reference to the bot instance InteractionContext ( _BaseInteractionContext , SendMixin ) attrs \u00b6 Represents the context of an interaction Ephemeral messages: Ephemeral messages allow you to send messages that only the author of the interaction can see. They are best considered as fire-and-forget , in the sense that you cannot edit them once they have been sent. Should you attach a component (ie. button) to the ephemeral message, you will be able to edit it when responding to a button interaction. Source code in dis_snek/models/context.py @define class InteractionContext ( _BaseInteractionContext , SendMixin ): \"\"\" Represents the context of an interaction !!! info \"Ephemeral messages:\" Ephemeral messages allow you to send messages that only the author of the interaction can see. They are best considered as `fire-and-forget`, in the sense that you cannot edit them once they have been sent. Should you attach a component (ie. button) to the ephemeral message, you will be able to edit it when responding to a button interaction. \"\"\" @property def guild ( self ): return self . _client . cache . guild_cache . get ( self . guild_id ) async def defer ( self , ephemeral = False ) -> None : \"\"\" Defers the response, showing a loading state. parameters: ephemeral: Should the response be ephemeral \"\"\" if self . deferred or self . responded : raise Exception ( \"You have already responded to this interaction!\" ) payload = { \"type\" : CallbackTypes . DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE } if ephemeral : payload [ \"data\" ] = { \"flags\" : MessageFlags . EPHEMERAL } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) self . ephemeral = ephemeral self . deferred = True async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : if self . responded : message_data = await self . _client . http . post_followup ( message_payload , self . _client . user . id , self . _token ) else : if isinstance ( message_payload , FormData ) and not self . deferred : await self . defer () if self . deferred : message_data = await self . _client . http . edit_interaction_message ( message_payload , self . _client . user . id , self . _token ) self . deferred = False else : payload = { \"type\" : CallbackTypes . CHANNEL_MESSAGE_WITH_SOURCE , \"data\" : message_payload } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) message_data = await self . _client . http . get_interaction_message ( self . _client . user . id , self . _token ) self . responded = True return message_data async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ephemeral : bool = False , ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. ephemeral bool: Should this message be sent as ephemeral (hidden) returns: New message object that was sent. \"\"\" if ephemeral : flags = MessageFlags . EPHEMERAL return await super () . send ( content , embeds , components , stickers , allowed_mentions , reply_to , file , tts , flags ) attrs-field inherited kw_only args : List \u00b6 The list of arguments to be passed to the command attrs-field inherited kw_only author : Union [ Member , User ] \u00b6 The author of the message attrs-field inherited kw_only channel : TYPE_MESSAGEABLE_CHANNEL \u00b6 The channel this was sent within attrs-field inherited kw_only data : Dict \u00b6 The raw data of this interaction attrs-field inherited kw_only deferred : bool \u00b6 Is this interaction deferred? attrs-field inherited kw_only ephemeral : bool \u00b6 Are responses to this interaction hidden attrs-field inherited kw_only guild_id : Snowflake_Type \u00b6 The guild this was sent within, if not a DM attrs-field inherited kw_only interaction_id : str \u00b6 The id of the interaction attrs-field inherited kw_only invoked_name : str \u00b6 The name of the command to be invoked attrs-field inherited kw_only kwargs : Dict \u00b6 The list of keyword arguments to be passed attrs-field inherited kw_only message : Message \u00b6 The message associated with this context attrs-field inherited kw_only resolved : Resolved \u00b6 Discord objects mentioned within this interaction attrs-field inherited kw_only responded : bool \u00b6 Have we responded to the interaction? attrs-field inherited kw_only target_id : Snowflake_Type \u00b6 The ID of the target, used for context menus to show what was clicked on inherited property readonly bot \u00b6 A reference to the bot instance async defer ( self , ephemeral = False ) \u00b6 Defers the response, showing a loading state. Parameters: Name Type Description Default ephemeral Should the response be ephemeral False Source code in dis_snek/models/context.py async def defer ( self , ephemeral = False ) -> None : \"\"\" Defers the response, showing a loading state. parameters: ephemeral: Should the response be ephemeral \"\"\" if self . deferred or self . responded : raise Exception ( \"You have already responded to this interaction!\" ) payload = { \"type\" : CallbackTypes . DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE } if ephemeral : payload [ \"data\" ] = { \"flags\" : MessageFlags . EPHEMERAL } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) self . ephemeral = ephemeral self . deferred = True async send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ephemeral = False ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None ephemeral bool Should this message be sent as ephemeral (hidden) False Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/context.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ephemeral : bool = False , ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. ephemeral bool: Should this message be sent as ephemeral (hidden) returns: New message object that was sent. \"\"\" if ephemeral : flags = MessageFlags . EPHEMERAL return await super () . send ( content , embeds , components , stickers , allowed_mentions , reply_to , file , tts , flags ) ComponentContext ( InteractionContext ) attrs \u00b6 Source code in dis_snek/models/context.py @define class ComponentContext ( InteractionContext ): custom_id : str = attr . ib ( default = \"\" , metadata = docs ( \"The ID given to the component that has been pressed\" )) component_type : int = attr . ib ( default = 0 , metadata = docs ( \"The type of component that has been pressed\" )) values : List = attr . ib ( factory = list , metadata = docs ( \"The values set\" )) # todo: Polls, check this defer_edit_origin : bool = attr . ib ( default = False , metadata = docs ( \"Are we editing the message the component is on\" )) @classmethod def from_dict ( cls , data : Dict , client : \"Snake\" ) -> \"ComponentContext\" : \"\"\"Create a context object from a dictionary\"\"\" new_cls = super () . from_dict ( data , client ) new_cls . token = data [ \"token\" ] new_cls . interaction_id = data [ \"id\" ] new_cls . custom_id = data [ \"data\" ][ \"custom_id\" ] new_cls . component_type = data [ \"data\" ][ \"component_type\" ] new_cls . message = client . cache . place_message_data ( data [ \"message\" ]) return new_cls async def defer ( self , ephemeral = False , edit_origin : bool = False ) -> None : \"\"\" Defers the response, showing a loading state. parameters: ephemeral: Should the response be ephemeral edit_origin: Whether we intend to edit the original message \"\"\" if self . deferred or self . responded : raise Exception ( \"You have already responded to this interaction!\" ) payload = { \"type\" : CallbackTypes . DEFERRED_UPDATE_MESSAGE if edit_origin else CallbackTypes . DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE } if ephemeral : if edit_origin : raise ValueError ( \"`edit_origin` and `ephemeral` are mutually exclusive\" ) payload [ \"data\" ] = { \"flags\" : MessageFlags . EPHEMERAL } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) self . deferred = True self . ephemeral = ephemeral self . defer_edit_origin = edit_origin async def edit_origin ( self , content : str = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , ) -> \"Message\" : \"\"\" Edits the original message of the component. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. returns: The message after it was edited. \"\"\" if not self . responded and not self . deferred and file : # Discord doesn't allow files at initial response, so we defer then edit. await self . defer ( edit_origin = True ) message_payload = process_message_payload ( content = content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , file = file , tts = tts , ) message_data = None if self . deferred : message_data = await self . _client . http . edit_interaction_message ( message_payload , self . _client . user . id , self . _token ) self . deferred = False self . defer_edit_origin = False else : payload = { \"type\" : CallbackTypes . UPDATE_MESSAGE , \"data\" : message_payload } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) message_data = await self . _client . http . get_interaction_message ( self . _client . user . id , self . _token ) if message_data : self . message = self . _client . cache . place_message_data ( message_data ) return self . message attrs-field inherited kw_only args : List \u00b6 The list of arguments to be passed to the command attrs-field inherited kw_only author : Union [ Member , User ] \u00b6 The author of the message attrs-field inherited kw_only channel : TYPE_MESSAGEABLE_CHANNEL \u00b6 The channel this was sent within attrs-field kw_only component_type : int \u00b6 The type of component that has been pressed attrs-field kw_only custom_id : str \u00b6 The ID given to the component that has been pressed attrs-field inherited kw_only data : Dict \u00b6 The raw data of this interaction attrs-field kw_only defer_edit_origin : bool \u00b6 Are we editing the message the component is on attrs-field inherited kw_only deferred : bool \u00b6 Is this interaction deferred? attrs-field inherited kw_only ephemeral : bool \u00b6 Are responses to this interaction hidden attrs-field inherited kw_only guild_id : Snowflake_Type \u00b6 The guild this was sent within, if not a DM attrs-field inherited kw_only interaction_id : str \u00b6 The id of the interaction attrs-field inherited kw_only invoked_name : str \u00b6 The name of the command to be invoked attrs-field inherited kw_only kwargs : Dict \u00b6 The list of keyword arguments to be passed attrs-field inherited kw_only message : Message \u00b6 The message associated with this context attrs-field inherited kw_only resolved : Resolved \u00b6 Discord objects mentioned within this interaction attrs-field inherited kw_only responded : bool \u00b6 Have we responded to the interaction? attrs-field inherited kw_only target_id : Snowflake_Type \u00b6 The ID of the target, used for context menus to show what was clicked on attrs-field kw_only values : List \u00b6 The values set inherited property readonly bot \u00b6 A reference to the bot instance async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ephemeral = False ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None ephemeral bool Should this message be sent as ephemeral (hidden) False Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/context.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ephemeral : bool = False , ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. ephemeral bool: Should this message be sent as ephemeral (hidden) returns: New message object that was sent. \"\"\" if ephemeral : flags = MessageFlags . EPHEMERAL return await super () . send ( content , embeds , components , stickers , allowed_mentions , reply_to , file , tts , flags ) classmethod from_dict ( data , client ) \u00b6 Create a context object from a dictionary Source code in dis_snek/models/context.py @classmethod def from_dict ( cls , data : Dict , client : \"Snake\" ) -> \"ComponentContext\" : \"\"\"Create a context object from a dictionary\"\"\" new_cls = super () . from_dict ( data , client ) new_cls . token = data [ \"token\" ] new_cls . interaction_id = data [ \"id\" ] new_cls . custom_id = data [ \"data\" ][ \"custom_id\" ] new_cls . component_type = data [ \"data\" ][ \"component_type\" ] new_cls . message = client . cache . place_message_data ( data [ \"message\" ]) return new_cls async defer ( self , ephemeral = False , edit_origin = False ) \u00b6 Defers the response, showing a loading state. Parameters: Name Type Description Default ephemeral Should the response be ephemeral False edit_origin bool Whether we intend to edit the original message False Source code in dis_snek/models/context.py async def defer ( self , ephemeral = False , edit_origin : bool = False ) -> None : \"\"\" Defers the response, showing a loading state. parameters: ephemeral: Should the response be ephemeral edit_origin: Whether we intend to edit the original message \"\"\" if self . deferred or self . responded : raise Exception ( \"You have already responded to this interaction!\" ) payload = { \"type\" : CallbackTypes . DEFERRED_UPDATE_MESSAGE if edit_origin else CallbackTypes . DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE } if ephemeral : if edit_origin : raise ValueError ( \"`edit_origin` and `ephemeral` are mutually exclusive\" ) payload [ \"data\" ] = { \"flags\" : MessageFlags . EPHEMERAL } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) self . deferred = True self . ephemeral = ephemeral self . defer_edit_origin = edit_origin async edit_origin ( self , content = None , embeds = None , components = None , allowed_mentions = None , file = None , tts = False ) \u00b6 Edits the original message of the component. Parameters: Name Type Description Default content str Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Message to reference, must be from the same channel. required file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False Returns: Type Description Message The message after it was edited. Source code in dis_snek/models/context.py async def edit_origin ( self , content : str = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , ) -> \"Message\" : \"\"\" Edits the original message of the component. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. returns: The message after it was edited. \"\"\" if not self . responded and not self . deferred and file : # Discord doesn't allow files at initial response, so we defer then edit. await self . defer ( edit_origin = True ) message_payload = process_message_payload ( content = content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , file = file , tts = tts , ) message_data = None if self . deferred : message_data = await self . _client . http . edit_interaction_message ( message_payload , self . _client . user . id , self . _token ) self . deferred = False self . defer_edit_origin = False else : payload = { \"type\" : CallbackTypes . UPDATE_MESSAGE , \"data\" : message_payload } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) message_data = await self . _client . http . get_interaction_message ( self . _client . user . id , self . _token ) if message_data : self . message = self . _client . cache . place_message_data ( message_data ) return self . message AutocompleteContext ( _BaseInteractionContext ) attrs \u00b6 Source code in dis_snek/models/context.py @define class AutocompleteContext ( _BaseInteractionContext ): focussed_option : str = attr . ib ( default = MISSING , metadata = docs ( \"The option the user is currently filling in\" )) @classmethod def from_dict ( cls , data : Dict , client : \"Snake\" ) -> \"ComponentContext\" : \"\"\"Create a context object from a dictionary\"\"\" new_cls = super () . from_dict ( data , client ) return new_cls @property def input_text ( self ) -> str : \"\"\"The text the user has entered so far\"\"\" return self . kwargs . get ( self . focussed_option , \"\" ) async def send ( self , choices : List [ Union [ str , int , float , Dict [ str , Union [ str , int , float ]]]]): \"\"\" Send your autocomplete choices to discord. Choices must be either a list of strings, or a dictionary following the following format: ```json { \"name\": str, \"value\": str } ``` Where name is the text visible in Discord, and value is the data sent back to your client when that choice is chosen. Args: choices: 25 choices the user can pick \"\"\" processed_choices = [] for choice in choices : if isinstance ( choice , ( int , float )): processed_choices . append ({ \"name\" : str ( choice ), \"value\" : choice }) elif isinstance ( choice , dict ): processed_choices . append ( choice ) else : choice = str ( choice ) processed_choices . append ({ \"name\" : choice , \"value\" : choice . replace ( \" \" , \"_\" )}) payload = { \"type\" : CallbackTypes . AUTOCOMPLETE_RESULT , \"data\" : { \"choices\" : processed_choices }} await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) attrs-field inherited kw_only args : List \u00b6 The list of arguments to be passed to the command attrs-field inherited kw_only author : Union [ Member , User ] \u00b6 The author of the message attrs-field inherited kw_only channel : TYPE_MESSAGEABLE_CHANNEL \u00b6 The channel this was sent within attrs-field inherited kw_only data : Dict \u00b6 The raw data of this interaction attrs-field inherited kw_only deferred : bool \u00b6 Is this interaction deferred? attrs-field inherited kw_only ephemeral : bool \u00b6 Are responses to this interaction hidden attrs-field kw_only focussed_option : str \u00b6 The option the user is currently filling in attrs-field inherited kw_only guild_id : Snowflake_Type \u00b6 The guild this was sent within, if not a DM attrs-field inherited kw_only interaction_id : str \u00b6 The id of the interaction attrs-field inherited kw_only invoked_name : str \u00b6 The name of the command to be invoked attrs-field inherited kw_only kwargs : Dict \u00b6 The list of keyword arguments to be passed attrs-field inherited kw_only message : Message \u00b6 The message associated with this context attrs-field inherited kw_only resolved : Resolved \u00b6 Discord objects mentioned within this interaction attrs-field inherited kw_only responded : bool \u00b6 Have we responded to the interaction? attrs-field inherited kw_only target_id : Snowflake_Type \u00b6 The ID of the target, used for context menus to show what was clicked on inherited property readonly bot \u00b6 A reference to the bot instance classmethod from_dict ( data , client ) \u00b6 Create a context object from a dictionary Source code in dis_snek/models/context.py @classmethod def from_dict ( cls , data : Dict , client : \"Snake\" ) -> \"ComponentContext\" : \"\"\"Create a context object from a dictionary\"\"\" new_cls = super () . from_dict ( data , client ) return new_cls property readonly input_text : str \u00b6 The text the user has entered so far async send ( self , choices ) \u00b6 Send your autocomplete choices to discord. Choices must be either a list of strings, or a dictionary following the following format: 1 2 3 4 { \"name\" : s tr , \"value\" : s tr } Where name is the text visible in Discord, and value is the data sent back to your client when that choice is chosen. Parameters: Name Type Description Default choices List[Union[str, int, float, Dict[str, Union[str, int, float]]]] 25 choices the user can pick required Source code in dis_snek/models/context.py async def send ( self , choices : List [ Union [ str , int , float , Dict [ str , Union [ str , int , float ]]]]): \"\"\" Send your autocomplete choices to discord. Choices must be either a list of strings, or a dictionary following the following format: ```json { \"name\": str, \"value\": str } ``` Where name is the text visible in Discord, and value is the data sent back to your client when that choice is chosen. Args: choices: 25 choices the user can pick \"\"\" processed_choices = [] for choice in choices : if isinstance ( choice , ( int , float )): processed_choices . append ({ \"name\" : str ( choice ), \"value\" : choice }) elif isinstance ( choice , dict ): processed_choices . append ( choice ) else : choice = str ( choice ) processed_choices . append ({ \"name\" : choice , \"value\" : choice . replace ( \" \" , \"_\" )}) payload = { \"type\" : CallbackTypes . AUTOCOMPLETE_RESULT , \"data\" : { \"choices\" : processed_choices }} await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) MessageContext ( Context , SendMixin ) attrs \u00b6 Source code in dis_snek/models/context.py @define class MessageContext ( Context , SendMixin ): prefix : str = attr . ib ( default = MISSING , metadata = docs ( \"The prefix used to invoke this command\" )) @classmethod def from_message ( cls , client : \"Snake\" , message : \"Message\" ): new_cls = cls ( client = client , message = message , author = message . author , channel = message . channel , guild_id = message . guild . id , ) return new_cls @property def content_parameters ( self ): return self . message . content . removeprefix ( f \" { self . prefix }{ self . invoked_name } \" ) . strip () async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : return await self . _client . http . create_message ( message_payload , self . channel . id ) attrs-field inherited kw_only args : List \u00b6 The list of arguments to be passed to the command attrs-field inherited kw_only author : Union [ Member , User ] \u00b6 The author of the message attrs-field inherited kw_only channel : TYPE_MESSAGEABLE_CHANNEL \u00b6 The channel this was sent within attrs-field inherited kw_only guild_id : Snowflake_Type \u00b6 The guild this was sent within, if not a DM attrs-field inherited kw_only invoked_name : str \u00b6 The name of the command to be invoked attrs-field inherited kw_only kwargs : Dict \u00b6 The list of keyword arguments to be passed attrs-field inherited kw_only message : Message \u00b6 The message associated with this context attrs-field kw_only prefix : str \u00b6 The prefix used to invoke this command async inherited send ( self , content = None , embeds = None , components = None , stickers = None , allowed_mentions = None , reply_to = None , file = None , tts = False , flags = None , ** kwargs ) \u00b6 Send a message. Parameters: Name Type Description Default content Optional[str] Message text content. None embeds Union[List[Union[Embed, dict]], Embed, dict] Embedded rich content (up to 6000 characters). None components Union[List[List[Union[BaseComponent, dict]]], List[Union[BaseComponent, dict]], BaseComponent, dict] The components to include with the message. None stickers Union[List[Union[Sticker, Snowflake_Type]], Sticker, Snowflake_Type] IDs of up to 3 stickers in the server to send in the message. None allowed_mentions Union[AllowedMentions, dict] Allowed mentions for the message. None reply_to Union[MessageReference, Message, dict, Snowflake_Type] Message to reference, must be from the same channel. None file Union[File, IOBase, Path, str] Location of file to send, the bytes or the File() instance, defaults to None. None tts bool Should this message use Text To Speech. False flags Union[int, MessageFlags] Message flags to apply. None Returns: Type Description Message New message object that was sent. Source code in dis_snek/models/context.py async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ** kwargs ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. returns: New message object that was sent. \"\"\" message_payload = process_message_payload ( content = content , embeds = embeds , components = components , stickers = stickers , allowed_mentions = allowed_mentions , reply_to = reply_to , file = file , tts = tts , flags = flags , ) if kwargs : for key , value in kwargs . items (): message_payload [ key ] = value message_data = await self . _send_http_request ( message_payload ) if message_data : return self . _client . cache . place_message_data ( message_data ) inherited property readonly bot \u00b6 A reference to the bot instance","title":"Context"},{"location":"API%20Reference/models/Internal%20Models/Context/#dis_snek.models.context.Resolved","text":"Represents resolved data in an interaction Source code in dis_snek/models/context.py @attr . s class Resolved : \"\"\"Represents resolved data in an interaction\"\"\" channels : Dict [ \"Snowflake_Type\" , \"TYPE_MESSAGEABLE_CHANNEL\" ] = attr . ib ( factory = dict , metadata = docs ( \"A dictionary of channels mentioned in the interaction\" ) ) members : Dict [ \"Snowflake_Type\" , \"Member\" ] = attr . ib ( factory = dict , metadata = docs ( \"A dictionary of members mentioned in the interaction\" ) ) users : Dict [ \"Snowflake_Type\" , \"User\" ] = attr . ib ( factory = dict , metadata = docs ( \"A dictionary of users mentioned in the interaction\" ) ) roles : Dict [ \"Snowflake_Type\" , \"Role\" ] = attr . ib ( factory = dict , metadata = docs ( \"A dictionary of roles mentioned in the interaction\" ) ) @classmethod def from_dict ( cls , client : \"Snake\" , data : dict , guild_id : Optional [ \"Snowflake_Type\" ] = None ): new_cls = cls () if channels := data . get ( \"channels\" ): for key , _channel in channels . items (): new_cls . channels [ key ] = client . cache . place_channel_data ( _channel ) if members := data . get ( \"members\" ): for key , _member in members . items (): new_cls . members [ key ] = client . cache . place_member_data ( guild_id , { ** _member , \"user\" : { ** data [ \"users\" ][ key ]}} ) if users := data . get ( \"users\" ): for key , _user in users . items (): new_cls . users [ key ] = client . cache . place_user_data ( _user ) if roles := data . get ( \"roles\" ): for key , _role in roles . items (): new_cls . roles [ key ] = client . cache . role_cache . get ( to_snowflake ( key )) return new_cls","title":"Resolved"},{"location":"API%20Reference/models/Internal%20Models/Context/#dis_snek.models.context.Context","text":"Represents the context of a command Source code in dis_snek/models/context.py @define class Context : \"\"\"Represents the context of a command\"\"\" _client : \"Snake\" = attr . ib ( default = None ) invoked_name : str = attr . ib ( default = None , metadata = docs ( \"The name of the command to be invoked\" )) args : List = attr . ib ( factory = list , metadata = docs ( \"The list of arguments to be passed to the command\" )) kwargs : Dict = attr . ib ( factory = dict , metadata = docs ( \"The list of keyword arguments to be passed\" )) author : Union [ \"Member\" , \"User\" ] = attr . ib ( default = None , metadata = docs ( \"The author of the message\" )) channel : \"TYPE_MESSAGEABLE_CHANNEL\" = attr . ib ( default = None , metadata = docs ( \"The channel this was sent within\" )) guild_id : \"Snowflake_Type\" = attr . ib ( default = None , converter = to_snowflake , metadata = docs ( \"The guild this was sent within, if not a DM\" ) ) message : \"Message\" = attr . ib ( default = None , metadata = docs ( \"The message associated with this context\" )) @property def guild ( self ): return self . _client . cache . guild_cache . get ( self . guild_id ) @property def bot ( self ): \"\"\"A reference to the bot instance\"\"\" return self . _client","title":"Context"},{"location":"API%20Reference/models/Internal%20Models/Context/#dis_snek.models.context.InteractionContext","text":"Represents the context of an interaction Ephemeral messages: Ephemeral messages allow you to send messages that only the author of the interaction can see. They are best considered as fire-and-forget , in the sense that you cannot edit them once they have been sent. Should you attach a component (ie. button) to the ephemeral message, you will be able to edit it when responding to a button interaction. Source code in dis_snek/models/context.py @define class InteractionContext ( _BaseInteractionContext , SendMixin ): \"\"\" Represents the context of an interaction !!! info \"Ephemeral messages:\" Ephemeral messages allow you to send messages that only the author of the interaction can see. They are best considered as `fire-and-forget`, in the sense that you cannot edit them once they have been sent. Should you attach a component (ie. button) to the ephemeral message, you will be able to edit it when responding to a button interaction. \"\"\" @property def guild ( self ): return self . _client . cache . guild_cache . get ( self . guild_id ) async def defer ( self , ephemeral = False ) -> None : \"\"\" Defers the response, showing a loading state. parameters: ephemeral: Should the response be ephemeral \"\"\" if self . deferred or self . responded : raise Exception ( \"You have already responded to this interaction!\" ) payload = { \"type\" : CallbackTypes . DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE } if ephemeral : payload [ \"data\" ] = { \"flags\" : MessageFlags . EPHEMERAL } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) self . ephemeral = ephemeral self . deferred = True async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : if self . responded : message_data = await self . _client . http . post_followup ( message_payload , self . _client . user . id , self . _token ) else : if isinstance ( message_payload , FormData ) and not self . deferred : await self . defer () if self . deferred : message_data = await self . _client . http . edit_interaction_message ( message_payload , self . _client . user . id , self . _token ) self . deferred = False else : payload = { \"type\" : CallbackTypes . CHANNEL_MESSAGE_WITH_SOURCE , \"data\" : message_payload } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) message_data = await self . _client . http . get_interaction_message ( self . _client . user . id , self . _token ) self . responded = True return message_data async def send ( self , content : Optional [ str ] = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , stickers : Optional [ Union [ List [ Union [ \"Sticker\" , \"Snowflake_Type\" ]], \"Sticker\" , \"Snowflake_Type\" ]] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , reply_to : Optional [ Union [ \"MessageReference\" , \"Message\" , dict , \"Snowflake_Type\" ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , flags : Optional [ Union [ int , \"MessageFlags\" ]] = None , ephemeral : bool = False , ) -> \"Message\" : \"\"\" Send a message. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. stickers: IDs of up to 3 stickers in the server to send in the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. flags: Message flags to apply. ephemeral bool: Should this message be sent as ephemeral (hidden) returns: New message object that was sent. \"\"\" if ephemeral : flags = MessageFlags . EPHEMERAL return await super () . send ( content , embeds , components , stickers , allowed_mentions , reply_to , file , tts , flags )","title":"InteractionContext"},{"location":"API%20Reference/models/Internal%20Models/Context/#dis_snek.models.context.ComponentContext","text":"Source code in dis_snek/models/context.py @define class ComponentContext ( InteractionContext ): custom_id : str = attr . ib ( default = \"\" , metadata = docs ( \"The ID given to the component that has been pressed\" )) component_type : int = attr . ib ( default = 0 , metadata = docs ( \"The type of component that has been pressed\" )) values : List = attr . ib ( factory = list , metadata = docs ( \"The values set\" )) # todo: Polls, check this defer_edit_origin : bool = attr . ib ( default = False , metadata = docs ( \"Are we editing the message the component is on\" )) @classmethod def from_dict ( cls , data : Dict , client : \"Snake\" ) -> \"ComponentContext\" : \"\"\"Create a context object from a dictionary\"\"\" new_cls = super () . from_dict ( data , client ) new_cls . token = data [ \"token\" ] new_cls . interaction_id = data [ \"id\" ] new_cls . custom_id = data [ \"data\" ][ \"custom_id\" ] new_cls . component_type = data [ \"data\" ][ \"component_type\" ] new_cls . message = client . cache . place_message_data ( data [ \"message\" ]) return new_cls async def defer ( self , ephemeral = False , edit_origin : bool = False ) -> None : \"\"\" Defers the response, showing a loading state. parameters: ephemeral: Should the response be ephemeral edit_origin: Whether we intend to edit the original message \"\"\" if self . deferred or self . responded : raise Exception ( \"You have already responded to this interaction!\" ) payload = { \"type\" : CallbackTypes . DEFERRED_UPDATE_MESSAGE if edit_origin else CallbackTypes . DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE } if ephemeral : if edit_origin : raise ValueError ( \"`edit_origin` and `ephemeral` are mutually exclusive\" ) payload [ \"data\" ] = { \"flags\" : MessageFlags . EPHEMERAL } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) self . deferred = True self . ephemeral = ephemeral self . defer_edit_origin = edit_origin async def edit_origin ( self , content : str = None , embeds : Optional [ Union [ List [ Union [ \"Embed\" , dict ]], Union [ \"Embed\" , dict ]]] = None , components : Optional [ Union [ List [ List [ Union [ \"BaseComponent\" , dict ]]], List [ Union [ \"BaseComponent\" , dict ]], \"BaseComponent\" , dict ] ] = None , allowed_mentions : Optional [ Union [ \"AllowedMentions\" , dict ]] = None , file : Optional [ Union [ \"File\" , \"IOBase\" , \"Path\" , str ]] = None , tts : bool = False , ) -> \"Message\" : \"\"\" Edits the original message of the component. parameters: content: Message text content. embeds: Embedded rich content (up to 6000 characters). components: The components to include with the message. allowed_mentions: Allowed mentions for the message. reply_to: Message to reference, must be from the same channel. file: Location of file to send, the bytes or the File() instance, defaults to None. tts: Should this message use Text To Speech. returns: The message after it was edited. \"\"\" if not self . responded and not self . deferred and file : # Discord doesn't allow files at initial response, so we defer then edit. await self . defer ( edit_origin = True ) message_payload = process_message_payload ( content = content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , file = file , tts = tts , ) message_data = None if self . deferred : message_data = await self . _client . http . edit_interaction_message ( message_payload , self . _client . user . id , self . _token ) self . deferred = False self . defer_edit_origin = False else : payload = { \"type\" : CallbackTypes . UPDATE_MESSAGE , \"data\" : message_payload } await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token ) message_data = await self . _client . http . get_interaction_message ( self . _client . user . id , self . _token ) if message_data : self . message = self . _client . cache . place_message_data ( message_data ) return self . message","title":"ComponentContext"},{"location":"API%20Reference/models/Internal%20Models/Context/#dis_snek.models.context.AutocompleteContext","text":"Source code in dis_snek/models/context.py @define class AutocompleteContext ( _BaseInteractionContext ): focussed_option : str = attr . ib ( default = MISSING , metadata = docs ( \"The option the user is currently filling in\" )) @classmethod def from_dict ( cls , data : Dict , client : \"Snake\" ) -> \"ComponentContext\" : \"\"\"Create a context object from a dictionary\"\"\" new_cls = super () . from_dict ( data , client ) return new_cls @property def input_text ( self ) -> str : \"\"\"The text the user has entered so far\"\"\" return self . kwargs . get ( self . focussed_option , \"\" ) async def send ( self , choices : List [ Union [ str , int , float , Dict [ str , Union [ str , int , float ]]]]): \"\"\" Send your autocomplete choices to discord. Choices must be either a list of strings, or a dictionary following the following format: ```json { \"name\": str, \"value\": str } ``` Where name is the text visible in Discord, and value is the data sent back to your client when that choice is chosen. Args: choices: 25 choices the user can pick \"\"\" processed_choices = [] for choice in choices : if isinstance ( choice , ( int , float )): processed_choices . append ({ \"name\" : str ( choice ), \"value\" : choice }) elif isinstance ( choice , dict ): processed_choices . append ( choice ) else : choice = str ( choice ) processed_choices . append ({ \"name\" : choice , \"value\" : choice . replace ( \" \" , \"_\" )}) payload = { \"type\" : CallbackTypes . AUTOCOMPLETE_RESULT , \"data\" : { \"choices\" : processed_choices }} await self . _client . http . post_initial_response ( payload , self . interaction_id , self . _token )","title":"AutocompleteContext"},{"location":"API%20Reference/models/Internal%20Models/Context/#dis_snek.models.context.MessageContext","text":"Source code in dis_snek/models/context.py @define class MessageContext ( Context , SendMixin ): prefix : str = attr . ib ( default = MISSING , metadata = docs ( \"The prefix used to invoke this command\" )) @classmethod def from_message ( cls , client : \"Snake\" , message : \"Message\" ): new_cls = cls ( client = client , message = message , author = message . author , channel = message . channel , guild_id = message . guild . id , ) return new_cls @property def content_parameters ( self ): return self . message . content . removeprefix ( f \" { self . prefix }{ self . invoked_name } \" ) . strip () async def _send_http_request ( self , message_payload : Union [ dict , \"FormData\" ]) -> dict : return await self . _client . http . create_message ( message_payload , self . channel . id )","title":"MessageContext"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/","text":"OptionTypes ( IntEnum ) \u00b6 Option types supported by slash commands. Source code in dis_snek/models/application_commands.py class OptionTypes ( IntEnum ): \"\"\"Option types supported by slash commands.\"\"\" SUB_COMMAND = 1 SUB_COMMAND_GROUP = 2 STRING = 3 INTEGER = 4 BOOLEAN = 5 USER = 6 CHANNEL = 7 ROLE = 8 MENTIONABLE = 9 NUMBER = 10 @classmethod def from_type ( cls , t : type ) -> \"OptionTypes\" : \"\"\" Convert data types to their corresponding OptionType. parameters: t: The datatype to convert returns: OptionType or None \"\"\" if issubclass ( t , str ): return cls . STRING if issubclass ( t , int ): return cls . INTEGER if issubclass ( t , bool ): return cls . BOOLEAN if issubclass ( t , BaseUser ): return cls . USER if issubclass ( t , BaseChannel ): return cls . CHANNEL if issubclass ( t , Role ): return cls . ROLE if issubclass ( t , float ): return cls . NUMBER PermissionTypes ( IntEnum ) \u00b6 Types of target supported by the interaction permission. Source code in dis_snek/models/application_commands.py class PermissionTypes ( IntEnum ): \"\"\"Types of target supported by the interaction permission.\"\"\" ROLE = 1 USER = 2 @classmethod def from_type ( cls , t : type ) -> \"PermissionTypes\" : if issubclass ( t , Role ): return cls . ROLE if issubclass ( t , BaseUser ): return cls . USER CallbackTypes ( IntEnum ) \u00b6 Types of callback supported by interaction response. Source code in dis_snek/models/application_commands.py class CallbackTypes ( IntEnum ): \"\"\"Types of callback supported by interaction response.\"\"\" PONG = 1 CHANNEL_MESSAGE_WITH_SOURCE = 4 DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE = 5 DEFERRED_UPDATE_MESSAGE = 6 UPDATE_MESSAGE = 7 AUTOCOMPLETE_RESULT = 8 Permission attrs \u00b6 Represents a interaction permission. Parameters: Name Type Description Default id Union[str, int, SnowflakeObject] The id of the role or user. required type The type of id (user or role) required permission bool The state of permission. True to allow, False , to disallow. True Source code in dis_snek/models/application_commands.py @attr . s ( slots = True ) class Permission : \"\"\" Represents a interaction permission. parameters: id: The id of the role or user. type: The type of id (user or role) permission: The state of permission. ``True`` to allow, ``False``, to disallow. \"\"\" id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) type : Union [ PermissionTypes , int ] = attr . ib ( converter = PermissionTypes ) permission : bool = attr . ib ( default = True ) def to_dict ( self ) -> dict : \"\"\" Convert this object into a dict ready for discord. returns: Representation of this object \"\"\" return attr . asdict ( self ) to_dict ( self ) \u00b6 Convert this object into a dict ready for discord. Returns: Type Description dict Representation of this object Source code in dis_snek/models/application_commands.py def to_dict ( self ) -> dict : \"\"\" Convert this object into a dict ready for discord. returns: Representation of this object \"\"\" return attr . asdict ( self ) InteractionCommand ( BaseCommand ) attrs \u00b6 Represents a discord abstract interaction command. Parameters: Name Type Description Default scope Denotes whether its global or for specific guild. required default_permission bool Is this command available to all users? True permissions Dict[Snowflake_Type, Union[dis_snek.models.application_commands.Permission, Dict]] Map of guild id and its respective list of permissions to apply. NOTHING cmd_id Snowflake_Type The id of this command given by discord. None callback Callable[..., Coroutine] The coroutine to callback when this interaction is received. None Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class InteractionCommand ( BaseCommand ): \"\"\" Represents a discord abstract interaction command. parameters: scope: Denotes whether its global or for specific guild. default_permission: Is this command available to all users? permissions: Map of guild id and its respective list of permissions to apply. cmd_id: The id of this command given by discord. callback: The coroutine to callback when this interaction is received. \"\"\" name : str = attr . ib ( metadata = docs ( \"1-32 character name\" ) | no_export_meta ) scopes : List [ \"Snowflake_Type\" ] = attr . ib ( default = [ GLOBAL_SCOPE ], converter = to_snowflake_list , metadata = docs ( \"The scopes of this interaction. Global or guild ids\" ) | no_export_meta , ) default_permission : bool = attr . ib ( default = True , metadata = docs ( \"whether this command is enabled by default when the app is added to a guild\" ) ) permissions : Dict [ \"Snowflake_Type\" , Union [ Permission , Dict ]] = attr . ib ( factory = dict , metadata = docs ( \"The permissions of this interaction\" ) ) cmd_id : \"Snowflake_Type\" = attr . ib ( default = None , metadata = docs ( \"The unique ID of this interaction\" ) | no_export_meta ) callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = docs ( \"The coroutine to call when this interaction is received\" ) | no_export_meta ) @property def resolved_name ( self ): \"\"\"A representation of this interaction's name\"\"\" return self . name @property def is_subcommand ( self ) -> bool : return False attrs-field kw_only callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to call when this interaction is received attrs-field inherited kw_only checks : list \u00b6 Any checks that must be checked before the command can run attrs-field kw_only cmd_id : Snowflake_Type \u00b6 The unique ID of this interaction attrs-field inherited kw_only cooldown : Cooldown \u00b6 An optional cooldown to apply to the command attrs-field kw_only default_permission : bool \u00b6 whether this command is enabled by default when the app is added to a guild attrs-field inherited kw_only enabled : bool \u00b6 Whether this can be run at all attrs-field inherited kw_only error_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called when an error occurs attrs-field inherited kw_only max_concurrency : MaxConcurrency \u00b6 An optional maximum number of concurrent instances to apply to the command attrs-field kw_only name : str \u00b6 1-32 character name attrs-field kw_only permissions : Dict [ Snowflake_Type , Union [ dis_snek . models . application_commands . Permission , Dict ]] \u00b6 The permissions of this interaction attrs-field inherited kw_only post_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called after the command has executed attrs-field inherited kw_only pre_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called before the command is executed, but after the checks attrs-field inherited kw_only scale : Any \u00b6 The scale this command belongs to attrs-field kw_only scopes : List [ Snowflake_Type ] \u00b6 The scopes of this interaction. Global or guild ids inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/application_commands.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/application_commands.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) property readonly resolved_name \u00b6 A representation of this interaction's name inherited error ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run upon an error. Source code in dis_snek/models/application_commands.py def error ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Error handler must be coroutine\" ) self . error_callback = call return call inherited pre_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run before the command Source code in dis_snek/models/application_commands.py def pre_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run before the command\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"pre_run must be coroutine\" ) self . pre_run_callback = call return call inherited post_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run after the command has Source code in dis_snek/models/application_commands.py def post_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run after the command has\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"post_run must be coroutine\" ) self . post_run_callback = call return call ContextMenu ( InteractionCommand ) attrs \u00b6 Represents a discord context menu. Parameters: Name Type Description Default name str The name of this entry. required type CommandTypes The type of entry (user or message). required Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class ContextMenu ( InteractionCommand ): \"\"\" Represents a discord context menu. parameters: name: The name of this entry. type: The type of entry (user or message). \"\"\" name : str = attr . ib ( metadata = docs ( \"1-32 character name\" )) type : CommandTypes = attr . ib ( metadata = docs ( \"The type of command, defaults to 1 if not specified\" )) @name . validator def _name_validator ( self , attribute : str , value : str ) -> None : if not 1 <= len ( value ) <= CONTEXT_MENU_NAME_LENGTH : raise ValueError ( \"Context Menu name attribute must be between 1 and 32 characters\" ) @type . validator def _type_validator ( self , attribute : str , value : int ): if not isinstance ( value , CommandTypes ): if value not in CommandTypes . __members__ . values (): raise ValueError ( \"Context Menu type not recognised, please consult the docs.\" ) elif value == CommandTypes . CHAT_INPUT : raise ValueError ( \"The CHAT_INPUT type is basically slash commands. Please use the @slash_command() \" \"decorator instead.\" ) attrs-field inherited kw_only callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to call when this interaction is received attrs-field inherited kw_only checks : list \u00b6 Any checks that must be checked before the command can run attrs-field inherited kw_only cmd_id : Snowflake_Type \u00b6 The unique ID of this interaction attrs-field inherited kw_only cooldown : Cooldown \u00b6 An optional cooldown to apply to the command attrs-field inherited kw_only default_permission : bool \u00b6 whether this command is enabled by default when the app is added to a guild attrs-field inherited kw_only enabled : bool \u00b6 Whether this can be run at all attrs-field inherited kw_only error_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called when an error occurs attrs-field inherited kw_only max_concurrency : MaxConcurrency \u00b6 An optional maximum number of concurrent instances to apply to the command attrs-field kw_only name : str \u00b6 1-32 character name attrs-field inherited kw_only permissions : Dict [ Snowflake_Type , Union [ dis_snek . models . application_commands . Permission , Dict ]] \u00b6 The permissions of this interaction attrs-field inherited kw_only post_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called after the command has executed attrs-field inherited kw_only pre_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called before the command is executed, but after the checks attrs-field inherited kw_only scale : Any \u00b6 The scale this command belongs to attrs-field inherited kw_only scopes : List [ Snowflake_Type ] \u00b6 The scopes of this interaction. Global or guild ids attrs-field kw_only type : CommandTypes \u00b6 The type of command, defaults to 1 if not specified inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/application_commands.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/application_commands.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) inherited property readonly resolved_name \u00b6 A representation of this interaction's name inherited error ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run upon an error. Source code in dis_snek/models/application_commands.py def error ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Error handler must be coroutine\" ) self . error_callback = call return call inherited pre_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run before the command Source code in dis_snek/models/application_commands.py def pre_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run before the command\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"pre_run must be coroutine\" ) self . pre_run_callback = call return call inherited post_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run after the command has Source code in dis_snek/models/application_commands.py def post_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run after the command has\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"post_run must be coroutine\" ) self . post_run_callback = call return call SlashCommandChoice ( DictSerializationMixin ) attrs \u00b6 Represents a discord slash command choice. Parameters: Name Type Description Default name str The name the user will see required value Union[str, int, float] The data sent to your code when this choice is used required Source code in dis_snek/models/application_commands.py @attr . s ( slots = True ) class SlashCommandChoice ( DictSerializationMixin ): \"\"\" Represents a discord slash command choice. parameters: name: The name the user will see value: The data sent to your code when this choice is used \"\"\" name : str = attr . ib () value : Union [ str , int , float ] = attr . ib () inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/application_commands.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/application_commands.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) SlashCommandOption ( DictSerializationMixin ) attrs \u00b6 Represents a discord slash command option. Parameters: Name Type Description Default name str The name of this option required type Union[dis_snek.models.application_commands.OptionTypes, int] The type of option required description str The description of this option 'No Description Set' required bool \"This option must be filled to use the command\" True choices List[Union[dis_snek.models.application_commands.SlashCommandChoice, Dict]] A list of choices the user has to pick between NOTHING channel_types Optional[list[Union[dis_snek.models.enums.ChannelTypes, int]]] The channel types permitted. The option needs to be a channel None min_value Optional[float] The minimum value permitted. The option needs to be an integer or float None max_value Optional[float] The maximum value permitted. The option needs to be an integer or float None Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class SlashCommandOption ( DictSerializationMixin ): \"\"\" Represents a discord slash command option. parameters: name: The name of this option type: The type of option description: The description of this option required: \"This option must be filled to use the command\" choices: A list of choices the user has to pick between channel_types: The channel types permitted. The option needs to be a channel min_value: The minimum value permitted. The option needs to be an integer or float max_value: The maximum value permitted. The option needs to be an integer or float \"\"\" name : str = attr . ib () type : Union [ OptionTypes , int ] = attr . ib () description : str = attr . ib ( default = \"No Description Set\" ) required : bool = attr . ib ( default = True ) autocomplete : bool = attr . ib ( default = False ) choices : List [ Union [ SlashCommandChoice , Dict ]] = attr . ib ( factory = list ) channel_types : Optional [ list [ Union [ ChannelTypes , int ]]] = attr . ib ( default = None ) min_value : Optional [ float ] = attr . ib ( default = None ) max_value : Optional [ float ] = attr . ib ( default = None ) @name . validator def _name_validator ( self , attribute : str , value : str ) -> None : if not re . match ( rf \"^[\\w-] {{ 1, { SLASH_CMD_NAME_LENGTH } }} $\" , value ) or value != value . lower (): raise ValueError ( f \"Options names must be lower case and match this regex: ^[\\w-] { 1 ,{ SLASH_CMD_NAME_LENGTH } } $\" ) # noqa: W605 @description . validator def _description_validator ( self , attribute : str , value : str ) -> None : if not 1 <= len ( value ) <= SLASH_OPTION_NAME_LENGTH : raise ValueError ( \"Options must be between 1 and 100 characters long\" ) @type . validator def _type_validator ( self , attribute : str , value : int ) -> None : if value == OptionTypes . SUB_COMMAND or value == OptionTypes . SUB_COMMAND_GROUP : raise ValueError ( \"Options cannot be SUB_COMMAND or SUB_COMMAND_GROUP. If you want to use subcommands, \" \"see the @sub_command() decorator.\" ) @channel_types . validator def _channel_types_validator ( self , attribute : str , value : Optional [ list [ OptionTypes ]]) -> None : if value is not None : if self . type != OptionTypes . CHANNEL : raise ValueError ( \"The option needs to be CHANNEL to use this\" ) allowed_int = [ channel_type . value for channel_type in ChannelTypes ] for item in value : if ( item not in allowed_int ) and ( item not in ChannelTypes ): raise ValueError ( f \" { value } is not allowed here\" ) @min_value . validator def _min_value_validator ( self , attribute : str , value : Optional [ float ]) -> None : if value is not None : if self . type != OptionTypes . INTEGER and self . type != OptionTypes . NUMBER : raise ValueError ( \"`min_value` can only be supplied with int or float options\" ) if self . type == OptionTypes . INTEGER : if isinstance ( value , float ): raise ValueError ( \"`min_value` needs to be an int in an int option\" ) if self . max_value is not None and self . min_value is not None : if self . max_value < self . min_value : raise ValueError ( \"`min_value` needs to be <= than `max_value`\" ) @max_value . validator def _max_value_validator ( self , attribute : str , value : Optional [ float ]) -> None : if value is not None : if self . type != OptionTypes . INTEGER and self . type != OptionTypes . NUMBER : raise ValueError ( \"`max_value` can only be supplied with int or float options\" ) if self . type == OptionTypes . INTEGER : if isinstance ( value , float ): raise ValueError ( \"`max_value` needs to be an int in an int option\" ) if self . max_value and self . min_value : if self . max_value < self . min_value : raise ValueError ( \"`min_value` needs to be <= than `max_value`\" ) inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/application_commands.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/application_commands.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) SlashCommand ( InteractionCommand ) attrs \u00b6 Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class SlashCommand ( InteractionCommand ): name : str = attr . ib () description : str = attr . ib ( \"No Description Set\" ) group_name : str = attr . ib ( default = None , metadata = no_export_meta ) group_description : str = attr . ib ( default = \"No Description Set\" , metadata = no_export_meta ) sub_cmd_name : str = attr . ib ( default = None , metadata = no_export_meta ) sub_cmd_description : str = attr . ib ( default = \"No Description Set\" , metadata = no_export_meta ) options : List [ Union [ SlashCommandOption , Dict ]] = attr . ib ( factory = list ) autocomplete_callbacks : dict = attr . ib ( factory = dict , metadata = no_export_meta ) @property def resolved_name ( self ): return f \" { self . name }{ f ' { self . group_name } ' if self . group_name else '' }{ f ' { self . sub_cmd_name } ' if self . sub_cmd_name else '' } \" @property def is_subcommand ( self ) -> bool : return not self . sub_cmd_name is None def __attrs_post_init__ ( self ): params = get_parameters ( self . callback ) for name , val in params . items (): if val . annotation and isinstance ( val . annotation , SlashCommandOption ): if not self . options : self . options = [] val . annotation . name = name self . options . append ( val . annotation ) if self . callback is not None : if hasattr ( self . callback , \"options\" ): if not self . options : self . options = [] self . options += self . callback . options if hasattr ( self . callback , \"permissions\" ): self . permissions = self . callback . permissions super () . __attrs_post_init__ () def to_dict ( self ) -> dict : data = super () . to_dict () if self . is_subcommand : data [ \"name\" ] = self . sub_cmd_name data [ \"description\" ] = self . sub_cmd_description data . pop ( \"default_permission\" , None ) return data @name . validator @group_name . validator @sub_cmd_name . validator def name_validator ( self , attribute : str , value : str ) -> None : if value : if not re . match ( rf \"^[\\w-] {{ 1, { SLASH_CMD_NAME_LENGTH } }} $\" , value ) or value != value . lower (): raise ValueError ( f \"Slash Command names must be lower case and match this regex: ^[\\w-] { 1 , { SLASH_CMD_NAME_LENGTH } } $\" ) # noqa: W605 @description . validator @group_description . validator @sub_cmd_description . validator def description_validator ( self , attribute : str , value : str ) -> None : if not 1 <= len ( value ) <= SLASH_CMD_MAX_DESC_LENGTH : raise ValueError ( f \"Description must be between 1 and { SLASH_CMD_MAX_DESC_LENGTH } characters long\" ) @options . validator def options_validator ( self , attribute : str , value : List ) -> None : if value : if isinstance ( value , list ): if len ( value ) > SLASH_CMD_MAX_OPTIONS : raise ValueError ( f \"Slash commands can only hold { SLASH_CMD_MAX_OPTIONS } options\" ) if value != sorted ( value , key = lambda x : x . required if isinstance ( x , SlashCommandOption ) else x [ \"required\" ], reverse = True , ): raise ValueError ( \"Required options must go before optional options\" ) else : raise TypeError ( \"Options attribute must be either None or a list of options\" ) def autocomplete ( self , option_name : str ): \"\"\"A decorator to declare a coroutine as an option autocomplete\"\"\" def wrapper ( call : Callable [ ... , Coroutine ]): if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"autocomplete must be coroutine\" ) self . autocomplete_callbacks [ option_name ] = call # automatically set the option's autocomplete attribute to True for opt in self . options : if isinstance ( opt , dict ) and opt [ \"name\" ] == option_name : opt [ \"autocomplete\" ] = True elif isinstance ( opt , SlashCommandOption ) and opt . name == option_name : opt . autocomplete = True return call option_name = option_name . lower () return wrapper def subcommand ( self , sub_cmd_name : str , group_name : str = None , group_description : str = \"No Description Set\" , sub_cmd_description : str = \"No Description Set\" , options : List [ Union [ SlashCommandOption , Dict ]] = None , ) -> Callable [ ... , \"SlashCommand\" ]: def wrapper ( call : Callable [ ... , Coroutine ]) -> \"SlashCommand\" : if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Subcommand must be coroutine\" ) return SlashCommand ( name = self . name , description = self . description , group_name = group_name , group_description = group_description , sub_cmd_name = sub_cmd_name , sub_cmd_description = sub_cmd_description , options = options , callback = call , ) return wrapper attrs-field inherited kw_only callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to call when this interaction is received attrs-field inherited kw_only checks : list \u00b6 Any checks that must be checked before the command can run attrs-field inherited kw_only cmd_id : Snowflake_Type \u00b6 The unique ID of this interaction attrs-field inherited kw_only cooldown : Cooldown \u00b6 An optional cooldown to apply to the command attrs-field inherited kw_only default_permission : bool \u00b6 whether this command is enabled by default when the app is added to a guild attrs-field inherited kw_only enabled : bool \u00b6 Whether this can be run at all attrs-field inherited kw_only error_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called when an error occurs attrs-field inherited kw_only max_concurrency : MaxConcurrency \u00b6 An optional maximum number of concurrent instances to apply to the command attrs-field inherited kw_only permissions : Dict [ Snowflake_Type , Union [ dis_snek . models . application_commands . Permission , Dict ]] \u00b6 The permissions of this interaction attrs-field inherited kw_only post_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called after the command has executed attrs-field inherited kw_only pre_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called before the command is executed, but after the checks attrs-field inherited kw_only scale : Any \u00b6 The scale this command belongs to attrs-field inherited kw_only scopes : List [ Snowflake_Type ] \u00b6 The scopes of this interaction. Global or guild ids inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/application_commands.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited error ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run upon an error. Source code in dis_snek/models/application_commands.py def error ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Error handler must be coroutine\" ) self . error_callback = call return call inherited pre_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run before the command Source code in dis_snek/models/application_commands.py def pre_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run before the command\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"pre_run must be coroutine\" ) self . pre_run_callback = call return call inherited post_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run after the command has Source code in dis_snek/models/application_commands.py def post_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run after the command has\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"post_run must be coroutine\" ) self . post_run_callback = call return call property readonly resolved_name \u00b6 A representation of this interaction's name to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description dict The exported dictionary. Source code in dis_snek/models/application_commands.py def to_dict ( self ) -> dict : data = super () . to_dict () if self . is_subcommand : data [ \"name\" ] = self . sub_cmd_name data [ \"description\" ] = self . sub_cmd_description data . pop ( \"default_permission\" , None ) return data autocomplete ( self , option_name ) \u00b6 A decorator to declare a coroutine as an option autocomplete Source code in dis_snek/models/application_commands.py def autocomplete ( self , option_name : str ): \"\"\"A decorator to declare a coroutine as an option autocomplete\"\"\" def wrapper ( call : Callable [ ... , Coroutine ]): if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"autocomplete must be coroutine\" ) self . autocomplete_callbacks [ option_name ] = call # automatically set the option's autocomplete attribute to True for opt in self . options : if isinstance ( opt , dict ) and opt [ \"name\" ] == option_name : opt [ \"autocomplete\" ] = True elif isinstance ( opt , SlashCommandOption ) and opt . name == option_name : opt . autocomplete = True return call option_name = option_name . lower () return wrapper ComponentCommand ( InteractionCommand ) attrs \u00b6 Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class ComponentCommand ( InteractionCommand ): # right now this adds no extra functionality, but for future dev ive implemented it listeners : list [ str ] = attr . ib ( factory = list ) attrs-field inherited kw_only callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to call when this interaction is received attrs-field inherited kw_only checks : list \u00b6 Any checks that must be checked before the command can run attrs-field inherited kw_only cmd_id : Snowflake_Type \u00b6 The unique ID of this interaction attrs-field inherited kw_only cooldown : Cooldown \u00b6 An optional cooldown to apply to the command attrs-field inherited kw_only default_permission : bool \u00b6 whether this command is enabled by default when the app is added to a guild attrs-field inherited kw_only enabled : bool \u00b6 Whether this can be run at all attrs-field inherited kw_only error_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called when an error occurs attrs-field inherited kw_only max_concurrency : MaxConcurrency \u00b6 An optional maximum number of concurrent instances to apply to the command attrs-field inherited kw_only name : str \u00b6 1-32 character name attrs-field inherited kw_only permissions : Dict [ Snowflake_Type , Union [ dis_snek . models . application_commands . Permission , Dict ]] \u00b6 The permissions of this interaction attrs-field inherited kw_only post_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called after the command has executed attrs-field inherited kw_only pre_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called before the command is executed, but after the checks attrs-field inherited kw_only scale : Any \u00b6 The scale this command belongs to attrs-field inherited kw_only scopes : List [ Snowflake_Type ] \u00b6 The scopes of this interaction. Global or guild ids inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/application_commands.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/application_commands.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) inherited property readonly resolved_name \u00b6 A representation of this interaction's name inherited error ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run upon an error. Source code in dis_snek/models/application_commands.py def error ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Error handler must be coroutine\" ) self . error_callback = call return call inherited pre_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run before the command Source code in dis_snek/models/application_commands.py def pre_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run before the command\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"pre_run must be coroutine\" ) self . pre_run_callback = call return call inherited post_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run after the command has Source code in dis_snek/models/application_commands.py def post_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run after the command has\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"post_run must be coroutine\" ) self . post_run_callback = call return call slash_command ( name , description = 'No Description Set' , scopes = MISSING , options = None , default_permission = True , permissions = None , sub_cmd_name = None , group_name = None , sub_cmd_description = 'No Description Set' , group_description = 'No Description Set' ) \u00b6 A decorator to declare a coroutine as a slash command. Note While the base and group descriptions arent visible in the discord client, currently. We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in one of the future ui updates. Parameters: Name Type Description Default name str 1-32 character name of the command required description str 1-100 character description of the command 'No Description Set' scope The scope this command exists within required options Optional[List[Union[dis_snek.models.application_commands.SlashCommandOption, Dict]]] The parameters for the command, max 25 None default_permission bool Whether the command is enabled by default when the app is added to a guild True permissions Optional[Dict[Snowflake_Type, Union[dis_snek.models.application_commands.Permission, Dict]]] The roles or users who can use this command None sub_cmd_name str 1-32 character name of the subcommand None sub_cmd_description str 1-100 character description of the subcommand 'No Description Set' group_name str 1-32 character name of the group None group_description str 1-100 character description of the group 'No Description Set' Returns: Type Description SlashCommand Object Source code in dis_snek/models/application_commands.py def slash_command ( name : str , description : str = \"No Description Set\" , scopes : List [ \"Snowflake_Type\" ] = MISSING , options : Optional [ List [ Union [ SlashCommandOption , Dict ]]] = None , default_permission : bool = True , permissions : Optional [ Dict [ \"Snowflake_Type\" , Union [ Permission , Dict ]]] = None , sub_cmd_name : str = None , group_name : str = None , sub_cmd_description : str = \"No Description Set\" , group_description : str = \"No Description Set\" , ): \"\"\" A decorator to declare a coroutine as a slash command. note: While the base and group descriptions arent visible in the discord client, currently. We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in one of the future ui updates. parameters: name: 1-32 character name of the command description: 1-100 character description of the command scope: The scope this command exists within options: The parameters for the command, max 25 default_permission: Whether the command is enabled by default when the app is added to a guild permissions: The roles or users who can use this command sub_cmd_name: 1-32 character name of the subcommand sub_cmd_description: 1-100 character description of the subcommand group_name: 1-32 character name of the group group_description: 1-100 character description of the group returns: SlashCommand Object \"\"\" def wrapper ( func ) -> SlashCommand : if not asyncio . iscoroutinefunction ( func ): raise ValueError ( \"Commands must be coroutines\" ) cmd = SlashCommand ( name = name , group_name = group_name , group_description = group_description , sub_cmd_name = sub_cmd_name , sub_cmd_description = sub_cmd_description , description = description , scopes = scopes if scopes else [ GLOBAL_SCOPE ], default_permission = default_permission , permissions = permissions or {}, callback = func , options = options , ) return cmd return wrapper context_menu ( name , context_type , scopes = MISSING , default_permission = True , permissions = None ) \u00b6 A decorator to declare a coroutine as a Context Menu Parameters: Name Type Description Default name str 1-32 character name of the context menu required context_type CommandTypes The type of context menu required scope The scope this command exists within required default_permission bool Whether the menu is enabled by default when the app is added to a guild True permissions Optional[Dict[Snowflake_Type, Union[dis_snek.models.application_commands.Permission, Dict]]] The roles or users who can use this menu None Returns: Type Description ContextMenu object Source code in dis_snek/models/application_commands.py def context_menu ( name : str , context_type : \"CommandTypes\" , scopes : List [ \"Snowflake_Type\" ] = MISSING , default_permission : bool = True , permissions : Optional [ Dict [ \"Snowflake_Type\" , Union [ Permission , Dict ]]] = None , ): \"\"\" A decorator to declare a coroutine as a Context Menu parameters: name: 1-32 character name of the context menu context_type: The type of context menu scope: The scope this command exists within default_permission: Whether the menu is enabled by default when the app is added to a guild permissions: The roles or users who can use this menu returns: ContextMenu object \"\"\" def wrapper ( func ) -> ContextMenu : if not asyncio . iscoroutinefunction ( func ): raise ValueError ( \"Commands must be coroutines\" ) perm = permissions if hasattr ( func , \"permissions\" ): if perm : perm . update ( func . permissions ) else : perm = func . permissions cmd = ContextMenu ( name = name , type = context_type , scopes = scopes if scopes else [ GLOBAL_SCOPE ], default_permission = default_permission , permissions = perm , callback = func , ) return cmd return wrapper component_callback ( * custom_id ) \u00b6 Register a coroutine as a component callback. Component callbacks work the same way as commands, just using components as a way of invoking, instead of messages. Your callback will be given a single argument, ComponentContext Parameters: Name Type Description Default custom_id str The custom ID of the component to wait for () Source code in dis_snek/models/application_commands.py def component_callback ( * custom_id : str ): \"\"\" Register a coroutine as a component callback. Component callbacks work the same way as commands, just using components as a way of invoking, instead of messages. Your callback will be given a single argument, `ComponentContext` Args: custom_id: The custom ID of the component to wait for \"\"\" def wrapper ( func ) -> ComponentCommand : if not asyncio . iscoroutinefunction ( func ): raise ValueError ( \"Commands must be coroutines\" ) return ComponentCommand ( name = f \"ComponentCallback:: { custom_id } \" , callback = func , listeners = custom_id ) # allows a mixture of generators and strings to be passed unpack = [] for c in custom_id : if inspect . isgenerator ( c ): unpack += list ( c ) else : unpack . append ( c ) custom_id = unpack return wrapper slash_option ( name , description , opt_type , required = False , autocomplete = False , choices = None , channel_types = None , min_value = None , max_value = None ) \u00b6 A decorator to add an option to a slash command. Parameters: Name Type Description Default name str 1-32 lowercase character name matching ^[\\w-]{1,32}$ required opt_type Union[dis_snek.models.application_commands.OptionTypes, int] The type of option required description str 1-100 character description of option required required bool If the parameter is required or optional--default false False choices List[Union[dis_snek.models.application_commands.SlashCommandChoice, dict]] A list of choices the user has to pick between (max 25) None channel_types Optional[list[Union[dis_snek.models.enums.ChannelTypes, int]]] The channel types permitted. The option needs to be a channel None min_value Optional[float] The minimum value permitted. The option needs to be an integer or float None max_value Optional[float] The maximum value permitted. The option needs to be an integer or float None Source code in dis_snek/models/application_commands.py def slash_option ( name : str , description : str , opt_type : Union [ OptionTypes , int ], required : bool = False , autocomplete : bool = False , choices : List [ Union [ SlashCommandChoice , dict ]] = None , channel_types : Optional [ list [ Union [ ChannelTypes , int ]]] = None , min_value : Optional [ float ] = None , max_value : Optional [ float ] = None , ) -> Any : \"\"\" A decorator to add an option to a slash command. parameters: name: 1-32 lowercase character name matching ^[\\w-]{1,32}$ opt_type: The type of option description: 1-100 character description of option required: If the parameter is required or optional--default false choices: A list of choices the user has to pick between (max 25) channel_types: The channel types permitted. The option needs to be a channel min_value: The minimum value permitted. The option needs to be an integer or float max_value: The maximum value permitted. The option needs to be an integer or float \"\"\" def wrapper ( func ): if hasattr ( func , \"cmd_id\" ): raise Exception ( \"slash_option decorators must be positioned under a slash_command decorator\" ) option = SlashCommandOption ( name = name , type = opt_type , description = description , required = required , autocomplete = autocomplete , choices = choices if choices else [], channel_types = channel_types , min_value = min_value , max_value = max_value , ) if not hasattr ( func , \"options\" ): func . options = [] func . options . insert ( 0 , option ) return func return wrapper slash_permission ( guild_id , permissions ) \u00b6 A decorator to add permissions for a guild to a slash command or context menu. Parameters: Name Type Description Default guild_id Snowflake_Type The target guild to apply the permissions. required permissions List[Union[dis_snek.models.application_commands.Permission, Dict]] A list of interaction permission rights. required Source code in dis_snek/models/application_commands.py def slash_permission ( guild_id : \"Snowflake_Type\" , permissions : List [ Union [ Permission , Dict ]]) -> Any : \"\"\" A decorator to add permissions for a guild to a slash command or context menu. parameters: guild_id: The target guild to apply the permissions. permissions: A list of interaction permission rights. \"\"\" guild_id = to_snowflake ( guild_id ) def wrapper ( func ): if hasattr ( func , \"cmd_id\" ): raise Exception ( \"slash_option decorators must be positioned under a slash_command decorator\" ) if not hasattr ( func , \"permissions\" ): func . permissions = {} if guild_id not in func . permissions : func . permissions [ guild_id ] = [] func . permissions [ guild_id ] += permissions return func return wrapper application_commands_to_dict ( commands ) \u00b6 Convert the command list into a format that would be accepted by discord Snake.interactions should be the variable passed to this Source code in dis_snek/models/application_commands.py def application_commands_to_dict ( commands : Dict [ \"Snowflake_Type\" , Dict [ str , InteractionCommand ]]) -> dict : \"\"\"Convert the command list into a format that would be accepted by discord `Snake.interactions` should be the variable passed to this\"\"\" cmd_bases = {} # {cmd_base: [commands]} \"\"\"A store of commands organised by their base command\"\"\" output = {} \"\"\"The output dictionary\"\"\" def squash_subcommand ( subcommands : List ) -> Dict : output_data = {} groups = {} sub_cmds = [] for subcommand in subcommands : if not output_data : output_data = { \"name\" : subcommand . name , \"description\" : subcommand . description , \"options\" : [], \"permissions\" : subcommand . permissions , \"default_permission\" : subcommand . default_permission , } if subcommand . group_name : if subcommand . group_name not in groups : groups [ subcommand . group_name ] = { \"name\" : subcommand . group_name , \"description\" : subcommand . group_description , \"type\" : int ( OptionTypes . SUB_COMMAND_GROUP ), \"options\" : [], } groups [ subcommand . group_name ][ \"options\" ] . append ( subcommand . to_dict () | { \"type\" : int ( OptionTypes . SUB_COMMAND )} ) else : sub_cmds . append ( subcommand . to_dict () | { \"type\" : int ( OptionTypes . SUB_COMMAND )}) options = [ g for g in groups . values ()] + sub_cmds output_data [ \"options\" ] = options return output_data for scope , cmds in commands . items (): for cmd in cmds . values (): if cmd . name not in cmd_bases : cmd_bases [ cmd . name ] = [ cmd ] continue if cmd not in cmd_bases [ cmd . name ]: cmd_bases [ cmd . name ] . append ( cmd ) for cmd_list in cmd_bases . values (): if any ( c . is_subcommand for c in cmd_list ): # validate all commands share required attributes scopes : list [ Snowflake_Type ] = list ( set ( s for c in cmd_list for s in c . scopes )) permissions : dict = { k : v for c in cmd_list for k , v in c . permissions . items ()} base_description = next ( ( c . description for c in cmd_list if c . description is not None ), \"No Description Set\" ) if not all ( c . description in ( base_description , \"No Description Set\" ) for c in cmd_list ): log . warning ( f \"Conflicting descriptions found in ` { cmd_list [ 0 ] . name } ` subcommands; ` { base_description } ` will be used\" ) if not all ( c . default_permission == cmd_list [ 0 ] . default_permission for c in cmd_list ): raise ValueError ( f \"Conflicting `default_permission` values found in ` { cmd_list [ 0 ] . name } `\" ) for cmd in cmd_list : cmd . scopes = list ( scopes ) cmd . permissions = permissions cmd . description = base_description # end validation of attributes cmd_data = squash_subcommand ( cmd_list ) else : scopes = cmd_list [ 0 ] . scopes cmd_data = cmd_list [ 0 ] . to_dict () for s in scopes : if s not in output : output [ s ] = [ cmd_data ] continue output [ s ] . append ( cmd_data ) return output sync_needed ( local_cmd , remote_cmd = None ) \u00b6 Compares a local application command to its remote counterpart to determine if a sync is required. Parameters: Name Type Description Default local_cmd dict The local json representation of the command required remote_cmd Optional[dict] The json representation of the command from Discord None Returns: Type Description bool Boolean indicating if a sync is needed Source code in dis_snek/models/application_commands.py def sync_needed ( local_cmd : dict , remote_cmd : Optional [ dict ] = None ) -> bool : \"\"\" Compares a local application command to its remote counterpart to determine if a sync is required. Args: local_cmd: The local json representation of the command remote_cmd: The json representation of the command from Discord Returns: Boolean indicating if a sync is needed \"\"\" if not remote_cmd : # No remote version, command must be new return True if ( local_cmd [ \"name\" ] != remote_cmd [ \"name\" ] or local_cmd . get ( \"description\" , \"\" ) != remote_cmd . get ( \"description\" , \"\" ) or local_cmd [ \"default_permission\" ] != remote_cmd [ \"default_permission\" ] ): # basic comparison of attributes return True if remote_cmd [ \"type\" ] == CommandTypes . CHAT_INPUT : try : if not _compare_options ( local_cmd [ \"options\" ], remote_cmd [ \"options\" ]): # options are not the same, sync needed return True except KeyError : if \"options\" in local_cmd or \"options\" in remote_cmd : return True return False","title":"Application commands"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.OptionTypes","text":"Option types supported by slash commands. Source code in dis_snek/models/application_commands.py class OptionTypes ( IntEnum ): \"\"\"Option types supported by slash commands.\"\"\" SUB_COMMAND = 1 SUB_COMMAND_GROUP = 2 STRING = 3 INTEGER = 4 BOOLEAN = 5 USER = 6 CHANNEL = 7 ROLE = 8 MENTIONABLE = 9 NUMBER = 10 @classmethod def from_type ( cls , t : type ) -> \"OptionTypes\" : \"\"\" Convert data types to their corresponding OptionType. parameters: t: The datatype to convert returns: OptionType or None \"\"\" if issubclass ( t , str ): return cls . STRING if issubclass ( t , int ): return cls . INTEGER if issubclass ( t , bool ): return cls . BOOLEAN if issubclass ( t , BaseUser ): return cls . USER if issubclass ( t , BaseChannel ): return cls . CHANNEL if issubclass ( t , Role ): return cls . ROLE if issubclass ( t , float ): return cls . NUMBER","title":"OptionTypes"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.PermissionTypes","text":"Types of target supported by the interaction permission. Source code in dis_snek/models/application_commands.py class PermissionTypes ( IntEnum ): \"\"\"Types of target supported by the interaction permission.\"\"\" ROLE = 1 USER = 2 @classmethod def from_type ( cls , t : type ) -> \"PermissionTypes\" : if issubclass ( t , Role ): return cls . ROLE if issubclass ( t , BaseUser ): return cls . USER","title":"PermissionTypes"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.CallbackTypes","text":"Types of callback supported by interaction response. Source code in dis_snek/models/application_commands.py class CallbackTypes ( IntEnum ): \"\"\"Types of callback supported by interaction response.\"\"\" PONG = 1 CHANNEL_MESSAGE_WITH_SOURCE = 4 DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE = 5 DEFERRED_UPDATE_MESSAGE = 6 UPDATE_MESSAGE = 7 AUTOCOMPLETE_RESULT = 8","title":"CallbackTypes"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.Permission","text":"Represents a interaction permission. Parameters: Name Type Description Default id Union[str, int, SnowflakeObject] The id of the role or user. required type The type of id (user or role) required permission bool The state of permission. True to allow, False , to disallow. True Source code in dis_snek/models/application_commands.py @attr . s ( slots = True ) class Permission : \"\"\" Represents a interaction permission. parameters: id: The id of the role or user. type: The type of id (user or role) permission: The state of permission. ``True`` to allow, ``False``, to disallow. \"\"\" id : \"Snowflake_Type\" = attr . ib ( converter = to_snowflake ) type : Union [ PermissionTypes , int ] = attr . ib ( converter = PermissionTypes ) permission : bool = attr . ib ( default = True ) def to_dict ( self ) -> dict : \"\"\" Convert this object into a dict ready for discord. returns: Representation of this object \"\"\" return attr . asdict ( self )","title":"Permission"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.InteractionCommand","text":"Represents a discord abstract interaction command. Parameters: Name Type Description Default scope Denotes whether its global or for specific guild. required default_permission bool Is this command available to all users? True permissions Dict[Snowflake_Type, Union[dis_snek.models.application_commands.Permission, Dict]] Map of guild id and its respective list of permissions to apply. NOTHING cmd_id Snowflake_Type The id of this command given by discord. None callback Callable[..., Coroutine] The coroutine to callback when this interaction is received. None Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class InteractionCommand ( BaseCommand ): \"\"\" Represents a discord abstract interaction command. parameters: scope: Denotes whether its global or for specific guild. default_permission: Is this command available to all users? permissions: Map of guild id and its respective list of permissions to apply. cmd_id: The id of this command given by discord. callback: The coroutine to callback when this interaction is received. \"\"\" name : str = attr . ib ( metadata = docs ( \"1-32 character name\" ) | no_export_meta ) scopes : List [ \"Snowflake_Type\" ] = attr . ib ( default = [ GLOBAL_SCOPE ], converter = to_snowflake_list , metadata = docs ( \"The scopes of this interaction. Global or guild ids\" ) | no_export_meta , ) default_permission : bool = attr . ib ( default = True , metadata = docs ( \"whether this command is enabled by default when the app is added to a guild\" ) ) permissions : Dict [ \"Snowflake_Type\" , Union [ Permission , Dict ]] = attr . ib ( factory = dict , metadata = docs ( \"The permissions of this interaction\" ) ) cmd_id : \"Snowflake_Type\" = attr . ib ( default = None , metadata = docs ( \"The unique ID of this interaction\" ) | no_export_meta ) callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = docs ( \"The coroutine to call when this interaction is received\" ) | no_export_meta ) @property def resolved_name ( self ): \"\"\"A representation of this interaction's name\"\"\" return self . name @property def is_subcommand ( self ) -> bool : return False","title":"InteractionCommand"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.ContextMenu","text":"Represents a discord context menu. Parameters: Name Type Description Default name str The name of this entry. required type CommandTypes The type of entry (user or message). required Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class ContextMenu ( InteractionCommand ): \"\"\" Represents a discord context menu. parameters: name: The name of this entry. type: The type of entry (user or message). \"\"\" name : str = attr . ib ( metadata = docs ( \"1-32 character name\" )) type : CommandTypes = attr . ib ( metadata = docs ( \"The type of command, defaults to 1 if not specified\" )) @name . validator def _name_validator ( self , attribute : str , value : str ) -> None : if not 1 <= len ( value ) <= CONTEXT_MENU_NAME_LENGTH : raise ValueError ( \"Context Menu name attribute must be between 1 and 32 characters\" ) @type . validator def _type_validator ( self , attribute : str , value : int ): if not isinstance ( value , CommandTypes ): if value not in CommandTypes . __members__ . values (): raise ValueError ( \"Context Menu type not recognised, please consult the docs.\" ) elif value == CommandTypes . CHAT_INPUT : raise ValueError ( \"The CHAT_INPUT type is basically slash commands. Please use the @slash_command() \" \"decorator instead.\" )","title":"ContextMenu"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.SlashCommandChoice","text":"Represents a discord slash command choice. Parameters: Name Type Description Default name str The name the user will see required value Union[str, int, float] The data sent to your code when this choice is used required Source code in dis_snek/models/application_commands.py @attr . s ( slots = True ) class SlashCommandChoice ( DictSerializationMixin ): \"\"\" Represents a discord slash command choice. parameters: name: The name the user will see value: The data sent to your code when this choice is used \"\"\" name : str = attr . ib () value : Union [ str , int , float ] = attr . ib ()","title":"SlashCommandChoice"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.SlashCommandOption","text":"Represents a discord slash command option. Parameters: Name Type Description Default name str The name of this option required type Union[dis_snek.models.application_commands.OptionTypes, int] The type of option required description str The description of this option 'No Description Set' required bool \"This option must be filled to use the command\" True choices List[Union[dis_snek.models.application_commands.SlashCommandChoice, Dict]] A list of choices the user has to pick between NOTHING channel_types Optional[list[Union[dis_snek.models.enums.ChannelTypes, int]]] The channel types permitted. The option needs to be a channel None min_value Optional[float] The minimum value permitted. The option needs to be an integer or float None max_value Optional[float] The maximum value permitted. The option needs to be an integer or float None Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class SlashCommandOption ( DictSerializationMixin ): \"\"\" Represents a discord slash command option. parameters: name: The name of this option type: The type of option description: The description of this option required: \"This option must be filled to use the command\" choices: A list of choices the user has to pick between channel_types: The channel types permitted. The option needs to be a channel min_value: The minimum value permitted. The option needs to be an integer or float max_value: The maximum value permitted. The option needs to be an integer or float \"\"\" name : str = attr . ib () type : Union [ OptionTypes , int ] = attr . ib () description : str = attr . ib ( default = \"No Description Set\" ) required : bool = attr . ib ( default = True ) autocomplete : bool = attr . ib ( default = False ) choices : List [ Union [ SlashCommandChoice , Dict ]] = attr . ib ( factory = list ) channel_types : Optional [ list [ Union [ ChannelTypes , int ]]] = attr . ib ( default = None ) min_value : Optional [ float ] = attr . ib ( default = None ) max_value : Optional [ float ] = attr . ib ( default = None ) @name . validator def _name_validator ( self , attribute : str , value : str ) -> None : if not re . match ( rf \"^[\\w-] {{ 1, { SLASH_CMD_NAME_LENGTH } }} $\" , value ) or value != value . lower (): raise ValueError ( f \"Options names must be lower case and match this regex: ^[\\w-] { 1 ,{ SLASH_CMD_NAME_LENGTH } } $\" ) # noqa: W605 @description . validator def _description_validator ( self , attribute : str , value : str ) -> None : if not 1 <= len ( value ) <= SLASH_OPTION_NAME_LENGTH : raise ValueError ( \"Options must be between 1 and 100 characters long\" ) @type . validator def _type_validator ( self , attribute : str , value : int ) -> None : if value == OptionTypes . SUB_COMMAND or value == OptionTypes . SUB_COMMAND_GROUP : raise ValueError ( \"Options cannot be SUB_COMMAND or SUB_COMMAND_GROUP. If you want to use subcommands, \" \"see the @sub_command() decorator.\" ) @channel_types . validator def _channel_types_validator ( self , attribute : str , value : Optional [ list [ OptionTypes ]]) -> None : if value is not None : if self . type != OptionTypes . CHANNEL : raise ValueError ( \"The option needs to be CHANNEL to use this\" ) allowed_int = [ channel_type . value for channel_type in ChannelTypes ] for item in value : if ( item not in allowed_int ) and ( item not in ChannelTypes ): raise ValueError ( f \" { value } is not allowed here\" ) @min_value . validator def _min_value_validator ( self , attribute : str , value : Optional [ float ]) -> None : if value is not None : if self . type != OptionTypes . INTEGER and self . type != OptionTypes . NUMBER : raise ValueError ( \"`min_value` can only be supplied with int or float options\" ) if self . type == OptionTypes . INTEGER : if isinstance ( value , float ): raise ValueError ( \"`min_value` needs to be an int in an int option\" ) if self . max_value is not None and self . min_value is not None : if self . max_value < self . min_value : raise ValueError ( \"`min_value` needs to be <= than `max_value`\" ) @max_value . validator def _max_value_validator ( self , attribute : str , value : Optional [ float ]) -> None : if value is not None : if self . type != OptionTypes . INTEGER and self . type != OptionTypes . NUMBER : raise ValueError ( \"`max_value` can only be supplied with int or float options\" ) if self . type == OptionTypes . INTEGER : if isinstance ( value , float ): raise ValueError ( \"`max_value` needs to be an int in an int option\" ) if self . max_value and self . min_value : if self . max_value < self . min_value : raise ValueError ( \"`min_value` needs to be <= than `max_value`\" )","title":"SlashCommandOption"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.SlashCommand","text":"Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class SlashCommand ( InteractionCommand ): name : str = attr . ib () description : str = attr . ib ( \"No Description Set\" ) group_name : str = attr . ib ( default = None , metadata = no_export_meta ) group_description : str = attr . ib ( default = \"No Description Set\" , metadata = no_export_meta ) sub_cmd_name : str = attr . ib ( default = None , metadata = no_export_meta ) sub_cmd_description : str = attr . ib ( default = \"No Description Set\" , metadata = no_export_meta ) options : List [ Union [ SlashCommandOption , Dict ]] = attr . ib ( factory = list ) autocomplete_callbacks : dict = attr . ib ( factory = dict , metadata = no_export_meta ) @property def resolved_name ( self ): return f \" { self . name }{ f ' { self . group_name } ' if self . group_name else '' }{ f ' { self . sub_cmd_name } ' if self . sub_cmd_name else '' } \" @property def is_subcommand ( self ) -> bool : return not self . sub_cmd_name is None def __attrs_post_init__ ( self ): params = get_parameters ( self . callback ) for name , val in params . items (): if val . annotation and isinstance ( val . annotation , SlashCommandOption ): if not self . options : self . options = [] val . annotation . name = name self . options . append ( val . annotation ) if self . callback is not None : if hasattr ( self . callback , \"options\" ): if not self . options : self . options = [] self . options += self . callback . options if hasattr ( self . callback , \"permissions\" ): self . permissions = self . callback . permissions super () . __attrs_post_init__ () def to_dict ( self ) -> dict : data = super () . to_dict () if self . is_subcommand : data [ \"name\" ] = self . sub_cmd_name data [ \"description\" ] = self . sub_cmd_description data . pop ( \"default_permission\" , None ) return data @name . validator @group_name . validator @sub_cmd_name . validator def name_validator ( self , attribute : str , value : str ) -> None : if value : if not re . match ( rf \"^[\\w-] {{ 1, { SLASH_CMD_NAME_LENGTH } }} $\" , value ) or value != value . lower (): raise ValueError ( f \"Slash Command names must be lower case and match this regex: ^[\\w-] { 1 , { SLASH_CMD_NAME_LENGTH } } $\" ) # noqa: W605 @description . validator @group_description . validator @sub_cmd_description . validator def description_validator ( self , attribute : str , value : str ) -> None : if not 1 <= len ( value ) <= SLASH_CMD_MAX_DESC_LENGTH : raise ValueError ( f \"Description must be between 1 and { SLASH_CMD_MAX_DESC_LENGTH } characters long\" ) @options . validator def options_validator ( self , attribute : str , value : List ) -> None : if value : if isinstance ( value , list ): if len ( value ) > SLASH_CMD_MAX_OPTIONS : raise ValueError ( f \"Slash commands can only hold { SLASH_CMD_MAX_OPTIONS } options\" ) if value != sorted ( value , key = lambda x : x . required if isinstance ( x , SlashCommandOption ) else x [ \"required\" ], reverse = True , ): raise ValueError ( \"Required options must go before optional options\" ) else : raise TypeError ( \"Options attribute must be either None or a list of options\" ) def autocomplete ( self , option_name : str ): \"\"\"A decorator to declare a coroutine as an option autocomplete\"\"\" def wrapper ( call : Callable [ ... , Coroutine ]): if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"autocomplete must be coroutine\" ) self . autocomplete_callbacks [ option_name ] = call # automatically set the option's autocomplete attribute to True for opt in self . options : if isinstance ( opt , dict ) and opt [ \"name\" ] == option_name : opt [ \"autocomplete\" ] = True elif isinstance ( opt , SlashCommandOption ) and opt . name == option_name : opt . autocomplete = True return call option_name = option_name . lower () return wrapper def subcommand ( self , sub_cmd_name : str , group_name : str = None , group_description : str = \"No Description Set\" , sub_cmd_description : str = \"No Description Set\" , options : List [ Union [ SlashCommandOption , Dict ]] = None , ) -> Callable [ ... , \"SlashCommand\" ]: def wrapper ( call : Callable [ ... , Coroutine ]) -> \"SlashCommand\" : if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Subcommand must be coroutine\" ) return SlashCommand ( name = self . name , description = self . description , group_name = group_name , group_description = group_description , sub_cmd_name = sub_cmd_name , sub_cmd_description = sub_cmd_description , options = options , callback = call , ) return wrapper","title":"SlashCommand"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.ComponentCommand","text":"Source code in dis_snek/models/application_commands.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class ComponentCommand ( InteractionCommand ): # right now this adds no extra functionality, but for future dev ive implemented it listeners : list [ str ] = attr . ib ( factory = list )","title":"ComponentCommand"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.slash_command","text":"A decorator to declare a coroutine as a slash command. Note While the base and group descriptions arent visible in the discord client, currently. We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in one of the future ui updates. Parameters: Name Type Description Default name str 1-32 character name of the command required description str 1-100 character description of the command 'No Description Set' scope The scope this command exists within required options Optional[List[Union[dis_snek.models.application_commands.SlashCommandOption, Dict]]] The parameters for the command, max 25 None default_permission bool Whether the command is enabled by default when the app is added to a guild True permissions Optional[Dict[Snowflake_Type, Union[dis_snek.models.application_commands.Permission, Dict]]] The roles or users who can use this command None sub_cmd_name str 1-32 character name of the subcommand None sub_cmd_description str 1-100 character description of the subcommand 'No Description Set' group_name str 1-32 character name of the group None group_description str 1-100 character description of the group 'No Description Set' Returns: Type Description SlashCommand Object Source code in dis_snek/models/application_commands.py def slash_command ( name : str , description : str = \"No Description Set\" , scopes : List [ \"Snowflake_Type\" ] = MISSING , options : Optional [ List [ Union [ SlashCommandOption , Dict ]]] = None , default_permission : bool = True , permissions : Optional [ Dict [ \"Snowflake_Type\" , Union [ Permission , Dict ]]] = None , sub_cmd_name : str = None , group_name : str = None , sub_cmd_description : str = \"No Description Set\" , group_description : str = \"No Description Set\" , ): \"\"\" A decorator to declare a coroutine as a slash command. note: While the base and group descriptions arent visible in the discord client, currently. We strongly advise defining them anyway, if you're using subcommands, as Discord has said they will be visible in one of the future ui updates. parameters: name: 1-32 character name of the command description: 1-100 character description of the command scope: The scope this command exists within options: The parameters for the command, max 25 default_permission: Whether the command is enabled by default when the app is added to a guild permissions: The roles or users who can use this command sub_cmd_name: 1-32 character name of the subcommand sub_cmd_description: 1-100 character description of the subcommand group_name: 1-32 character name of the group group_description: 1-100 character description of the group returns: SlashCommand Object \"\"\" def wrapper ( func ) -> SlashCommand : if not asyncio . iscoroutinefunction ( func ): raise ValueError ( \"Commands must be coroutines\" ) cmd = SlashCommand ( name = name , group_name = group_name , group_description = group_description , sub_cmd_name = sub_cmd_name , sub_cmd_description = sub_cmd_description , description = description , scopes = scopes if scopes else [ GLOBAL_SCOPE ], default_permission = default_permission , permissions = permissions or {}, callback = func , options = options , ) return cmd return wrapper","title":"slash_command()"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.context_menu","text":"A decorator to declare a coroutine as a Context Menu Parameters: Name Type Description Default name str 1-32 character name of the context menu required context_type CommandTypes The type of context menu required scope The scope this command exists within required default_permission bool Whether the menu is enabled by default when the app is added to a guild True permissions Optional[Dict[Snowflake_Type, Union[dis_snek.models.application_commands.Permission, Dict]]] The roles or users who can use this menu None Returns: Type Description ContextMenu object Source code in dis_snek/models/application_commands.py def context_menu ( name : str , context_type : \"CommandTypes\" , scopes : List [ \"Snowflake_Type\" ] = MISSING , default_permission : bool = True , permissions : Optional [ Dict [ \"Snowflake_Type\" , Union [ Permission , Dict ]]] = None , ): \"\"\" A decorator to declare a coroutine as a Context Menu parameters: name: 1-32 character name of the context menu context_type: The type of context menu scope: The scope this command exists within default_permission: Whether the menu is enabled by default when the app is added to a guild permissions: The roles or users who can use this menu returns: ContextMenu object \"\"\" def wrapper ( func ) -> ContextMenu : if not asyncio . iscoroutinefunction ( func ): raise ValueError ( \"Commands must be coroutines\" ) perm = permissions if hasattr ( func , \"permissions\" ): if perm : perm . update ( func . permissions ) else : perm = func . permissions cmd = ContextMenu ( name = name , type = context_type , scopes = scopes if scopes else [ GLOBAL_SCOPE ], default_permission = default_permission , permissions = perm , callback = func , ) return cmd return wrapper","title":"context_menu()"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.component_callback","text":"Register a coroutine as a component callback. Component callbacks work the same way as commands, just using components as a way of invoking, instead of messages. Your callback will be given a single argument, ComponentContext Parameters: Name Type Description Default custom_id str The custom ID of the component to wait for () Source code in dis_snek/models/application_commands.py def component_callback ( * custom_id : str ): \"\"\" Register a coroutine as a component callback. Component callbacks work the same way as commands, just using components as a way of invoking, instead of messages. Your callback will be given a single argument, `ComponentContext` Args: custom_id: The custom ID of the component to wait for \"\"\" def wrapper ( func ) -> ComponentCommand : if not asyncio . iscoroutinefunction ( func ): raise ValueError ( \"Commands must be coroutines\" ) return ComponentCommand ( name = f \"ComponentCallback:: { custom_id } \" , callback = func , listeners = custom_id ) # allows a mixture of generators and strings to be passed unpack = [] for c in custom_id : if inspect . isgenerator ( c ): unpack += list ( c ) else : unpack . append ( c ) custom_id = unpack return wrapper","title":"component_callback()"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.slash_option","text":"A decorator to add an option to a slash command. Parameters: Name Type Description Default name str 1-32 lowercase character name matching ^[\\w-]{1,32}$ required opt_type Union[dis_snek.models.application_commands.OptionTypes, int] The type of option required description str 1-100 character description of option required required bool If the parameter is required or optional--default false False choices List[Union[dis_snek.models.application_commands.SlashCommandChoice, dict]] A list of choices the user has to pick between (max 25) None channel_types Optional[list[Union[dis_snek.models.enums.ChannelTypes, int]]] The channel types permitted. The option needs to be a channel None min_value Optional[float] The minimum value permitted. The option needs to be an integer or float None max_value Optional[float] The maximum value permitted. The option needs to be an integer or float None Source code in dis_snek/models/application_commands.py def slash_option ( name : str , description : str , opt_type : Union [ OptionTypes , int ], required : bool = False , autocomplete : bool = False , choices : List [ Union [ SlashCommandChoice , dict ]] = None , channel_types : Optional [ list [ Union [ ChannelTypes , int ]]] = None , min_value : Optional [ float ] = None , max_value : Optional [ float ] = None , ) -> Any : \"\"\" A decorator to add an option to a slash command. parameters: name: 1-32 lowercase character name matching ^[\\w-]{1,32}$ opt_type: The type of option description: 1-100 character description of option required: If the parameter is required or optional--default false choices: A list of choices the user has to pick between (max 25) channel_types: The channel types permitted. The option needs to be a channel min_value: The minimum value permitted. The option needs to be an integer or float max_value: The maximum value permitted. The option needs to be an integer or float \"\"\" def wrapper ( func ): if hasattr ( func , \"cmd_id\" ): raise Exception ( \"slash_option decorators must be positioned under a slash_command decorator\" ) option = SlashCommandOption ( name = name , type = opt_type , description = description , required = required , autocomplete = autocomplete , choices = choices if choices else [], channel_types = channel_types , min_value = min_value , max_value = max_value , ) if not hasattr ( func , \"options\" ): func . options = [] func . options . insert ( 0 , option ) return func return wrapper","title":"slash_option()"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.slash_permission","text":"A decorator to add permissions for a guild to a slash command or context menu. Parameters: Name Type Description Default guild_id Snowflake_Type The target guild to apply the permissions. required permissions List[Union[dis_snek.models.application_commands.Permission, Dict]] A list of interaction permission rights. required Source code in dis_snek/models/application_commands.py def slash_permission ( guild_id : \"Snowflake_Type\" , permissions : List [ Union [ Permission , Dict ]]) -> Any : \"\"\" A decorator to add permissions for a guild to a slash command or context menu. parameters: guild_id: The target guild to apply the permissions. permissions: A list of interaction permission rights. \"\"\" guild_id = to_snowflake ( guild_id ) def wrapper ( func ): if hasattr ( func , \"cmd_id\" ): raise Exception ( \"slash_option decorators must be positioned under a slash_command decorator\" ) if not hasattr ( func , \"permissions\" ): func . permissions = {} if guild_id not in func . permissions : func . permissions [ guild_id ] = [] func . permissions [ guild_id ] += permissions return func return wrapper","title":"slash_permission()"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.application_commands_to_dict","text":"Convert the command list into a format that would be accepted by discord Snake.interactions should be the variable passed to this Source code in dis_snek/models/application_commands.py def application_commands_to_dict ( commands : Dict [ \"Snowflake_Type\" , Dict [ str , InteractionCommand ]]) -> dict : \"\"\"Convert the command list into a format that would be accepted by discord `Snake.interactions` should be the variable passed to this\"\"\" cmd_bases = {} # {cmd_base: [commands]} \"\"\"A store of commands organised by their base command\"\"\" output = {} \"\"\"The output dictionary\"\"\" def squash_subcommand ( subcommands : List ) -> Dict : output_data = {} groups = {} sub_cmds = [] for subcommand in subcommands : if not output_data : output_data = { \"name\" : subcommand . name , \"description\" : subcommand . description , \"options\" : [], \"permissions\" : subcommand . permissions , \"default_permission\" : subcommand . default_permission , } if subcommand . group_name : if subcommand . group_name not in groups : groups [ subcommand . group_name ] = { \"name\" : subcommand . group_name , \"description\" : subcommand . group_description , \"type\" : int ( OptionTypes . SUB_COMMAND_GROUP ), \"options\" : [], } groups [ subcommand . group_name ][ \"options\" ] . append ( subcommand . to_dict () | { \"type\" : int ( OptionTypes . SUB_COMMAND )} ) else : sub_cmds . append ( subcommand . to_dict () | { \"type\" : int ( OptionTypes . SUB_COMMAND )}) options = [ g for g in groups . values ()] + sub_cmds output_data [ \"options\" ] = options return output_data for scope , cmds in commands . items (): for cmd in cmds . values (): if cmd . name not in cmd_bases : cmd_bases [ cmd . name ] = [ cmd ] continue if cmd not in cmd_bases [ cmd . name ]: cmd_bases [ cmd . name ] . append ( cmd ) for cmd_list in cmd_bases . values (): if any ( c . is_subcommand for c in cmd_list ): # validate all commands share required attributes scopes : list [ Snowflake_Type ] = list ( set ( s for c in cmd_list for s in c . scopes )) permissions : dict = { k : v for c in cmd_list for k , v in c . permissions . items ()} base_description = next ( ( c . description for c in cmd_list if c . description is not None ), \"No Description Set\" ) if not all ( c . description in ( base_description , \"No Description Set\" ) for c in cmd_list ): log . warning ( f \"Conflicting descriptions found in ` { cmd_list [ 0 ] . name } ` subcommands; ` { base_description } ` will be used\" ) if not all ( c . default_permission == cmd_list [ 0 ] . default_permission for c in cmd_list ): raise ValueError ( f \"Conflicting `default_permission` values found in ` { cmd_list [ 0 ] . name } `\" ) for cmd in cmd_list : cmd . scopes = list ( scopes ) cmd . permissions = permissions cmd . description = base_description # end validation of attributes cmd_data = squash_subcommand ( cmd_list ) else : scopes = cmd_list [ 0 ] . scopes cmd_data = cmd_list [ 0 ] . to_dict () for s in scopes : if s not in output : output [ s ] = [ cmd_data ] continue output [ s ] . append ( cmd_data ) return output","title":"application_commands_to_dict()"},{"location":"API%20Reference/models/Internal%20Models/application%20commands/#dis_snek.models.application_commands.sync_needed","text":"Compares a local application command to its remote counterpart to determine if a sync is required. Parameters: Name Type Description Default local_cmd dict The local json representation of the command required remote_cmd Optional[dict] The json representation of the command from Discord None Returns: Type Description bool Boolean indicating if a sync is needed Source code in dis_snek/models/application_commands.py def sync_needed ( local_cmd : dict , remote_cmd : Optional [ dict ] = None ) -> bool : \"\"\" Compares a local application command to its remote counterpart to determine if a sync is required. Args: local_cmd: The local json representation of the command remote_cmd: The json representation of the command from Discord Returns: Boolean indicating if a sync is needed \"\"\" if not remote_cmd : # No remote version, command must be new return True if ( local_cmd [ \"name\" ] != remote_cmd [ \"name\" ] or local_cmd . get ( \"description\" , \"\" ) != remote_cmd . get ( \"description\" , \"\" ) or local_cmd [ \"default_permission\" ] != remote_cmd [ \"default_permission\" ] ): # basic comparison of attributes return True if remote_cmd [ \"type\" ] == CommandTypes . CHAT_INPUT : try : if not _compare_options ( local_cmd [ \"options\" ], remote_cmd [ \"options\" ]): # options are not the same, sync needed return True except KeyError : if \"options\" in local_cmd or \"options\" in remote_cmd : return True return False","title":"sync_needed()"},{"location":"API%20Reference/models/Internal%20Models/checks/","text":"has_role ( role ) \u00b6 Check if the user has the given role Parameters: Name Type Description Default role Union[str, int, dis_snek.models.discord_objects.role.Role] The Role or role id to check for required Source code in dis_snek/models/checks.py def has_role ( role : Union [ Snowflake_Type , Role ]): \"\"\" Check if the user has the given role Args: role: The Role or role id to check for \"\"\" async def check ( ctx : Context ) -> bool : if ctx . guild is None : return False return await ctx . author . has_role ( role ) return check has_any_role ( * roles ) \u00b6 Checks if the user has any of the given roles Parameters: Name Type Description Default *roles Union[str, int, dis_snek.models.discord_objects.role.Role] The Role(s) or role id(s) to check for () Source code in dis_snek/models/checks.py def has_any_role ( * roles : Union [ Snowflake_Type , Role ]): \"\"\" Checks if the user has any of the given roles Args: *roles: The Role(s) or role id(s) to check for \"\"\" async def check ( ctx : Context ) -> bool : if ctx . guild is None : return False if any ( ctx . author . has_role ( to_snowflake ( r )) for r in roles ): return True return False has_id ( user_id ) \u00b6 Checks if the author has the desired ID. Parameters: Name Type Description Default coro the function to check required Source code in dis_snek/models/checks.py def has_id ( user_id ): \"\"\" Checks if the author has the desired ID. parameters: coro: the function to check \"\"\" async def check ( ctx : Context ) -> bool : return ctx . author . id == user_id return check is_owner () \u00b6 Is the author the owner of the bot. Note this does not account for teams Parameters: Name Type Description Default coro the function to check required Source code in dis_snek/models/checks.py def is_owner (): \"\"\" Is the author the owner of the bot. !!! note this does not account for teams parameters: coro: the function to check \"\"\" async def check ( ctx : Context ) -> bool : return ctx . author . id == ctx . bot . owner return check guild_only () \u00b6 This command may only be ran in a guild Source code in dis_snek/models/checks.py def guild_only (): \"\"\" This command may only be ran in a guild \"\"\" async def check ( ctx : Context ) -> bool : return ctx . guild is not None return check dm_only () \u00b6 This command may only be ran in a dm Source code in dis_snek/models/checks.py def dm_only (): \"\"\" This command may only be ran in a dm \"\"\" async def check ( ctx : Context ) -> bool : return ctx . guild is None return check","title":"Checks"},{"location":"API%20Reference/models/Internal%20Models/checks/#dis_snek.models.checks.has_role","text":"Check if the user has the given role Parameters: Name Type Description Default role Union[str, int, dis_snek.models.discord_objects.role.Role] The Role or role id to check for required Source code in dis_snek/models/checks.py def has_role ( role : Union [ Snowflake_Type , Role ]): \"\"\" Check if the user has the given role Args: role: The Role or role id to check for \"\"\" async def check ( ctx : Context ) -> bool : if ctx . guild is None : return False return await ctx . author . has_role ( role ) return check","title":"has_role()"},{"location":"API%20Reference/models/Internal%20Models/checks/#dis_snek.models.checks.has_any_role","text":"Checks if the user has any of the given roles Parameters: Name Type Description Default *roles Union[str, int, dis_snek.models.discord_objects.role.Role] The Role(s) or role id(s) to check for () Source code in dis_snek/models/checks.py def has_any_role ( * roles : Union [ Snowflake_Type , Role ]): \"\"\" Checks if the user has any of the given roles Args: *roles: The Role(s) or role id(s) to check for \"\"\" async def check ( ctx : Context ) -> bool : if ctx . guild is None : return False if any ( ctx . author . has_role ( to_snowflake ( r )) for r in roles ): return True return False","title":"has_any_role()"},{"location":"API%20Reference/models/Internal%20Models/checks/#dis_snek.models.checks.has_id","text":"Checks if the author has the desired ID. Parameters: Name Type Description Default coro the function to check required Source code in dis_snek/models/checks.py def has_id ( user_id ): \"\"\" Checks if the author has the desired ID. parameters: coro: the function to check \"\"\" async def check ( ctx : Context ) -> bool : return ctx . author . id == user_id return check","title":"has_id()"},{"location":"API%20Reference/models/Internal%20Models/checks/#dis_snek.models.checks.is_owner","text":"Is the author the owner of the bot. Note this does not account for teams Parameters: Name Type Description Default coro the function to check required Source code in dis_snek/models/checks.py def is_owner (): \"\"\" Is the author the owner of the bot. !!! note this does not account for teams parameters: coro: the function to check \"\"\" async def check ( ctx : Context ) -> bool : return ctx . author . id == ctx . bot . owner return check","title":"is_owner()"},{"location":"API%20Reference/models/Internal%20Models/checks/#dis_snek.models.checks.guild_only","text":"This command may only be ran in a guild Source code in dis_snek/models/checks.py def guild_only (): \"\"\" This command may only be ran in a guild \"\"\" async def check ( ctx : Context ) -> bool : return ctx . guild is not None return check","title":"guild_only()"},{"location":"API%20Reference/models/Internal%20Models/checks/#dis_snek.models.checks.dm_only","text":"This command may only be ran in a dm Source code in dis_snek/models/checks.py def dm_only (): \"\"\" This command may only be ran in a dm \"\"\" async def check ( ctx : Context ) -> bool : return ctx . guild is None return check","title":"dm_only()"},{"location":"API%20Reference/models/Internal%20Models/color/","text":"Colour spelled incorrectly. Represent colours that can be used with discord. BrandColors ( Color , Enum ) \u00b6 A collection of colors complying to the Discord Brand specification https://discord.com/branding Source code in dis_snek/models/color.py class BrandColors ( Color , Enum ): \"\"\" A collection of colors complying to the Discord Brand specification https://discord.com/branding \"\"\" BLURPLE = \"#5865F2\" GREEN = \"#57F287\" YELLOW = \"#FEE75C\" FUCHSIA = \"#EB459E\" RED = \"#ED4245\" WHITE = \"#FFFFFF\" BLACK = \"#000000\" BrandColours ( Color , Enum ) \u00b6 A collection of colors complying to the Discord Brand specification https://discord.com/branding Source code in dis_snek/models/color.py class BrandColors ( Color , Enum ): \"\"\" A collection of colors complying to the Discord Brand specification https://discord.com/branding \"\"\" BLURPLE = \"#5865F2\" GREEN = \"#57F287\" YELLOW = \"#FEE75C\" FUCHSIA = \"#EB459E\" RED = \"#ED4245\" WHITE = \"#FFFFFF\" BLACK = \"#000000\" MaterialColors ( Color , Enum ) \u00b6 A collection of material ui colors. https://www.materialpalette.com/ Source code in dis_snek/models/color.py class MaterialColors ( Color , Enum ): \"\"\" A collection of material ui colors. https://www.materialpalette.com/ \"\"\" RED = \"#F44336\" PINK = \"#E91E63\" LAVENDER = \"#EDB9F5\" PURPLE = \"#9C27B0\" DEEP_PURPLE = \"#673AB7\" INDIGO = \"#3F51B5\" BLUE = \"#2196F3\" LIGHT_BLUE = \"#03A9F4\" CYAN = \"#00BCD4\" TEAL = \"#009688\" GREEN = \"#4CAF50\" LIGHT_GREEN = \"#8BC34A\" LIME = \"#CDDC39\" YELLOW = \"#FFEB3B\" AMBER = \"#FFC107\" ORANGE = \"#FF9800\" DEEP_ORANGE = \"#FF5722\" BROWN = \"#795548\" GREY = \"#9E9E9E\" BLUE_GREY = \"#607D8B\" MaterialColours ( Color , Enum ) \u00b6 A collection of material ui colors. https://www.materialpalette.com/ Source code in dis_snek/models/color.py class MaterialColors ( Color , Enum ): \"\"\" A collection of material ui colors. https://www.materialpalette.com/ \"\"\" RED = \"#F44336\" PINK = \"#E91E63\" LAVENDER = \"#EDB9F5\" PURPLE = \"#9C27B0\" DEEP_PURPLE = \"#673AB7\" INDIGO = \"#3F51B5\" BLUE = \"#2196F3\" LIGHT_BLUE = \"#03A9F4\" CYAN = \"#00BCD4\" TEAL = \"#009688\" GREEN = \"#4CAF50\" LIGHT_GREEN = \"#8BC34A\" LIME = \"#CDDC39\" YELLOW = \"#FFEB3B\" AMBER = \"#FFC107\" ORANGE = \"#FF9800\" DEEP_ORANGE = \"#FF5722\" BROWN = \"#795548\" GREY = \"#9E9E9E\" BLUE_GREY = \"#607D8B\" FlatUIColors ( Color , Enum ) \u00b6 A collection of flat ui colours. https://materialui.co/flatuicolors Source code in dis_snek/models/color.py class FlatUIColors ( Color , Enum ): \"\"\" A collection of flat ui colours. https://materialui.co/flatuicolors \"\"\" TURQUOISE = \"#1ABC9C\" EMERLAND = \"#2ECC71\" PETERRIVER = \"#3498DB\" AMETHYST = \"#9B59B6\" WETASPHALT = \"#34495E\" GREENSEA = \"#16A085\" NEPHRITIS = \"#27AE60\" BELIZEHOLE = \"#2980B9\" WISTERIA = \"#8E44AD\" MIDNIGHTBLUE = \"#2C3E50\" SUNFLOWER = \"#F1C40F\" CARROT = \"#E67E22\" ALIZARIN = \"#E74C3C\" CLOUDS = \"#ECF0F1\" CONCRETE = \"#95A5A6\" ORANGE = \"#F39C12\" PUMPKIN = \"#D35400\" POMEGRANATE = \"#C0392B\" SILVER = \"#BDC3C7\" ASBESTOS = \"#7F8C8D\" FlatUIColours ( Color , Enum ) \u00b6 A collection of flat ui colours. https://materialui.co/flatuicolors Source code in dis_snek/models/color.py class FlatUIColors ( Color , Enum ): \"\"\" A collection of flat ui colours. https://materialui.co/flatuicolors \"\"\" TURQUOISE = \"#1ABC9C\" EMERLAND = \"#2ECC71\" PETERRIVER = \"#3498DB\" AMETHYST = \"#9B59B6\" WETASPHALT = \"#34495E\" GREENSEA = \"#16A085\" NEPHRITIS = \"#27AE60\" BELIZEHOLE = \"#2980B9\" WISTERIA = \"#8E44AD\" MIDNIGHTBLUE = \"#2C3E50\" SUNFLOWER = \"#F1C40F\" CARROT = \"#E67E22\" ALIZARIN = \"#E74C3C\" CLOUDS = \"#ECF0F1\" CONCRETE = \"#95A5A6\" ORANGE = \"#F39C12\" PUMPKIN = \"#D35400\" POMEGRANATE = \"#C0392B\" SILVER = \"#BDC3C7\" ASBESTOS = \"#7F8C8D\"","title":"Color"},{"location":"API%20Reference/models/Internal%20Models/color/#dis_snek.models.color.BrandColors","text":"A collection of colors complying to the Discord Brand specification https://discord.com/branding Source code in dis_snek/models/color.py class BrandColors ( Color , Enum ): \"\"\" A collection of colors complying to the Discord Brand specification https://discord.com/branding \"\"\" BLURPLE = \"#5865F2\" GREEN = \"#57F287\" YELLOW = \"#FEE75C\" FUCHSIA = \"#EB459E\" RED = \"#ED4245\" WHITE = \"#FFFFFF\" BLACK = \"#000000\"","title":"BrandColors"},{"location":"API%20Reference/models/Internal%20Models/color/#dis_snek.models.color.BrandColours","text":"A collection of colors complying to the Discord Brand specification https://discord.com/branding Source code in dis_snek/models/color.py class BrandColors ( Color , Enum ): \"\"\" A collection of colors complying to the Discord Brand specification https://discord.com/branding \"\"\" BLURPLE = \"#5865F2\" GREEN = \"#57F287\" YELLOW = \"#FEE75C\" FUCHSIA = \"#EB459E\" RED = \"#ED4245\" WHITE = \"#FFFFFF\" BLACK = \"#000000\"","title":"BrandColours"},{"location":"API%20Reference/models/Internal%20Models/color/#dis_snek.models.color.MaterialColors","text":"A collection of material ui colors. https://www.materialpalette.com/ Source code in dis_snek/models/color.py class MaterialColors ( Color , Enum ): \"\"\" A collection of material ui colors. https://www.materialpalette.com/ \"\"\" RED = \"#F44336\" PINK = \"#E91E63\" LAVENDER = \"#EDB9F5\" PURPLE = \"#9C27B0\" DEEP_PURPLE = \"#673AB7\" INDIGO = \"#3F51B5\" BLUE = \"#2196F3\" LIGHT_BLUE = \"#03A9F4\" CYAN = \"#00BCD4\" TEAL = \"#009688\" GREEN = \"#4CAF50\" LIGHT_GREEN = \"#8BC34A\" LIME = \"#CDDC39\" YELLOW = \"#FFEB3B\" AMBER = \"#FFC107\" ORANGE = \"#FF9800\" DEEP_ORANGE = \"#FF5722\" BROWN = \"#795548\" GREY = \"#9E9E9E\" BLUE_GREY = \"#607D8B\"","title":"MaterialColors"},{"location":"API%20Reference/models/Internal%20Models/color/#dis_snek.models.color.MaterialColours","text":"A collection of material ui colors. https://www.materialpalette.com/ Source code in dis_snek/models/color.py class MaterialColors ( Color , Enum ): \"\"\" A collection of material ui colors. https://www.materialpalette.com/ \"\"\" RED = \"#F44336\" PINK = \"#E91E63\" LAVENDER = \"#EDB9F5\" PURPLE = \"#9C27B0\" DEEP_PURPLE = \"#673AB7\" INDIGO = \"#3F51B5\" BLUE = \"#2196F3\" LIGHT_BLUE = \"#03A9F4\" CYAN = \"#00BCD4\" TEAL = \"#009688\" GREEN = \"#4CAF50\" LIGHT_GREEN = \"#8BC34A\" LIME = \"#CDDC39\" YELLOW = \"#FFEB3B\" AMBER = \"#FFC107\" ORANGE = \"#FF9800\" DEEP_ORANGE = \"#FF5722\" BROWN = \"#795548\" GREY = \"#9E9E9E\" BLUE_GREY = \"#607D8B\"","title":"MaterialColours"},{"location":"API%20Reference/models/Internal%20Models/color/#dis_snek.models.color.FlatUIColors","text":"A collection of flat ui colours. https://materialui.co/flatuicolors Source code in dis_snek/models/color.py class FlatUIColors ( Color , Enum ): \"\"\" A collection of flat ui colours. https://materialui.co/flatuicolors \"\"\" TURQUOISE = \"#1ABC9C\" EMERLAND = \"#2ECC71\" PETERRIVER = \"#3498DB\" AMETHYST = \"#9B59B6\" WETASPHALT = \"#34495E\" GREENSEA = \"#16A085\" NEPHRITIS = \"#27AE60\" BELIZEHOLE = \"#2980B9\" WISTERIA = \"#8E44AD\" MIDNIGHTBLUE = \"#2C3E50\" SUNFLOWER = \"#F1C40F\" CARROT = \"#E67E22\" ALIZARIN = \"#E74C3C\" CLOUDS = \"#ECF0F1\" CONCRETE = \"#95A5A6\" ORANGE = \"#F39C12\" PUMPKIN = \"#D35400\" POMEGRANATE = \"#C0392B\" SILVER = \"#BDC3C7\" ASBESTOS = \"#7F8C8D\"","title":"FlatUIColors"},{"location":"API%20Reference/models/Internal%20Models/color/#dis_snek.models.color.FlatUIColours","text":"A collection of flat ui colours. https://materialui.co/flatuicolors Source code in dis_snek/models/color.py class FlatUIColors ( Color , Enum ): \"\"\" A collection of flat ui colours. https://materialui.co/flatuicolors \"\"\" TURQUOISE = \"#1ABC9C\" EMERLAND = \"#2ECC71\" PETERRIVER = \"#3498DB\" AMETHYST = \"#9B59B6\" WETASPHALT = \"#34495E\" GREENSEA = \"#16A085\" NEPHRITIS = \"#27AE60\" BELIZEHOLE = \"#2980B9\" WISTERIA = \"#8E44AD\" MIDNIGHTBLUE = \"#2C3E50\" SUNFLOWER = \"#F1C40F\" CARROT = \"#E67E22\" ALIZARIN = \"#E74C3C\" CLOUDS = \"#ECF0F1\" CONCRETE = \"#95A5A6\" ORANGE = \"#F39C12\" PUMPKIN = \"#D35400\" POMEGRANATE = \"#C0392B\" SILVER = \"#BDC3C7\" ASBESTOS = \"#7F8C8D\"","title":"FlatUIColours"},{"location":"API%20Reference/models/Internal%20Models/command/","text":"BaseCommand ( DictSerializationMixin ) attrs \u00b6 An object all commands inherit from. Outlines the basic structure of a command, and handles checks. Attributes: Name Type Description scale Any The scale this command belongs to. enabled bool Whether this command is enabled checks list Any checks that must be run before this command can be run callback Callable[..., Coroutine] The coroutine to be called for this command error_callback Callable[..., Coroutine] The coroutine to be called when an error occurs pre_run_callback Callable[..., Coroutine] A coroutine to be called before this command is run but after the checks post_run_callback Callable[..., Coroutine] A coroutine to be called after this command has run Source code in dis_snek/models/command.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class BaseCommand ( DictSerializationMixin ): \"\"\" An object all commands inherit from. Outlines the basic structure of a command, and handles checks. attributes: scale: The scale this command belongs to. enabled: Whether this command is enabled checks: Any checks that must be run before this command can be run callback: The coroutine to be called for this command error_callback: The coroutine to be called when an error occurs pre_run_callback: A coroutine to be called before this command is run **but** after the checks post_run_callback: A coroutine to be called after this command has run \"\"\" scale : Any = attr . ib ( default = None , metadata = docs ( \"The scale this command belongs to\" ) | no_export_meta ) enabled : bool = attr . ib ( default = True , metadata = docs ( \"Whether this can be run at all\" ) | no_export_meta ) checks : list = attr . ib ( factory = list , metadata = docs ( \"Any checks that must be *checked* before the command can run\" )) cooldown : Cooldown = attr . ib ( default = MISSING , metadata = docs ( \"An optional cooldown to apply to the command\" )) max_concurrency : MaxConcurrency = attr . ib ( default = MISSING , metadata = docs ( \"An optional maximum number of concurrent instances to apply to the command\" ) ) callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = docs ( \"The coroutine to be called for this command\" ) | no_export_meta ) error_callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = no_export_meta | docs ( \"The coroutine to be called when an error occurs\" ) ) pre_run_callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = no_export_meta | docs ( \"The coroutine to be called before the command is executed, **but** after the checks\" ), ) post_run_callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = no_export_meta | docs ( \"The coroutine to be called after the command has executed\" ) ) def __attrs_post_init__ ( self ): if self . callback is not None : if hasattr ( self . callback , \"checks\" ): self . checks += self . callback . checks if hasattr ( self . callback , \"cooldown\" ): self . cooldown = self . callback . cooldown if hasattr ( self . callback , \"max_concurrency\" ): self . max_concurrency = self . callback . max_concurrency async def __call__ ( self , context , * args , ** kwargs ): \"\"\" Calls this command. parameters: context: The context of this command args: Any kwargs: Any \"\"\" try : if await self . _can_run ( context ): if self . pre_run_callback is not None : await self . pre_run_callback ( context , * args , ** kwargs ) if self . scale is not None and self . scale . scale_prerun : await self . scale . scale_prerun ( context , * args , ** kwargs ) await self . call_callback ( self . callback , context ) if self . post_run_callback is not None : await self . post_run_callback ( context , * args , ** kwargs ) if self . scale is not None and self . scale . scale_postrun : await self . scale . scale_postrun ( context , * args , ** kwargs ) except Exception as e : if self . error_callback : await self . error_callback ( e , context , * args , ** kwargs ) else : raise finally : if self . max_concurrency is not MISSING : await self . max_concurrency . release ( context ) async def call_callback ( self , callback : Callable , context : \"Context\" ): callback = functools . partial ( callback , context ) # first param must be ctx parameters = get_parameters ( callback ) args = [] kwargs = {} if len ( parameters ) == 0 : # if no params, user only wants context return await callback () c_args = copy . copy ( context . args ) for param in parameters . values (): if config := getattr ( param . annotation , \"_annotation_dat\" , None ): # if user has used an snek-annotation, run the annotation, and pass the result to the user local = { \"context\" : context , \"scale\" : self . scale } ano_args = [ local [ c ] for c in config [ \"args\" ]] if param . kind != param . POSITIONAL_ONLY : kwargs [ param . name ] = param . annotation ( * ano_args ) else : args . append ( param . annotation ( * ano_args )) continue elif param . name in context . kwargs : # if parameter is in kwargs, user obviously wants it, pass it if param . kind != param . POSITIONAL_ONLY : kwargs [ param . name ] = context . kwargs [ param . name ] else : args . append ( context . kwargs [ param . name ]) if context . kwargs [ param . name ] in c_args : c_args . remove ( context . kwargs [ param . name ]) elif param . default is not param . empty : kwargs [ param . name ] = param . default else : if not str ( param ) . startswith ( \"*\" ): if param . kind != param . KEYWORD_ONLY : try : args . append ( c_args . pop ( 0 )) except IndexError : raise ValueError ( f \" { context . invoked_name } expects { len ([ p for p in parameters . values () if p . default is p . empty ]) + len ( callback . args ) } \" f \" arguments but received { len ( context . args ) } instead\" ) from None else : raise ValueError ( f \"Unable to resolve argument: { param . name } \" ) if any ( kwargs_reg . match ( str ( param )) for param in parameters . values ()): # if user has `**kwargs` pass all remaining kwargs kwargs = kwargs | { k : v for k , v in context . kwargs . items () if k not in kwargs } if any ( args_reg . match ( str ( param )) for param in parameters . values ()): # user has `*args` pass all remaining args args = args + c_args return await callback ( * args , ** kwargs ) async def _can_run ( self , context ): \"\"\" Determines if this command can be run. parameters: context: The context of the command \"\"\" max_conc_acquired = False # signals if a semaphore has been acquired, for exception handling try : if not self . enabled : return False for _c in self . checks : if not await _c ( context ): raise CommandCheckFailure ( self , _c , context ) if self . scale and self . scale . scale_checks : for _c in self . scale . scale_checks : if not await _c ( context ): raise CommandCheckFailure ( self , _c , context ) if self . max_concurrency is not MISSING : if not await self . max_concurrency . acquire ( context ): raise MaxConcurrencyReached ( self , self . max_concurrency ) if self . cooldown is not MISSING : if not await self . cooldown . acquire_token ( context ): raise CommandOnCooldown ( self , await self . cooldown . get_cooldown ( context )) return True except Exception : if max_conc_acquired : await self . max_concurrency . release ( context ) raise def error ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Error handler must be coroutine\" ) self . error_callback = call return call def pre_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run before the command\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"pre_run must be coroutine\" ) self . pre_run_callback = call return call def post_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run after the command has\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"post_run must be coroutine\" ) self . post_run_callback = call return call attrs-field kw_only callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called for this command attrs-field kw_only checks : list \u00b6 Any checks that must be checked before the command can run attrs-field kw_only cooldown : Cooldown \u00b6 An optional cooldown to apply to the command attrs-field kw_only enabled : bool \u00b6 Whether this can be run at all attrs-field kw_only error_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called when an error occurs attrs-field kw_only max_concurrency : MaxConcurrency \u00b6 An optional maximum number of concurrent instances to apply to the command attrs-field kw_only post_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called after the command has executed attrs-field kw_only pre_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called before the command is executed, but after the checks attrs-field kw_only scale : Any \u00b6 The scale this command belongs to inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/command.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/command.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) error ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run upon an error. Source code in dis_snek/models/command.py def error ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Error handler must be coroutine\" ) self . error_callback = call return call pre_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run before the command Source code in dis_snek/models/command.py def pre_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run before the command\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"pre_run must be coroutine\" ) self . pre_run_callback = call return call post_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run after the command has Source code in dis_snek/models/command.py def post_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run after the command has\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"post_run must be coroutine\" ) self . post_run_callback = call return call MessageCommand ( BaseCommand ) attrs \u00b6 Represents a command triggered by standard message. Source code in dis_snek/models/command.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class MessageCommand ( BaseCommand ): \"\"\" Represents a command triggered by standard message. \"\"\" name : str = attr . ib ( metadata = docs ( \"The name of the command\" )) attrs-field inherited kw_only callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called for this command attrs-field inherited kw_only checks : list \u00b6 Any checks that must be checked before the command can run attrs-field inherited kw_only cooldown : Cooldown \u00b6 An optional cooldown to apply to the command attrs-field inherited kw_only enabled : bool \u00b6 Whether this can be run at all attrs-field inherited kw_only error_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called when an error occurs attrs-field inherited kw_only max_concurrency : MaxConcurrency \u00b6 An optional maximum number of concurrent instances to apply to the command attrs-field kw_only name : str \u00b6 The name of the command attrs-field inherited kw_only post_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called after the command has executed attrs-field inherited kw_only pre_run_callback : Callable [ ... , Coroutine ] \u00b6 The coroutine to be called before the command is executed, but after the checks attrs-field inherited kw_only scale : Any \u00b6 The scale this command belongs to inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/command.py def update_from_dict ( self , data ): \"\"\" Updates object attribute(s) with new json data received from discord api. \"\"\" data = self . _process_dict ( data ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) return self inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/command.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) inherited error ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run upon an error. Source code in dis_snek/models/command.py def error ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Error handler must be coroutine\" ) self . error_callback = call return call inherited pre_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run before the command Source code in dis_snek/models/command.py def pre_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run before the command\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"pre_run must be coroutine\" ) self . pre_run_callback = call return call inherited post_run ( self , call ) \u00b6 A decorator to declare a coroutine as one that will be run after the command has Source code in dis_snek/models/command.py def post_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run after the command has\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"post_run must be coroutine\" ) self . post_run_callback = call return call message_command ( name = None ) \u00b6 A decorator to declare a coroutine as a message command. Parameters: Name Type Description Default name str The name of the command, defaults to the name of the coroutine None Returns: Type Description Message Command Object Source code in dis_snek/models/command.py def message_command ( name : str = None , ): \"\"\" A decorator to declare a coroutine as a message command. parameters: name: The name of the command, defaults to the name of the coroutine returns: Message Command Object \"\"\" def wrapper ( func ): if not asyncio . iscoroutinefunction ( func ): raise ValueError ( \"Commands must be coroutines\" ) cmd = MessageCommand ( name = name or func . __name__ , callback = func ) return cmd return wrapper check ( check ) \u00b6 Add a check to a command. Parameters: Name Type Description Default check Callable[..., Coroutine] A coroutine as a check for this command required Source code in dis_snek/models/command.py def check ( check : Callable [ ... , Coroutine ]): \"\"\" Add a check to a command. parameters: check: A coroutine as a check for this command \"\"\" def wrapper ( coro ): if isinstance ( coro , BaseCommand ): coro . checks . append ( check ) return if not hasattr ( coro , \"checks\" ): coro . checks = [] coro . checks . append ( check ) return coro return wrapper cooldown ( bucket , rate , interval ) \u00b6 Add a cooldown to a command Parameters: Name Type Description Default bucket Buckets The bucket used to track cooldowns required rate int How many commands may be ran per interval required interval float How many seconds to wait for a cooldown required Source code in dis_snek/models/command.py def cooldown ( bucket : Buckets , rate : int , interval : float ): \"\"\" Add a cooldown to a command Args: bucket: The bucket used to track cooldowns rate: How many commands may be ran per interval interval: How many seconds to wait for a cooldown \"\"\" def wrapper ( coro : Callable [ ... , Coroutine ]): cooldown_obj = Cooldown ( bucket , rate , interval ) coro . cooldown = cooldown_obj return coro return wrapper max_concurrency ( bucket , concurrent ) \u00b6 Add a maximum number of concurrent instances to the command. Parameters: Name Type Description Default bucket Buckets The bucket to enforce the maximum within required concurrent int The maximum number of concurrent instances to allow required Source code in dis_snek/models/command.py def max_concurrency ( bucket : Buckets , concurrent : int ): \"\"\" Add a maximum number of concurrent instances to the command. Args: bucket: The bucket to enforce the maximum within concurrent: The maximum number of concurrent instances to allow \"\"\" def wrapper ( coro : Callable [ ... , Coroutine ]): max_conc = MaxConcurrency ( concurrent , bucket ) coro . max_concurrency = max_conc return coro return wrapper","title":"Command"},{"location":"API%20Reference/models/Internal%20Models/command/#dis_snek.models.command.BaseCommand","text":"An object all commands inherit from. Outlines the basic structure of a command, and handles checks. Attributes: Name Type Description scale Any The scale this command belongs to. enabled bool Whether this command is enabled checks list Any checks that must be run before this command can be run callback Callable[..., Coroutine] The coroutine to be called for this command error_callback Callable[..., Coroutine] The coroutine to be called when an error occurs pre_run_callback Callable[..., Coroutine] A coroutine to be called before this command is run but after the checks post_run_callback Callable[..., Coroutine] A coroutine to be called after this command has run Source code in dis_snek/models/command.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class BaseCommand ( DictSerializationMixin ): \"\"\" An object all commands inherit from. Outlines the basic structure of a command, and handles checks. attributes: scale: The scale this command belongs to. enabled: Whether this command is enabled checks: Any checks that must be run before this command can be run callback: The coroutine to be called for this command error_callback: The coroutine to be called when an error occurs pre_run_callback: A coroutine to be called before this command is run **but** after the checks post_run_callback: A coroutine to be called after this command has run \"\"\" scale : Any = attr . ib ( default = None , metadata = docs ( \"The scale this command belongs to\" ) | no_export_meta ) enabled : bool = attr . ib ( default = True , metadata = docs ( \"Whether this can be run at all\" ) | no_export_meta ) checks : list = attr . ib ( factory = list , metadata = docs ( \"Any checks that must be *checked* before the command can run\" )) cooldown : Cooldown = attr . ib ( default = MISSING , metadata = docs ( \"An optional cooldown to apply to the command\" )) max_concurrency : MaxConcurrency = attr . ib ( default = MISSING , metadata = docs ( \"An optional maximum number of concurrent instances to apply to the command\" ) ) callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = docs ( \"The coroutine to be called for this command\" ) | no_export_meta ) error_callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = no_export_meta | docs ( \"The coroutine to be called when an error occurs\" ) ) pre_run_callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = no_export_meta | docs ( \"The coroutine to be called before the command is executed, **but** after the checks\" ), ) post_run_callback : Callable [ ... , Coroutine ] = attr . ib ( default = None , metadata = no_export_meta | docs ( \"The coroutine to be called after the command has executed\" ) ) def __attrs_post_init__ ( self ): if self . callback is not None : if hasattr ( self . callback , \"checks\" ): self . checks += self . callback . checks if hasattr ( self . callback , \"cooldown\" ): self . cooldown = self . callback . cooldown if hasattr ( self . callback , \"max_concurrency\" ): self . max_concurrency = self . callback . max_concurrency async def __call__ ( self , context , * args , ** kwargs ): \"\"\" Calls this command. parameters: context: The context of this command args: Any kwargs: Any \"\"\" try : if await self . _can_run ( context ): if self . pre_run_callback is not None : await self . pre_run_callback ( context , * args , ** kwargs ) if self . scale is not None and self . scale . scale_prerun : await self . scale . scale_prerun ( context , * args , ** kwargs ) await self . call_callback ( self . callback , context ) if self . post_run_callback is not None : await self . post_run_callback ( context , * args , ** kwargs ) if self . scale is not None and self . scale . scale_postrun : await self . scale . scale_postrun ( context , * args , ** kwargs ) except Exception as e : if self . error_callback : await self . error_callback ( e , context , * args , ** kwargs ) else : raise finally : if self . max_concurrency is not MISSING : await self . max_concurrency . release ( context ) async def call_callback ( self , callback : Callable , context : \"Context\" ): callback = functools . partial ( callback , context ) # first param must be ctx parameters = get_parameters ( callback ) args = [] kwargs = {} if len ( parameters ) == 0 : # if no params, user only wants context return await callback () c_args = copy . copy ( context . args ) for param in parameters . values (): if config := getattr ( param . annotation , \"_annotation_dat\" , None ): # if user has used an snek-annotation, run the annotation, and pass the result to the user local = { \"context\" : context , \"scale\" : self . scale } ano_args = [ local [ c ] for c in config [ \"args\" ]] if param . kind != param . POSITIONAL_ONLY : kwargs [ param . name ] = param . annotation ( * ano_args ) else : args . append ( param . annotation ( * ano_args )) continue elif param . name in context . kwargs : # if parameter is in kwargs, user obviously wants it, pass it if param . kind != param . POSITIONAL_ONLY : kwargs [ param . name ] = context . kwargs [ param . name ] else : args . append ( context . kwargs [ param . name ]) if context . kwargs [ param . name ] in c_args : c_args . remove ( context . kwargs [ param . name ]) elif param . default is not param . empty : kwargs [ param . name ] = param . default else : if not str ( param ) . startswith ( \"*\" ): if param . kind != param . KEYWORD_ONLY : try : args . append ( c_args . pop ( 0 )) except IndexError : raise ValueError ( f \" { context . invoked_name } expects { len ([ p for p in parameters . values () if p . default is p . empty ]) + len ( callback . args ) } \" f \" arguments but received { len ( context . args ) } instead\" ) from None else : raise ValueError ( f \"Unable to resolve argument: { param . name } \" ) if any ( kwargs_reg . match ( str ( param )) for param in parameters . values ()): # if user has `**kwargs` pass all remaining kwargs kwargs = kwargs | { k : v for k , v in context . kwargs . items () if k not in kwargs } if any ( args_reg . match ( str ( param )) for param in parameters . values ()): # user has `*args` pass all remaining args args = args + c_args return await callback ( * args , ** kwargs ) async def _can_run ( self , context ): \"\"\" Determines if this command can be run. parameters: context: The context of the command \"\"\" max_conc_acquired = False # signals if a semaphore has been acquired, for exception handling try : if not self . enabled : return False for _c in self . checks : if not await _c ( context ): raise CommandCheckFailure ( self , _c , context ) if self . scale and self . scale . scale_checks : for _c in self . scale . scale_checks : if not await _c ( context ): raise CommandCheckFailure ( self , _c , context ) if self . max_concurrency is not MISSING : if not await self . max_concurrency . acquire ( context ): raise MaxConcurrencyReached ( self , self . max_concurrency ) if self . cooldown is not MISSING : if not await self . cooldown . acquire_token ( context ): raise CommandOnCooldown ( self , await self . cooldown . get_cooldown ( context )) return True except Exception : if max_conc_acquired : await self . max_concurrency . release ( context ) raise def error ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run upon an error.\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"Error handler must be coroutine\" ) self . error_callback = call return call def pre_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run before the command\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"pre_run must be coroutine\" ) self . pre_run_callback = call return call def post_run ( self , call : Callable [ ... , Coroutine ]): \"\"\"A decorator to declare a coroutine as one that will be run after the command has\"\"\" if not asyncio . iscoroutinefunction ( call ): raise TypeError ( \"post_run must be coroutine\" ) self . post_run_callback = call return call","title":"BaseCommand"},{"location":"API%20Reference/models/Internal%20Models/command/#dis_snek.models.command.MessageCommand","text":"Represents a command triggered by standard message. Source code in dis_snek/models/command.py @attr . s ( slots = True , kw_only = True , on_setattr = [ attr . setters . convert , attr . setters . validate ]) class MessageCommand ( BaseCommand ): \"\"\" Represents a command triggered by standard message. \"\"\" name : str = attr . ib ( metadata = docs ( \"The name of the command\" ))","title":"MessageCommand"},{"location":"API%20Reference/models/Internal%20Models/command/#dis_snek.models.command.message_command","text":"A decorator to declare a coroutine as a message command. Parameters: Name Type Description Default name str The name of the command, defaults to the name of the coroutine None Returns: Type Description Message Command Object Source code in dis_snek/models/command.py def message_command ( name : str = None , ): \"\"\" A decorator to declare a coroutine as a message command. parameters: name: The name of the command, defaults to the name of the coroutine returns: Message Command Object \"\"\" def wrapper ( func ): if not asyncio . iscoroutinefunction ( func ): raise ValueError ( \"Commands must be coroutines\" ) cmd = MessageCommand ( name = name or func . __name__ , callback = func ) return cmd return wrapper","title":"message_command()"},{"location":"API%20Reference/models/Internal%20Models/command/#dis_snek.models.command.check","text":"Add a check to a command. Parameters: Name Type Description Default check Callable[..., Coroutine] A coroutine as a check for this command required Source code in dis_snek/models/command.py def check ( check : Callable [ ... , Coroutine ]): \"\"\" Add a check to a command. parameters: check: A coroutine as a check for this command \"\"\" def wrapper ( coro ): if isinstance ( coro , BaseCommand ): coro . checks . append ( check ) return if not hasattr ( coro , \"checks\" ): coro . checks = [] coro . checks . append ( check ) return coro return wrapper","title":"check()"},{"location":"API%20Reference/models/Internal%20Models/command/#dis_snek.models.command.cooldown","text":"Add a cooldown to a command Parameters: Name Type Description Default bucket Buckets The bucket used to track cooldowns required rate int How many commands may be ran per interval required interval float How many seconds to wait for a cooldown required Source code in dis_snek/models/command.py def cooldown ( bucket : Buckets , rate : int , interval : float ): \"\"\" Add a cooldown to a command Args: bucket: The bucket used to track cooldowns rate: How many commands may be ran per interval interval: How many seconds to wait for a cooldown \"\"\" def wrapper ( coro : Callable [ ... , Coroutine ]): cooldown_obj = Cooldown ( bucket , rate , interval ) coro . cooldown = cooldown_obj return coro return wrapper","title":"cooldown()"},{"location":"API%20Reference/models/Internal%20Models/command/#dis_snek.models.command.max_concurrency","text":"Add a maximum number of concurrent instances to the command. Parameters: Name Type Description Default bucket Buckets The bucket to enforce the maximum within required concurrent int The maximum number of concurrent instances to allow required Source code in dis_snek/models/command.py def max_concurrency ( bucket : Buckets , concurrent : int ): \"\"\" Add a maximum number of concurrent instances to the command. Args: bucket: The bucket to enforce the maximum within concurrent: The maximum number of concurrent instances to allow \"\"\" def wrapper ( coro : Callable [ ... , Coroutine ]): max_conc = MaxConcurrency ( concurrent , bucket ) coro . max_concurrency = max_conc return coro return wrapper","title":"max_concurrency()"},{"location":"API%20Reference/models/Internal%20Models/cooldowns/","text":"Buckets ( IntEnum ) \u00b6 Outlines the cooldown buckets that may be used. Should a bucket for guilds exist, and the command is invoked in a DM, a sane default will be used. Note To add your own, override this Source code in dis_snek/models/cooldowns.py class Buckets ( IntEnum ): \"\"\" Outlines the cooldown buckets that may be used. Should a bucket for guilds exist, and the command is invoked in a DM, a sane default will be used. ??? note To add your own, override this \"\"\" DEFAULT = 0 \"\"\"Default is the same as user\"\"\" USER = 1 \"\"\"Per user cooldowns\"\"\" GUILD = 2 \"\"\"Per guild cooldowns\"\"\" CHANNEL = 3 \"\"\"Per channel cooldowns\"\"\" MEMBER = 4 \"\"\"Per guild member cooldowns\"\"\" CATEGORY = 5 \"\"\"Per category cooldowns\"\"\" ROLE = 6 \"\"\"Per role cooldowns\"\"\" async def get_key ( self , context : \"Context\" ): if self is Buckets . USER : return context . author . id elif self is Buckets . GUILD : return context . guild . id if context . guild else context . author . id elif self is Buckets . CHANNEL : return context . channel . id elif self is Buckets . MEMBER : return ( context . guild . id , context . author . id ) if context . guild else context . author . id elif self is Buckets . CATEGORY : return await context . channel . parent . id if context . channel . parent else context . channel . id elif self is Buckets . ROLE : return context . channel . id if not context . guild else await context . author . top_role . id else : return context . author . id def __call__ ( self , context : \"Context\" ): return self . get_key ( context ) CATEGORY \u00b6 Per category cooldowns CHANNEL \u00b6 Per channel cooldowns DEFAULT \u00b6 Default is the same as user GUILD \u00b6 Per guild cooldowns MEMBER \u00b6 Per guild member cooldowns ROLE \u00b6 Per role cooldowns USER \u00b6 Per user cooldowns Cooldown \u00b6 Manages cooldowns and their respective buckets for a command Source code in dis_snek/models/cooldowns.py class Cooldown : \"\"\" Manages cooldowns and their respective buckets for a command \"\"\" __slots__ = \"bucket\" , \"cooldown_repositories\" , \"rate\" , \"interval\" def __init__ ( self , cooldown_bucket : Buckets , rate : int , interval : float ): self . bucket : Buckets = cooldown_bucket self . cooldown_repositories = {} self . rate : int = rate self . interval : float = interval async def get_cooldown ( self , context : \"Context\" ) -> \"CooldownSystem\" : key = await self . bucket ( context ) if key not in self . cooldown_repositories : cooldown = CooldownSystem ( self . rate , self . interval ) self . cooldown_repositories [ key ] = cooldown return cooldown return self . cooldown_repositories . get ( await self . bucket ( context )) async def acquire_token ( self , context : \"Context\" ) -> bool : \"\"\" Attempt to acquire a token for a command to run. Uses the context of the command to use the correct CooldownSystem Args: context: The context of the command Returns: True if a token was acquired, False if not \"\"\" cooldown = await self . get_cooldown ( context ) return cooldown . acquire_token () async def get_cooldown_time ( self , context : \"Context\" ) -> float : \"\"\" Get the remaining cooldown time. Args: context: The context of the command Returns: remaining cooldown time, will return 0 if the cooldown has not been reached \"\"\" cooldown = await self . get_cooldown ( context ) return cooldown . get_cooldown_time () async def on_cooldown ( self , context : \"Context\" ) -> bool : \"\"\" Returns the cooldown state of the command Args: context: The context of the command Returns: boolean state if the command is on cooldown or not \"\"\" cooldown = await self . get_cooldown ( context ) return cooldown . on_cooldown () async def reset_all ( self ) -> None : \"\"\" Resets this cooldown system to its initial state. !!! warning To be clear, this will reset **all** cooldowns for this command to their initial states \"\"\" # this doesnt need to be async, but for consistency, it is self . cooldown_repositories = {} async def reset ( self , context : \"Context\" ) -> None : \"\"\" Resets the cooldown for the bucket of which invoked this command Args: context: The context of the command \"\"\" cooldown = await self . get_cooldown ( context ) cooldown . reset () async acquire_token ( self , context ) \u00b6 Attempt to acquire a token for a command to run. Uses the context of the command to use the correct CooldownSystem Parameters: Name Type Description Default context Context The context of the command required Returns: Type Description bool True if a token was acquired, False if not Source code in dis_snek/models/cooldowns.py async def acquire_token ( self , context : \"Context\" ) -> bool : \"\"\" Attempt to acquire a token for a command to run. Uses the context of the command to use the correct CooldownSystem Args: context: The context of the command Returns: True if a token was acquired, False if not \"\"\" cooldown = await self . get_cooldown ( context ) return cooldown . acquire_token () async get_cooldown_time ( self , context ) \u00b6 Get the remaining cooldown time. Parameters: Name Type Description Default context Context The context of the command required Returns: Type Description float remaining cooldown time, will return 0 if the cooldown has not been reached Source code in dis_snek/models/cooldowns.py async def get_cooldown_time ( self , context : \"Context\" ) -> float : \"\"\" Get the remaining cooldown time. Args: context: The context of the command Returns: remaining cooldown time, will return 0 if the cooldown has not been reached \"\"\" cooldown = await self . get_cooldown ( context ) return cooldown . get_cooldown_time () async on_cooldown ( self , context ) \u00b6 Returns the cooldown state of the command Parameters: Name Type Description Default context Context The context of the command required Returns: Type Description bool boolean state if the command is on cooldown or not Source code in dis_snek/models/cooldowns.py async def on_cooldown ( self , context : \"Context\" ) -> bool : \"\"\" Returns the cooldown state of the command Args: context: The context of the command Returns: boolean state if the command is on cooldown or not \"\"\" cooldown = await self . get_cooldown ( context ) return cooldown . on_cooldown () async reset_all ( self ) \u00b6 Resets this cooldown system to its initial state. Warning To be clear, this will reset all cooldowns for this command to their initial states Source code in dis_snek/models/cooldowns.py async def reset_all ( self ) -> None : \"\"\" Resets this cooldown system to its initial state. !!! warning To be clear, this will reset **all** cooldowns for this command to their initial states \"\"\" # this doesnt need to be async, but for consistency, it is self . cooldown_repositories = {} async reset ( self , context ) \u00b6 Resets the cooldown for the bucket of which invoked this command Parameters: Name Type Description Default context Context The context of the command required Source code in dis_snek/models/cooldowns.py async def reset ( self , context : \"Context\" ) -> None : \"\"\" Resets the cooldown for the bucket of which invoked this command Args: context: The context of the command \"\"\" cooldown = await self . get_cooldown ( context ) cooldown . reset () CooldownSystem \u00b6 Represents a cooldown system for commands Attributes: Name Type Description rate int How many commands may be ran per interval interval float How many seconds to wait for a cooldown opened float When this cooldown session began Source code in dis_snek/models/cooldowns.py class CooldownSystem : \"\"\" Represents a cooldown system for commands Attributes: rate: How many commands may be ran per interval interval: How many seconds to wait for a cooldown opened: When this cooldown session began \"\"\" __slots__ = \"rate\" , \"interval\" , \"opened\" , \"_tokens\" def __init__ ( self , rate : int , interval : float ): self . rate : int = rate self . interval : float = interval self . opened : float = 0.0 self . _tokens : int = self . rate # sanity checks if self . rate < 1 : raise ValueError ( \"Cooldown rate must be greater than 0\" ) if self . interval < 1 : raise ValueError ( \"Cooldown interval must be greater than 0\" ) def reset ( self ) -> None : \"\"\" Resets the tokens for this cooldown \"\"\" self . _tokens = self . rate self . opened = 0.0 def on_cooldown ( self ) -> bool : \"\"\" Returns the cooldown state of the command Returns: boolean state if the command is on cooldown or not \"\"\" self . determine_cooldown () if self . _tokens == 0 : return False return True def acquire_token ( self ) -> bool : \"\"\" Attempt to acquire a token for a command to run. Returns: True if a token was acquired, False if not \"\"\" self . determine_cooldown () if self . _tokens == 0 : return False self . _tokens -= 1 self . opened = time . time () return True def get_cooldown_time ( self ) -> float : \"\"\" Returns how long until the cooldown will reset. Returns: remaining cooldown time, will return 0 if the cooldown has not been reached \"\"\" if self . _tokens != 0 : return 0 return self . interval - ( time . time () - self . opened ) def determine_cooldown ( self ) -> None : \"\"\" Determines the state of the cooldown system \"\"\" c_time = time . time () if c_time > self . opened + self . interval : # cooldown has expired, reset the cooldown self . reset () reset ( self ) \u00b6 Resets the tokens for this cooldown Source code in dis_snek/models/cooldowns.py def reset ( self ) -> None : \"\"\" Resets the tokens for this cooldown \"\"\" self . _tokens = self . rate self . opened = 0.0 on_cooldown ( self ) \u00b6 Returns the cooldown state of the command Returns: Type Description bool boolean state if the command is on cooldown or not Source code in dis_snek/models/cooldowns.py def on_cooldown ( self ) -> bool : \"\"\" Returns the cooldown state of the command Returns: boolean state if the command is on cooldown or not \"\"\" self . determine_cooldown () if self . _tokens == 0 : return False return True acquire_token ( self ) \u00b6 Attempt to acquire a token for a command to run. Returns: Type Description bool True if a token was acquired, False if not Source code in dis_snek/models/cooldowns.py def acquire_token ( self ) -> bool : \"\"\" Attempt to acquire a token for a command to run. Returns: True if a token was acquired, False if not \"\"\" self . determine_cooldown () if self . _tokens == 0 : return False self . _tokens -= 1 self . opened = time . time () return True get_cooldown_time ( self ) \u00b6 Returns how long until the cooldown will reset. Returns: Type Description float remaining cooldown time, will return 0 if the cooldown has not been reached Source code in dis_snek/models/cooldowns.py def get_cooldown_time ( self ) -> float : \"\"\" Returns how long until the cooldown will reset. Returns: remaining cooldown time, will return 0 if the cooldown has not been reached \"\"\" if self . _tokens != 0 : return 0 return self . interval - ( time . time () - self . opened ) determine_cooldown ( self ) \u00b6 Determines the state of the cooldown system Source code in dis_snek/models/cooldowns.py def determine_cooldown ( self ) -> None : \"\"\" Determines the state of the cooldown system \"\"\" c_time = time . time () if c_time > self . opened + self . interval : # cooldown has expired, reset the cooldown self . reset () MaxConcurrency \u00b6 Limits how many instances of a command may be running concurrently Attributes: Name Type Description bucket Buckets The bucket this concurrency applies to concurrent int The maximum number of concurrent instances permitted to wait bool Should we wait until a instance is available Source code in dis_snek/models/cooldowns.py class MaxConcurrency : \"\"\" Limits how many instances of a command may be running concurrently Attributes: bucket Buckets: The bucket this concurrency applies to concurrent int: The maximum number of concurrent instances permitted to wait bool: Should we wait until a instance is available \"\"\" def __init__ ( self , concurrent : int , concurrency_bucket : Buckets , wait = False ): self . bucket : Buckets = concurrency_bucket self . concurrency_repository : Dict = {} self . concurrent : int = concurrent self . wait = wait async def get_semaphore ( self , context : \"Context\" ) -> asyncio . Semaphore : \"\"\" Get the semaphore associated with the given context. Args: context: The commands context Returns: A semaphore object \"\"\" key = await self . bucket ( context ) if key not in self . concurrency_repository : semaphore = asyncio . Semaphore ( self . concurrent ) self . concurrency_repository [ key ] = semaphore return semaphore return self . concurrency_repository . get ( key ) async def acquire ( self , context : \"Context\" ) -> bool : \"\"\" Acquire an instance of the semaphore Args: context:The context of the command returns: If the semaphore was successfully acquired \"\"\" semaphore = await self . get_semaphore ( context ) if not self . wait and semaphore . locked (): return False acquired = await semaphore . acquire () return acquired async def release ( self , context : \"Context\" ) -> None : \"\"\" Release the semaphore. Args: context: The context of the command \"\"\" semaphore = await self . get_semaphore ( context ) semaphore . release () async get_semaphore ( self , context ) \u00b6 Get the semaphore associated with the given context. Parameters: Name Type Description Default context Context The commands context required Returns: Type Description Semaphore A semaphore object Source code in dis_snek/models/cooldowns.py async def get_semaphore ( self , context : \"Context\" ) -> asyncio . Semaphore : \"\"\" Get the semaphore associated with the given context. Args: context: The commands context Returns: A semaphore object \"\"\" key = await self . bucket ( context ) if key not in self . concurrency_repository : semaphore = asyncio . Semaphore ( self . concurrent ) self . concurrency_repository [ key ] = semaphore return semaphore return self . concurrency_repository . get ( key ) async acquire ( self , context ) \u00b6 Acquire an instance of the semaphore Parameters: Name Type Description Default context Context The context of the command required Returns: Type Description bool If the semaphore was successfully acquired Source code in dis_snek/models/cooldowns.py async def acquire ( self , context : \"Context\" ) -> bool : \"\"\" Acquire an instance of the semaphore Args: context:The context of the command returns: If the semaphore was successfully acquired \"\"\" semaphore = await self . get_semaphore ( context ) if not self . wait and semaphore . locked (): return False acquired = await semaphore . acquire () return acquired async release ( self , context ) \u00b6 Release the semaphore. Parameters: Name Type Description Default context Context The context of the command required Source code in dis_snek/models/cooldowns.py async def release ( self , context : \"Context\" ) -> None : \"\"\" Release the semaphore. Args: context: The context of the command \"\"\" semaphore = await self . get_semaphore ( context ) semaphore . release ()","title":"Cooldowns"},{"location":"API%20Reference/models/Internal%20Models/cooldowns/#dis_snek.models.cooldowns.Buckets","text":"Outlines the cooldown buckets that may be used. Should a bucket for guilds exist, and the command is invoked in a DM, a sane default will be used. Note To add your own, override this Source code in dis_snek/models/cooldowns.py class Buckets ( IntEnum ): \"\"\" Outlines the cooldown buckets that may be used. Should a bucket for guilds exist, and the command is invoked in a DM, a sane default will be used. ??? note To add your own, override this \"\"\" DEFAULT = 0 \"\"\"Default is the same as user\"\"\" USER = 1 \"\"\"Per user cooldowns\"\"\" GUILD = 2 \"\"\"Per guild cooldowns\"\"\" CHANNEL = 3 \"\"\"Per channel cooldowns\"\"\" MEMBER = 4 \"\"\"Per guild member cooldowns\"\"\" CATEGORY = 5 \"\"\"Per category cooldowns\"\"\" ROLE = 6 \"\"\"Per role cooldowns\"\"\" async def get_key ( self , context : \"Context\" ): if self is Buckets . USER : return context . author . id elif self is Buckets . GUILD : return context . guild . id if context . guild else context . author . id elif self is Buckets . CHANNEL : return context . channel . id elif self is Buckets . MEMBER : return ( context . guild . id , context . author . id ) if context . guild else context . author . id elif self is Buckets . CATEGORY : return await context . channel . parent . id if context . channel . parent else context . channel . id elif self is Buckets . ROLE : return context . channel . id if not context . guild else await context . author . top_role . id else : return context . author . id def __call__ ( self , context : \"Context\" ): return self . get_key ( context )","title":"Buckets"},{"location":"API%20Reference/models/Internal%20Models/cooldowns/#dis_snek.models.cooldowns.Cooldown","text":"Manages cooldowns and their respective buckets for a command Source code in dis_snek/models/cooldowns.py class Cooldown : \"\"\" Manages cooldowns and their respective buckets for a command \"\"\" __slots__ = \"bucket\" , \"cooldown_repositories\" , \"rate\" , \"interval\" def __init__ ( self , cooldown_bucket : Buckets , rate : int , interval : float ): self . bucket : Buckets = cooldown_bucket self . cooldown_repositories = {} self . rate : int = rate self . interval : float = interval async def get_cooldown ( self , context : \"Context\" ) -> \"CooldownSystem\" : key = await self . bucket ( context ) if key not in self . cooldown_repositories : cooldown = CooldownSystem ( self . rate , self . interval ) self . cooldown_repositories [ key ] = cooldown return cooldown return self . cooldown_repositories . get ( await self . bucket ( context )) async def acquire_token ( self , context : \"Context\" ) -> bool : \"\"\" Attempt to acquire a token for a command to run. Uses the context of the command to use the correct CooldownSystem Args: context: The context of the command Returns: True if a token was acquired, False if not \"\"\" cooldown = await self . get_cooldown ( context ) return cooldown . acquire_token () async def get_cooldown_time ( self , context : \"Context\" ) -> float : \"\"\" Get the remaining cooldown time. Args: context: The context of the command Returns: remaining cooldown time, will return 0 if the cooldown has not been reached \"\"\" cooldown = await self . get_cooldown ( context ) return cooldown . get_cooldown_time () async def on_cooldown ( self , context : \"Context\" ) -> bool : \"\"\" Returns the cooldown state of the command Args: context: The context of the command Returns: boolean state if the command is on cooldown or not \"\"\" cooldown = await self . get_cooldown ( context ) return cooldown . on_cooldown () async def reset_all ( self ) -> None : \"\"\" Resets this cooldown system to its initial state. !!! warning To be clear, this will reset **all** cooldowns for this command to their initial states \"\"\" # this doesnt need to be async, but for consistency, it is self . cooldown_repositories = {} async def reset ( self , context : \"Context\" ) -> None : \"\"\" Resets the cooldown for the bucket of which invoked this command Args: context: The context of the command \"\"\" cooldown = await self . get_cooldown ( context ) cooldown . reset ()","title":"Cooldown"},{"location":"API%20Reference/models/Internal%20Models/cooldowns/#dis_snek.models.cooldowns.CooldownSystem","text":"Represents a cooldown system for commands Attributes: Name Type Description rate int How many commands may be ran per interval interval float How many seconds to wait for a cooldown opened float When this cooldown session began Source code in dis_snek/models/cooldowns.py class CooldownSystem : \"\"\" Represents a cooldown system for commands Attributes: rate: How many commands may be ran per interval interval: How many seconds to wait for a cooldown opened: When this cooldown session began \"\"\" __slots__ = \"rate\" , \"interval\" , \"opened\" , \"_tokens\" def __init__ ( self , rate : int , interval : float ): self . rate : int = rate self . interval : float = interval self . opened : float = 0.0 self . _tokens : int = self . rate # sanity checks if self . rate < 1 : raise ValueError ( \"Cooldown rate must be greater than 0\" ) if self . interval < 1 : raise ValueError ( \"Cooldown interval must be greater than 0\" ) def reset ( self ) -> None : \"\"\" Resets the tokens for this cooldown \"\"\" self . _tokens = self . rate self . opened = 0.0 def on_cooldown ( self ) -> bool : \"\"\" Returns the cooldown state of the command Returns: boolean state if the command is on cooldown or not \"\"\" self . determine_cooldown () if self . _tokens == 0 : return False return True def acquire_token ( self ) -> bool : \"\"\" Attempt to acquire a token for a command to run. Returns: True if a token was acquired, False if not \"\"\" self . determine_cooldown () if self . _tokens == 0 : return False self . _tokens -= 1 self . opened = time . time () return True def get_cooldown_time ( self ) -> float : \"\"\" Returns how long until the cooldown will reset. Returns: remaining cooldown time, will return 0 if the cooldown has not been reached \"\"\" if self . _tokens != 0 : return 0 return self . interval - ( time . time () - self . opened ) def determine_cooldown ( self ) -> None : \"\"\" Determines the state of the cooldown system \"\"\" c_time = time . time () if c_time > self . opened + self . interval : # cooldown has expired, reset the cooldown self . reset ()","title":"CooldownSystem"},{"location":"API%20Reference/models/Internal%20Models/cooldowns/#dis_snek.models.cooldowns.MaxConcurrency","text":"Limits how many instances of a command may be running concurrently Attributes: Name Type Description bucket Buckets The bucket this concurrency applies to concurrent int The maximum number of concurrent instances permitted to wait bool Should we wait until a instance is available Source code in dis_snek/models/cooldowns.py class MaxConcurrency : \"\"\" Limits how many instances of a command may be running concurrently Attributes: bucket Buckets: The bucket this concurrency applies to concurrent int: The maximum number of concurrent instances permitted to wait bool: Should we wait until a instance is available \"\"\" def __init__ ( self , concurrent : int , concurrency_bucket : Buckets , wait = False ): self . bucket : Buckets = concurrency_bucket self . concurrency_repository : Dict = {} self . concurrent : int = concurrent self . wait = wait async def get_semaphore ( self , context : \"Context\" ) -> asyncio . Semaphore : \"\"\" Get the semaphore associated with the given context. Args: context: The commands context Returns: A semaphore object \"\"\" key = await self . bucket ( context ) if key not in self . concurrency_repository : semaphore = asyncio . Semaphore ( self . concurrent ) self . concurrency_repository [ key ] = semaphore return semaphore return self . concurrency_repository . get ( key ) async def acquire ( self , context : \"Context\" ) -> bool : \"\"\" Acquire an instance of the semaphore Args: context:The context of the command returns: If the semaphore was successfully acquired \"\"\" semaphore = await self . get_semaphore ( context ) if not self . wait and semaphore . locked (): return False acquired = await semaphore . acquire () return acquired async def release ( self , context : \"Context\" ) -> None : \"\"\" Release the semaphore. Args: context: The context of the command \"\"\" semaphore = await self . get_semaphore ( context ) semaphore . release ()","title":"MaxConcurrency"},{"location":"API%20Reference/models/Internal%20Models/discord/","text":"ClientObject ( DictSerializationMixin ) attrs \u00b6 Source code in dis_snek/models/discord.py @attr . s () class ClientObject ( DictSerializationMixin ): _client : \"Snake\" = field ( metadata = no_export_meta ) def __attrs_post_init__ ( self ): # This automatically populates the object with data from the cache try : if hasattr ( self , \"channel\" ) and self . channel is None and getattr ( self , \"_channel_id\" , None ): # If a channel attribute is expected, but not populated, grab it from the cache self . channel = self . _client . cache . channel_cache . get ( int ( self . _channel_id )) if self . channel and getattr ( self . channel , \"_guild_id\" , None ) and not getattr ( self , \"_guild_id\" , None ): # if we have a channel now, and are expecting a guild, but lack an ID, get it from the channel self . _guild_id = self . channel . _guild_id except AttributeError : pass try : if hasattr ( self , \"guild\" ) and self . guild is None and getattr ( self , \"_guild_id\" , None ): # if a guild is expected, but not populated, grab it from cache self . guild = self . _client . cache . guild_cache . get ( int ( self . _guild_id )) except AttributeError : pass try : if hasattr ( self , \"author\" ) and self . author is None and getattr ( self , \"_author_id\" , None ): # if an author is expected, but not populated, grab it from the cache if self . guild : self . author = self . _client . cache . member_cache . get (( int ( self . _guild_id ), int ( self . _author_id ))) if not self . author : # fall back to a user object if no member available or applicable self . author = self . _client . cache . user_cache . get ( int ( self . _author_id )) except AttributeError : pass @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: return super () . _process_dict ( data ) @classmethod def from_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ): data = cls . _process_dict ( data , client ) return cls ( client = client , ** cls . _filter_kwargs ( data , cls . _get_init_keys ())) @classmethod def from_list ( cls , datas : List [ Dict [ str , Any ]], client : \"Snake\" ): return [ cls . from_dict ( data , client ) for data in datas ] def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) classmethod from_dict ( data , client ) \u00b6 Process and converts dictionary data received from discord api to object class instance. Parameters: Name Type Description Default data Dict[str, Any] The json data received from discord api. required Source code in dis_snek/models/discord.py @classmethod def from_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ): data = cls . _process_dict ( data , client ) return cls ( client = client , ** cls . _filter_kwargs ( data , cls . _get_init_keys ())) classmethod from_list ( datas , client ) \u00b6 Process and converts list data received from discord api to object class instances. Parameters: Name Type Description Default data The json data received from discord api. required Source code in dis_snek/models/discord.py @classmethod def from_list ( cls , datas : List [ Dict [ str , Any ]], client : \"Snake\" ): return [ cls . from_dict ( data , client ) for data in datas ] update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self ) DiscordObject ( SnowflakeObject , ClientObject ) attrs \u00b6 Source code in dis_snek/models/discord.py @attr . s () class DiscordObject ( SnowflakeObject , ClientObject ): pass inherited property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return: inherited update_from_dict ( self , data ) \u00b6 Updates object attribute(s) with new json data received from discord api. Source code in dis_snek/models/discord.py def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value ) inherited to_dict ( self ) \u00b6 Exports object into dictionary representation, ready to be sent to discord api. Returns: Type Description Dict[str, Any] The exported dictionary. Source code in dis_snek/models/discord.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Exports object into dictionary representation, ready to be sent to discord api. returns: The exported dictionary. \"\"\" self . _check_object () return to_dict ( self )","title":"Discord"},{"location":"API%20Reference/models/Internal%20Models/discord/#dis_snek.models.discord.ClientObject","text":"Source code in dis_snek/models/discord.py @attr . s () class ClientObject ( DictSerializationMixin ): _client : \"Snake\" = field ( metadata = no_export_meta ) def __attrs_post_init__ ( self ): # This automatically populates the object with data from the cache try : if hasattr ( self , \"channel\" ) and self . channel is None and getattr ( self , \"_channel_id\" , None ): # If a channel attribute is expected, but not populated, grab it from the cache self . channel = self . _client . cache . channel_cache . get ( int ( self . _channel_id )) if self . channel and getattr ( self . channel , \"_guild_id\" , None ) and not getattr ( self , \"_guild_id\" , None ): # if we have a channel now, and are expecting a guild, but lack an ID, get it from the channel self . _guild_id = self . channel . _guild_id except AttributeError : pass try : if hasattr ( self , \"guild\" ) and self . guild is None and getattr ( self , \"_guild_id\" , None ): # if a guild is expected, but not populated, grab it from cache self . guild = self . _client . cache . guild_cache . get ( int ( self . _guild_id )) except AttributeError : pass try : if hasattr ( self , \"author\" ) and self . author is None and getattr ( self , \"_author_id\" , None ): # if an author is expected, but not populated, grab it from the cache if self . guild : self . author = self . _client . cache . member_cache . get (( int ( self . _guild_id ), int ( self . _author_id ))) if not self . author : # fall back to a user object if no member available or applicable self . author = self . _client . cache . user_cache . get ( int ( self . _author_id )) except AttributeError : pass @classmethod def _process_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ) -> Dict [ str , Any ]: return super () . _process_dict ( data ) @classmethod def from_dict ( cls , data : Dict [ str , Any ], client : \"Snake\" ): data = cls . _process_dict ( data , client ) return cls ( client = client , ** cls . _filter_kwargs ( data , cls . _get_init_keys ())) @classmethod def from_list ( cls , datas : List [ Dict [ str , Any ]], client : \"Snake\" ): return [ cls . from_dict ( data , client ) for data in datas ] def update_from_dict ( self , data ): data = self . _process_dict ( data , self . _client ) for key , value in self . _filter_kwargs ( data , self . _get_keys ()) . items (): # todo improve setattr ( self , key , value )","title":"ClientObject"},{"location":"API%20Reference/models/Internal%20Models/discord/#dis_snek.models.discord.DiscordObject","text":"Source code in dis_snek/models/discord.py @attr . s () class DiscordObject ( SnowflakeObject , ClientObject ): pass","title":"DiscordObject"},{"location":"API%20Reference/models/Internal%20Models/scale/","text":"Scale \u00b6 A class that allows you to separate your commands and listeners into separate files. Skins require an entrypoint in the same file called setup , this function allows client to load the Scale. Example Usage: 1 2 3 4 5 6 7 class ExampleScale ( Scale ): def __init__ ( self , bot ): print ( \"Scale Created\" ) @message_command async def some_command ( self , context ): await ctx . send ( f \"I was sent from a scale called { self . name } \" ) Parameters: Name Type Description Default bot Snake A reference to the client required Attributes: Name Type Description bot Snake A reference to the client name str The name of this Scale ( read-only ) description str A description of this Scale scale_checks str A list of checks to be ran on any command in this scale scale_prerun List A list of coroutines to be run before any command in this scale scale_postrun List A list of coroutines to be run after any command in this scale Source code in dis_snek/models/scale.py class Scale : \"\"\" A class that allows you to separate your commands and listeners into separate files. Skins require an entrypoint in the same file called `setup`, this function allows client to load the Scale. ??? Hint \"Example Usage:\" ```python class ExampleScale(Scale): def __init__(self, bot): print(\"Scale Created\") @message_command async def some_command(self, context): await ctx.send(f\"I was sent from a scale called {self.name}\") ``` parameters: bot Snake: A reference to the client Attributes: bot Snake: A reference to the client name str: The name of this Scale (`read-only`) description str: A description of this Scale scale_checks str: A list of checks to be ran on any command in this scale scale_prerun List: A list of coroutines to be run before any command in this scale scale_postrun List: A list of coroutines to be run after any command in this scale \"\"\" bot : \"Snake\" __name : str extension_name : str description : str scale_checks : List scale_prerun : List scale_postrun : List listeners : List _commands : List def __new__ ( cls , bot : \"Snake\" , * args , ** kwargs ): cls . bot = bot cls . __name = cls . __name__ cls . scale_checks = [] cls . scale_prerun = [] cls . scale_postrun = [] cls . listeners = [] cls . description = kwargs . get ( \"Description\" , None ) if not cls . description : cls . description = inspect . cleandoc ( cls . __doc__ ) if cls . __doc__ else None # load commands from class cls . _commands = [] cls . _listeners = [] new_cls = super () . __new__ ( cls ) for name , val in cls . __dict__ . items (): if isinstance ( val , BaseCommand ): val . scale = new_cls val = wrap_partial ( val , new_cls ) new_cls . _commands . append ( val ) if isinstance ( val , ComponentCommand ): bot . add_component_callback ( val ) elif isinstance ( val , InteractionCommand ): bot . add_interaction ( val ) else : bot . add_message_command ( val ) elif isinstance ( val , Listener ): val = wrap_partial ( val , new_cls ) bot . add_listener ( val ) new_cls . listeners . append ( val ) log . debug ( f \" { len ( new_cls . _commands ) } commands and { len ( new_cls . listeners ) } listeners\" f \" have been loaded from ` { new_cls . name } `\" ) new_cls . extension_name = inspect . getmodule ( new_cls ) . __name__ new_cls . bot . scales [ new_cls . name ] = new_cls return new_cls @property def __name__ ( self ): return self . name @property def commands ( self ): \"\"\"Get the commands from this Scale\"\"\" return self . _commands @property def listeners ( self ): \"\"\"Get the listeners from this Scale\"\"\" return self . _listeners @property def name ( self ): return self . __name def shed ( self ): \"\"\" Called when this Scale is being removed. \"\"\" for func in self . _commands : if isinstance ( func , ComponentCommand ): for listener in func . listeners : self . bot . _component_callbacks . pop ( listener ) elif isinstance ( func , InteractionCommand ): for scope in func . scopes : if self . bot . interactions . get ( scope ): self . bot . interactions [ scope ] . pop ( func . resolved_name , []) elif isinstance ( func , MessageCommand ): if self . bot . commands [ func . name ]: self . bot . commands . pop ( func . name ) for func in self . listeners : self . bot . listeners [ func . event ] . remove ( func ) self . bot . scales . pop ( self . name , None ) log . debug ( f \" { self . name } has been shed\" ) def add_scale_check ( self , coroutine : Callable [ ... , Coroutine ]) -> None : \"\"\" Add a coroutine as a check for all commands in this scale to run. This coroutine must take **only** the parameter `context`. ??? Hint \"Example Usage:\" ```python def __init__(self, bot): self.bot = bot self.add_scale_check(self.example) @staticmethod async def example(context: Context): if context.author.id == 123456789: return True return False ``` Args: coroutine: The coroutine to use as a check \"\"\" if not asyncio . iscoroutinefunction ( coroutine ): raise TypeError ( \"Check must be a coroutine\" ) if not self . scale_checks : self . scale_checks = [] self . scale_checks . append ( coroutine ) def add_scale_prerun ( self , coroutine : Callable [ ... , Coroutine ]): \"\"\" Add a coroutine to be run **before** all commands in this Scale. Note: Pre-runs will **only** be run if the commands checks pass ??? Hint \"Example Usage:\" ```python def __init__(self, bot): self.bot = bot self.add_scale_prerun(self.example) async def example(self, context: Context): await ctx.send(\"I ran first\") ``` Args: coroutine: The coroutine to run \"\"\" if not asyncio . iscoroutinefunction ( coroutine ): raise TypeError ( \"Callback must be a coroutine\" ) if not self . scale_prerun : self . scale_prerun = [] self . scale_prerun . append ( coroutine ) def add_scale_postrun ( self , coroutine : Callable [ ... , Coroutine ]): \"\"\" Add a coroutine to be run **after** all commands in this Scale. ??? Hint \"Example Usage:\" ```python def __init__(self, bot): self.bot = bot self.add_scale_postrun(self.example) async def example(self, context: Context): await ctx.send(\"I ran first\") ``` Args: coroutine: The coroutine to run \"\"\" if not asyncio . iscoroutinefunction ( coroutine ): raise TypeError ( \"Callback must be a coroutine\" ) if not self . scale_postrun : self . scale_postrun = [] self . scale_postrun . append ( coroutine ) property readonly commands \u00b6 Get the commands from this Scale property readonly listeners \u00b6 Get the listeners from this Scale shed ( self ) \u00b6 Called when this Scale is being removed. Source code in dis_snek/models/scale.py def shed ( self ): \"\"\" Called when this Scale is being removed. \"\"\" for func in self . _commands : if isinstance ( func , ComponentCommand ): for listener in func . listeners : self . bot . _component_callbacks . pop ( listener ) elif isinstance ( func , InteractionCommand ): for scope in func . scopes : if self . bot . interactions . get ( scope ): self . bot . interactions [ scope ] . pop ( func . resolved_name , []) elif isinstance ( func , MessageCommand ): if self . bot . commands [ func . name ]: self . bot . commands . pop ( func . name ) for func in self . listeners : self . bot . listeners [ func . event ] . remove ( func ) self . bot . scales . pop ( self . name , None ) log . debug ( f \" { self . name } has been shed\" ) add_scale_check ( self , coroutine ) \u00b6 Add a coroutine as a check for all commands in this scale to run. This coroutine must take only the parameter context . Example Usage: 1 2 3 4 5 6 7 8 9 def __init__ ( self , bot ): self . bot = bot self . add_scale_check ( self . example ) @staticmethod async def example ( context : Context ): if context . author . id == 123456789 : return True return False Parameters: Name Type Description Default coroutine Callable[..., Coroutine] The coroutine to use as a check required Source code in dis_snek/models/scale.py def add_scale_check ( self , coroutine : Callable [ ... , Coroutine ]) -> None : \"\"\" Add a coroutine as a check for all commands in this scale to run. This coroutine must take **only** the parameter `context`. ??? Hint \"Example Usage:\" ```python def __init__(self, bot): self.bot = bot self.add_scale_check(self.example) @staticmethod async def example(context: Context): if context.author.id == 123456789: return True return False ``` Args: coroutine: The coroutine to use as a check \"\"\" if not asyncio . iscoroutinefunction ( coroutine ): raise TypeError ( \"Check must be a coroutine\" ) if not self . scale_checks : self . scale_checks = [] self . scale_checks . append ( coroutine ) add_scale_prerun ( self , coroutine ) \u00b6 Add a coroutine to be run before all commands in this Scale. Note Pre-runs will only be run if the commands checks pass Example Usage: 1 2 3 4 5 6 def __init__ ( self , bot ): self . bot = bot self . add_scale_prerun ( self . example ) async def example ( self , context : Context ): await ctx . send ( \"I ran first\" ) Parameters: Name Type Description Default coroutine Callable[..., Coroutine] The coroutine to run required Source code in dis_snek/models/scale.py def add_scale_prerun ( self , coroutine : Callable [ ... , Coroutine ]): \"\"\" Add a coroutine to be run **before** all commands in this Scale. Note: Pre-runs will **only** be run if the commands checks pass ??? Hint \"Example Usage:\" ```python def __init__(self, bot): self.bot = bot self.add_scale_prerun(self.example) async def example(self, context: Context): await ctx.send(\"I ran first\") ``` Args: coroutine: The coroutine to run \"\"\" if not asyncio . iscoroutinefunction ( coroutine ): raise TypeError ( \"Callback must be a coroutine\" ) if not self . scale_prerun : self . scale_prerun = [] self . scale_prerun . append ( coroutine ) add_scale_postrun ( self , coroutine ) \u00b6 Add a coroutine to be run after all commands in this Scale. Example Usage: 1 2 3 4 5 6 def __init__ ( self , bot ): self . bot = bot self . add_scale_postrun ( self . example ) async def example ( self , context : Context ): await ctx . send ( \"I ran first\" ) Parameters: Name Type Description Default coroutine Callable[..., Coroutine] The coroutine to run required Source code in dis_snek/models/scale.py def add_scale_postrun ( self , coroutine : Callable [ ... , Coroutine ]): \"\"\" Add a coroutine to be run **after** all commands in this Scale. ??? Hint \"Example Usage:\" ```python def __init__(self, bot): self.bot = bot self.add_scale_postrun(self.example) async def example(self, context: Context): await ctx.send(\"I ran first\") ``` Args: coroutine: The coroutine to run \"\"\" if not asyncio . iscoroutinefunction ( coroutine ): raise TypeError ( \"Callback must be a coroutine\" ) if not self . scale_postrun : self . scale_postrun = [] self . scale_postrun . append ( coroutine )","title":"Scale"},{"location":"API%20Reference/models/Internal%20Models/scale/#dis_snek.models.scale.Scale","text":"A class that allows you to separate your commands and listeners into separate files. Skins require an entrypoint in the same file called setup , this function allows client to load the Scale. Example Usage: 1 2 3 4 5 6 7 class ExampleScale ( Scale ): def __init__ ( self , bot ): print ( \"Scale Created\" ) @message_command async def some_command ( self , context ): await ctx . send ( f \"I was sent from a scale called { self . name } \" ) Parameters: Name Type Description Default bot Snake A reference to the client required Attributes: Name Type Description bot Snake A reference to the client name str The name of this Scale ( read-only ) description str A description of this Scale scale_checks str A list of checks to be ran on any command in this scale scale_prerun List A list of coroutines to be run before any command in this scale scale_postrun List A list of coroutines to be run after any command in this scale Source code in dis_snek/models/scale.py class Scale : \"\"\" A class that allows you to separate your commands and listeners into separate files. Skins require an entrypoint in the same file called `setup`, this function allows client to load the Scale. ??? Hint \"Example Usage:\" ```python class ExampleScale(Scale): def __init__(self, bot): print(\"Scale Created\") @message_command async def some_command(self, context): await ctx.send(f\"I was sent from a scale called {self.name}\") ``` parameters: bot Snake: A reference to the client Attributes: bot Snake: A reference to the client name str: The name of this Scale (`read-only`) description str: A description of this Scale scale_checks str: A list of checks to be ran on any command in this scale scale_prerun List: A list of coroutines to be run before any command in this scale scale_postrun List: A list of coroutines to be run after any command in this scale \"\"\" bot : \"Snake\" __name : str extension_name : str description : str scale_checks : List scale_prerun : List scale_postrun : List listeners : List _commands : List def __new__ ( cls , bot : \"Snake\" , * args , ** kwargs ): cls . bot = bot cls . __name = cls . __name__ cls . scale_checks = [] cls . scale_prerun = [] cls . scale_postrun = [] cls . listeners = [] cls . description = kwargs . get ( \"Description\" , None ) if not cls . description : cls . description = inspect . cleandoc ( cls . __doc__ ) if cls . __doc__ else None # load commands from class cls . _commands = [] cls . _listeners = [] new_cls = super () . __new__ ( cls ) for name , val in cls . __dict__ . items (): if isinstance ( val , BaseCommand ): val . scale = new_cls val = wrap_partial ( val , new_cls ) new_cls . _commands . append ( val ) if isinstance ( val , ComponentCommand ): bot . add_component_callback ( val ) elif isinstance ( val , InteractionCommand ): bot . add_interaction ( val ) else : bot . add_message_command ( val ) elif isinstance ( val , Listener ): val = wrap_partial ( val , new_cls ) bot . add_listener ( val ) new_cls . listeners . append ( val ) log . debug ( f \" { len ( new_cls . _commands ) } commands and { len ( new_cls . listeners ) } listeners\" f \" have been loaded from ` { new_cls . name } `\" ) new_cls . extension_name = inspect . getmodule ( new_cls ) . __name__ new_cls . bot . scales [ new_cls . name ] = new_cls return new_cls @property def __name__ ( self ): return self . name @property def commands ( self ): \"\"\"Get the commands from this Scale\"\"\" return self . _commands @property def listeners ( self ): \"\"\"Get the listeners from this Scale\"\"\" return self . _listeners @property def name ( self ): return self . __name def shed ( self ): \"\"\" Called when this Scale is being removed. \"\"\" for func in self . _commands : if isinstance ( func , ComponentCommand ): for listener in func . listeners : self . bot . _component_callbacks . pop ( listener ) elif isinstance ( func , InteractionCommand ): for scope in func . scopes : if self . bot . interactions . get ( scope ): self . bot . interactions [ scope ] . pop ( func . resolved_name , []) elif isinstance ( func , MessageCommand ): if self . bot . commands [ func . name ]: self . bot . commands . pop ( func . name ) for func in self . listeners : self . bot . listeners [ func . event ] . remove ( func ) self . bot . scales . pop ( self . name , None ) log . debug ( f \" { self . name } has been shed\" ) def add_scale_check ( self , coroutine : Callable [ ... , Coroutine ]) -> None : \"\"\" Add a coroutine as a check for all commands in this scale to run. This coroutine must take **only** the parameter `context`. ??? Hint \"Example Usage:\" ```python def __init__(self, bot): self.bot = bot self.add_scale_check(self.example) @staticmethod async def example(context: Context): if context.author.id == 123456789: return True return False ``` Args: coroutine: The coroutine to use as a check \"\"\" if not asyncio . iscoroutinefunction ( coroutine ): raise TypeError ( \"Check must be a coroutine\" ) if not self . scale_checks : self . scale_checks = [] self . scale_checks . append ( coroutine ) def add_scale_prerun ( self , coroutine : Callable [ ... , Coroutine ]): \"\"\" Add a coroutine to be run **before** all commands in this Scale. Note: Pre-runs will **only** be run if the commands checks pass ??? Hint \"Example Usage:\" ```python def __init__(self, bot): self.bot = bot self.add_scale_prerun(self.example) async def example(self, context: Context): await ctx.send(\"I ran first\") ``` Args: coroutine: The coroutine to run \"\"\" if not asyncio . iscoroutinefunction ( coroutine ): raise TypeError ( \"Callback must be a coroutine\" ) if not self . scale_prerun : self . scale_prerun = [] self . scale_prerun . append ( coroutine ) def add_scale_postrun ( self , coroutine : Callable [ ... , Coroutine ]): \"\"\" Add a coroutine to be run **after** all commands in this Scale. ??? Hint \"Example Usage:\" ```python def __init__(self, bot): self.bot = bot self.add_scale_postrun(self.example) async def example(self, context: Context): await ctx.send(\"I ran first\") ``` Args: coroutine: The coroutine to run \"\"\" if not asyncio . iscoroutinefunction ( coroutine ): raise TypeError ( \"Callback must be a coroutine\" ) if not self . scale_postrun : self . scale_postrun = [] self . scale_postrun . append ( coroutine )","title":"Scale"},{"location":"API%20Reference/models/Internal%20Models/snowflake/","text":"SnowflakeObject attrs \u00b6 Source code in dis_snek/models/snowflake.py @define () class SnowflakeObject : id : \"Snowflake_Type\" = field ( repr = True , converter = to_snowflake ) def __eq__ ( self , other ): return self . id == other . id def __ne__ ( self , other ): return self . id != other . id def __hash__ ( self ): return int ( self . id ) << 32 @property def created_at ( self ) -> \"Timestamp\" : \"\"\" Returns a timestamp representing the date-time this discord object was created :return: \"\"\" return Timestamp . from_snowflake ( self . id ) attrs-field kw_only id : Snowflake_Type \u00b6 The custom emoji id. Leave empty if you are using standard unicode emoji. property readonly created_at : Timestamp \u00b6 Returns a timestamp representing the date-time this discord object was created :return:","title":"Snowflake"},{"location":"API%20Reference/models/Internal%20Models/snowflake/#dis_snek.models.snowflake.SnowflakeObject","text":"Source code in dis_snek/models/snowflake.py @define () class SnowflakeObject : id : \"Snowflake_Type\" = field ( repr = True , converter = to_snowflake ) def __eq__ ( self , other ): return self . id == other . id def __ne__ ( self , other ): return self . id != other . id def __hash__ ( self ): return int ( self . id ) << 32 @property def created_at ( self ) -> \"Timestamp\" : \"\"\" Returns a timestamp representing the date-time this discord object was created :return: \"\"\" return Timestamp . from_snowflake ( self . id )","title":"SnowflakeObject"},{"location":"API%20Reference/models/Internal%20Models/timestamp/","text":"TimestampStyles ( str , Enum ) \u00b6 An enumeration. Source code in dis_snek/models/timestamp.py class TimestampStyles ( str , Enum ): ShortTime = \"t\" LongTime = \"T\" ShortDate = \"d\" LongDate = \"D\" ShortDateTime = \"f\" # default LongDateTime = \"F\" RelativeTime = \"R\" Timestamp ( datetime ) \u00b6 A special class that represents Discord timestamps. Assumes that all naive datetimes are based on local timezone. Source code in dis_snek/models/timestamp.py class Timestamp ( datetime ): \"\"\"A special class that represents Discord timestamps. Assumes that all naive datetimes are based on local timezone. \"\"\" @classmethod def fromdatetime ( cls , dt : datetime ) -> \"Timestamp\" : timestamp = cls . fromtimestamp ( dt . timestamp (), tz = dt . tzinfo ) if timestamp . tzinfo is None : # assume naive datetimes are based on local timezone return timestamp . astimezone () return timestamp @classmethod def utcfromtimestamp ( cls , t : float ) -> \"Timestamp\" : \"\"\"Construct a timezone-aware UTC datetime from a POSIX timestamp.\"\"\" return super () . utcfromtimestamp ( t ) . replace ( tzinfo = timezone . utc ) @classmethod def fromisoformat ( cls , date_string : str ) -> \"Timestamp\" : timestamp = super () . fromisoformat ( date_string ) if timestamp . tzinfo is None : # assume naive datetimes are based on local timezone return timestamp . astimezone () return timestamp @classmethod def fromisocalendar ( cls , year : int , week : int , day : int ) -> \"Timestamp\" : return super () . fromisocalendar ( year , week , day ) . astimezone () @classmethod def fromtimestamp ( cls , t : float , tz = None ) -> \"Timestamp\" : timestamp = super () . fromtimestamp ( t , tz = tz ) if timestamp . tzinfo is None : # assume naive datetimes are based on local timezone return timestamp . astimezone () return timestamp @classmethod def fromordinal ( cls , n : int ) -> \"Timestamp\" : return super () . fromordinal ( n ) . astimezone () def to_snowflake ( self , high : bool = False ) -> Union [ str , int ]: \"\"\"Returns a numeric snowflake pretending to be created at the given date. When using as the lower end of a range, use ``tosnowflake(high=False) - 1`` to be inclusive, ``high=True`` to be exclusive. When using as the higher end of a range, use ``tosnowflake(high=True) + 1`` to be inclusive, ``high=False`` to be exclusive \"\"\" discord_millis = int ( self . timestamp () * 1000 - DISCORD_EPOCH ) return ( discord_millis << 22 ) + ( 2 ** 22 - 1 if high else 0 ) @classmethod def from_snowflake ( cls , snowflake : \"Snowflake_Type\" ) -> \"Timestamp\" : if isinstance ( snowflake , str ): snowflake = int ( snowflake ) timestamp = (( snowflake >> 22 ) + DISCORD_EPOCH ) / 1000 return cls . utcfromtimestamp ( timestamp ) def format ( self , style : Optional [ Union [ TimestampStyles , str ]] = None ) -> str : if not style : return f \"<t: { self . timestamp () : .0f } >\" else : return f \"<t: { self . timestamp () : .0f } : { style } >\" def __str__ ( self ): return self . format () classmethod utcfromtimestamp ( t ) \u00b6 Construct a timezone-aware UTC datetime from a POSIX timestamp. Source code in dis_snek/models/timestamp.py @classmethod def utcfromtimestamp ( cls , t : float ) -> \"Timestamp\" : \"\"\"Construct a timezone-aware UTC datetime from a POSIX timestamp.\"\"\" return super () . utcfromtimestamp ( t ) . replace ( tzinfo = timezone . utc ) classmethod fromisoformat ( date_string ) \u00b6 string -> datetime from datetime.isoformat() output Source code in dis_snek/models/timestamp.py @classmethod def fromisoformat ( cls , date_string : str ) -> \"Timestamp\" : timestamp = super () . fromisoformat ( date_string ) if timestamp . tzinfo is None : # assume naive datetimes are based on local timezone return timestamp . astimezone () return timestamp classmethod fromisocalendar ( year , week , day ) \u00b6 int, int, int -> Construct a date from the ISO year, week number and weekday. This is the inverse of the date.isocalendar() function Source code in dis_snek/models/timestamp.py @classmethod def fromisocalendar ( cls , year : int , week : int , day : int ) -> \"Timestamp\" : return super () . fromisocalendar ( year , week , day ) . astimezone () classmethod fromtimestamp ( t , tz = None ) \u00b6 timestamp[, tz] -> tz's local time from POSIX timestamp. Source code in dis_snek/models/timestamp.py @classmethod def fromtimestamp ( cls , t : float , tz = None ) -> \"Timestamp\" : timestamp = super () . fromtimestamp ( t , tz = tz ) if timestamp . tzinfo is None : # assume naive datetimes are based on local timezone return timestamp . astimezone () return timestamp classmethod fromordinal ( n ) \u00b6 int -> date corresponding to a proleptic Gregorian ordinal. Source code in dis_snek/models/timestamp.py @classmethod def fromordinal ( cls , n : int ) -> \"Timestamp\" : return super () . fromordinal ( n ) . astimezone () to_snowflake ( self , high = False ) \u00b6 Returns a numeric snowflake pretending to be created at the given date. When using as the lower end of a range, use tosnowflake(high=False) - 1 to be inclusive, high=True to be exclusive. When using as the higher end of a range, use tosnowflake(high=True) + 1 to be inclusive, high=False to be exclusive Source code in dis_snek/models/timestamp.py def to_snowflake ( self , high : bool = False ) -> Union [ str , int ]: \"\"\"Returns a numeric snowflake pretending to be created at the given date. When using as the lower end of a range, use ``tosnowflake(high=False) - 1`` to be inclusive, ``high=True`` to be exclusive. When using as the higher end of a range, use ``tosnowflake(high=True) + 1`` to be inclusive, ``high=False`` to be exclusive \"\"\" discord_millis = int ( self . timestamp () * 1000 - DISCORD_EPOCH ) return ( discord_millis << 22 ) + ( 2 ** 22 - 1 if high else 0 )","title":"Timestamp"},{"location":"API%20Reference/models/Internal%20Models/timestamp/#dis_snek.models.timestamp.TimestampStyles","text":"An enumeration. Source code in dis_snek/models/timestamp.py class TimestampStyles ( str , Enum ): ShortTime = \"t\" LongTime = \"T\" ShortDate = \"d\" LongDate = \"D\" ShortDateTime = \"f\" # default LongDateTime = \"F\" RelativeTime = \"R\"","title":"TimestampStyles"},{"location":"API%20Reference/models/Internal%20Models/timestamp/#dis_snek.models.timestamp.Timestamp","text":"A special class that represents Discord timestamps. Assumes that all naive datetimes are based on local timezone. Source code in dis_snek/models/timestamp.py class Timestamp ( datetime ): \"\"\"A special class that represents Discord timestamps. Assumes that all naive datetimes are based on local timezone. \"\"\" @classmethod def fromdatetime ( cls , dt : datetime ) -> \"Timestamp\" : timestamp = cls . fromtimestamp ( dt . timestamp (), tz = dt . tzinfo ) if timestamp . tzinfo is None : # assume naive datetimes are based on local timezone return timestamp . astimezone () return timestamp @classmethod def utcfromtimestamp ( cls , t : float ) -> \"Timestamp\" : \"\"\"Construct a timezone-aware UTC datetime from a POSIX timestamp.\"\"\" return super () . utcfromtimestamp ( t ) . replace ( tzinfo = timezone . utc ) @classmethod def fromisoformat ( cls , date_string : str ) -> \"Timestamp\" : timestamp = super () . fromisoformat ( date_string ) if timestamp . tzinfo is None : # assume naive datetimes are based on local timezone return timestamp . astimezone () return timestamp @classmethod def fromisocalendar ( cls , year : int , week : int , day : int ) -> \"Timestamp\" : return super () . fromisocalendar ( year , week , day ) . astimezone () @classmethod def fromtimestamp ( cls , t : float , tz = None ) -> \"Timestamp\" : timestamp = super () . fromtimestamp ( t , tz = tz ) if timestamp . tzinfo is None : # assume naive datetimes are based on local timezone return timestamp . astimezone () return timestamp @classmethod def fromordinal ( cls , n : int ) -> \"Timestamp\" : return super () . fromordinal ( n ) . astimezone () def to_snowflake ( self , high : bool = False ) -> Union [ str , int ]: \"\"\"Returns a numeric snowflake pretending to be created at the given date. When using as the lower end of a range, use ``tosnowflake(high=False) - 1`` to be inclusive, ``high=True`` to be exclusive. When using as the higher end of a range, use ``tosnowflake(high=True) + 1`` to be inclusive, ``high=False`` to be exclusive \"\"\" discord_millis = int ( self . timestamp () * 1000 - DISCORD_EPOCH ) return ( discord_millis << 22 ) + ( 2 ** 22 - 1 if high else 0 ) @classmethod def from_snowflake ( cls , snowflake : \"Snowflake_Type\" ) -> \"Timestamp\" : if isinstance ( snowflake , str ): snowflake = int ( snowflake ) timestamp = (( snowflake >> 22 ) + DISCORD_EPOCH ) / 1000 return cls . utcfromtimestamp ( timestamp ) def format ( self , style : Optional [ Union [ TimestampStyles , str ]] = None ) -> str : if not style : return f \"<t: { self . timestamp () : .0f } >\" else : return f \"<t: { self . timestamp () : .0f } : { style } >\" def __str__ ( self ): return self . format ()","title":"Timestamp"},{"location":"API%20Reference/models/events/discord/","text":"These are events dispatched by Discord. This is intended as a reference so you know what data to expect for each event Example Usage: The event classes outlined here are in CamelCase to comply with Class naming convention, however the event names are actually in lower_case_with_underscores so your listeners should be named as following: 1 2 3 4 5 6 7 8 9 @listen () def on_ready (): # ready events pass no data, so dont have params print ( \"Im ready!\" ) @listen () def on_guild_join ( event ): # guild_create events pass a guild object, expect a single param print ( f \" { event . guild . name } created\" ) Warning While all of these events are documented, not all of them are used, currently. RawGatewayEvent ( BaseEvent ) attrs \u00b6 An event dispatched from the gateway. Holds the raw dict that the gateway dispatches Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class RawGatewayEvent ( BaseEvent ): \"\"\"An event dispatched from the gateway. Holds the raw dict that the gateway dispatches\"\"\" data : dict = attr . ib ( factory = dict ) \"\"\"Raw Data from the gateway\"\"\" attrs-field data : dict \u00b6 Raw Data from the gateway ChannelCreate ( BaseEvent ) attrs \u00b6 Dispatched when a channel is created. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ChannelCreate ( BaseEvent ): \"\"\"Dispatched when a channel is created.\"\"\" channel : \"BaseChannel\" = attr . ib ( metadata = docs ( \"The channel this event is dispatched from\" )) attrs-field channel : BaseChannel \u00b6 The channel this event is dispatched from ChannelUpdate ( ChannelCreate ) attrs \u00b6 Dispatched when a channel is updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ChannelUpdate ( ChannelCreate ): \"\"\"Dispatched when a channel is updated\"\"\" attrs-field inherited channel : BaseChannel \u00b6 The channel this event is dispatched from ChannelDelete ( ChannelCreate ) attrs \u00b6 Dispatched when a channel is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ChannelDelete ( ChannelCreate ): \"\"\"Dispatched when a channel is deleted\"\"\" attrs-field inherited channel : BaseChannel \u00b6 The channel this event is dispatched from ChannelPinsUpdate ( ChannelCreate ) attrs \u00b6 Dispatched when a channel's pins are updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ChannelPinsUpdate ( ChannelCreate ): \"\"\"Dispatched when a channel's pins are updated\"\"\" last_pin_timestamp : \"Timestamp\" = attr . ib () \"\"\"The time at which the most recent pinned message was pinned\"\"\" attrs-field inherited channel : BaseChannel \u00b6 The channel this event is dispatched from attrs-field last_pin_timestamp : Timestamp \u00b6 The time at which the most recent pinned message was pinned ThreadCreate ( BaseEvent ) attrs \u00b6 Dispatched when a thread is created. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadCreate ( BaseEvent ): \"\"\"Dispatched when a thread is created.\"\"\" thread : \"TYPE_THREAD_CHANNEL\" = attr . ib ( metadata = docs ( \"The thread this event is dispatched from\" )) attrs-field thread : TYPE_THREAD_CHANNEL \u00b6 The thread this event is dispatched from ThreadUpdate ( ThreadCreate ) attrs \u00b6 Dispatched when a thread is updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadUpdate ( ThreadCreate ): \"\"\"Dispatched when a thread is updated\"\"\" attrs-field inherited thread : TYPE_THREAD_CHANNEL \u00b6 The thread this event is dispatched from ThreadDelete ( ThreadCreate ) attrs \u00b6 Dispatched when a thread is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadDelete ( ThreadCreate ): \"\"\"Dispatched when a thread is deleted\"\"\" attrs-field inherited thread : TYPE_THREAD_CHANNEL \u00b6 The thread this event is dispatched from ThreadListSync ( BaseEvent ) attrs \u00b6 Dispatched when gaining access to a channel, contains all active threads in that channel Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadListSync ( BaseEvent ): \"\"\"Dispatched when gaining access to a channel, contains all active threads in that channel\"\"\" channel_ids : List [ \"Snowflake_Type\" ] = attr . ib () \"\"\"The parent channel ids whose threads are being synced. If omitted, then threads were synced for the entire guild. This array may contain channel_ids that have no active threads as well, so you know to clear that data.\"\"\" threads : List [ \"BaseChannel\" ] = attr . ib () \"\"\"all active threads in the given channels that the current user can access\"\"\" members : List [ \"Member\" ] = attr . ib () \"\"\"all thread member objects from the synced threads for the current user, indicating which threads the current user has been added to\"\"\" attrs-field channel_ids : List [ Snowflake_Type ] \u00b6 The parent channel ids whose threads are being synced. If omitted, then threads were synced for the entire guild. This array may contain channel_ids that have no active threads as well, so you know to clear that data. attrs-field members : List [ Member ] \u00b6 all thread member objects from the synced threads for the current user, indicating which threads the current user has been added to attrs-field threads : List [ BaseChannel ] \u00b6 all active threads in the given channels that the current user can access ThreadMemberUpdate ( ThreadCreate ) attrs \u00b6 Dispatched when the thread member object for the current user is updated. Note from Discord This event is documented for completeness, but unlikely to be used by most bots. For bots, this event largely is just a signal that you are a member of the thread Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadMemberUpdate ( ThreadCreate ): \"\"\"Dispatched when the thread member object for the current user is updated. ??? info \"Note from Discord\" This event is documented for completeness, but unlikely to be used by most bots. For bots, this event largely is just a signal that you are a member of the thread \"\"\" member : \"Member\" = attr . ib () \"\"\"The member who was added\"\"\" attrs-field member : Member \u00b6 The member who was added attrs-field inherited thread : TYPE_THREAD_CHANNEL \u00b6 The thread this event is dispatched from ThreadMembersUpdate ( BaseEvent ) attrs \u00b6 Dispatched when anyone is added or removed from a thread. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadMembersUpdate ( BaseEvent ): \"\"\"Dispatched when anyone is added or removed from a thread.\"\"\" id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the thread\"\"\" member_count : int = attr . ib ( default = 50 ) \"\"\"the approximate number of members in the thread, capped at 50\"\"\" added_members : List [ \"Member\" ] = attr . ib ( factory = list ) \"\"\"Users added to the thread\"\"\" removed_member_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) \"\"\"Users removed from the thread\"\"\" attrs-field added_members : List [ Member ] \u00b6 Users added to the thread attrs-field id : Snowflake_Type \u00b6 The ID of the thread attrs-field member_count : int \u00b6 the approximate number of members in the thread, capped at 50 attrs-field removed_member_ids : List [ Snowflake_Type ] \u00b6 Users removed from the thread GuildJoin ( BaseEvent ) attrs \u00b6 Dispatched when a guild is joined, created, or becomes available. Note This is called multiple times during startup, check the bot is ready before responding to this. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildJoin ( BaseEvent ): \"\"\"Dispatched when a guild is joined, created, or becomes available. !!! note This is called multiple times during startup, check the bot is ready before responding to this. \"\"\" guild : \"Guild\" = attr . ib () \"\"\"The guild that was created\"\"\" attrs-field guild : Guild \u00b6 The guild that was created GuildUpdate ( BaseEvent ) attrs \u00b6 Dispatched when a guild is updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildUpdate ( BaseEvent ): \"\"\"Dispatched when a guild is updated.\"\"\" before : \"Guild\" = attr . ib () \"\"\"Guild before this event\"\"\" after : \"Guild\" = attr . ib () \"\"\"Guild after this event\"\"\" attrs-field after : Guild \u00b6 Guild after this event attrs-field before : Guild \u00b6 Guild before this event GuildLeft ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a guild is left Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildLeft ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild is left\"\"\" guild : Optional [ \"Guild\" ] = attr . ib ( default = MISSING ) \"\"\"The guild, if it was cached\"\"\" attrs-field guild : Optional [ Guild ] \u00b6 The guild, if it was cached attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild GuildUnavailable ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a guild is not available. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildUnavailable ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild is not available.\"\"\" guild : Optional [ \"Guild\" ] = attr . ib ( default = MISSING ) \"\"\"The guild, if it was cached\"\"\" attrs-field guild : Optional [ Guild ] \u00b6 The guild, if it was cached attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild BanCreate ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when someone was banned from a guild Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class BanCreate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when someone was banned from a guild\"\"\" user : \"BaseUser\" = attr . ib ( metadata = docs ( \"The user\" )) attrs-field user : BaseUser \u00b6 The user attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild BanRemove ( BanCreate ) attrs \u00b6 Dispatched when a users ban is removed Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class BanRemove ( BanCreate ): \"\"\"Dispatched when a users ban is removed\"\"\" attrs-field inherited user : BaseUser \u00b6 The user attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild GuildEmojisUpdate ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a guild's emojis are updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildEmojisUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild's emojis are updated.\"\"\" before : List [ \"Emoji\" ] = attr . ib ( factory = list ) \"\"\"List of emoji before this event\"\"\" after : List [ \"Emoji\" ] = attr . ib ( factory = list ) \"\"\"List of emoji after this event\"\"\" attrs-field after : List [ Emoji ] \u00b6 List of emoji after this event attrs-field before : List [ Emoji ] \u00b6 List of emoji before this event attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild GuildStickersUpdate ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a guild's stickers are updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildStickersUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild's stickers are updated.\"\"\" before : List [ \"Sticker\" ] = attr . ib ( factory = list ) \"\"\"List of stickers from before this event\"\"\" after : List [ \"Sticker\" ] = attr . ib ( factory = list ) \"\"\"List of stickers from after this event\"\"\" attrs-field after : List [ Sticker ] \u00b6 List of stickers from after this event attrs-field before : List [ Sticker ] \u00b6 List of stickers from before this event attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild MemberAdd ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a member is added to a guild. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MemberAdd ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a member is added to a guild.\"\"\" member : \"Member\" = attr . ib ( metadata = docs ( \"The member who was added\" )) attrs-field member : Member \u00b6 The member who was added attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild MemberRemove ( MemberAdd ) attrs \u00b6 Dispatched when a member is removed from a guild. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MemberRemove ( MemberAdd ): \"\"\"Dispatched when a member is removed from a guild.\"\"\" member : Union [ \"Member\" , \"User\" ] = attr . ib ( metadata = docs ( \"The member who was added, can be user if the member is not cached\" ) ) attrs-field member : Union [ Member , User ] \u00b6 The member who was added, can be user if the member is not cached attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild MemberUpdate ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a member is updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MemberUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a member is updated.\"\"\" before : \"Member\" = attr . ib () \"\"\"The state of the member before this event\"\"\" after : \"Member\" = attr . ib () \"\"\"The state of the member after this event\"\"\" attrs-field after : Member \u00b6 The state of the member after this event attrs-field before : Member \u00b6 The state of the member before this event attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild RoleCreate ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a role is created. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class RoleCreate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a role is created.\"\"\" role : \"Role\" = attr . ib () \"\"\"The created role\"\"\" attrs-field role : Role \u00b6 The created role attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild RoleUpdate ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a role is updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class RoleUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a role is updated.\"\"\" before : \"Role\" = attr . ib () \"\"\"The role before this event\"\"\" after : \"Role\" = attr . ib () \"\"\"The role after this event\"\"\" attrs-field after : Role \u00b6 The role after this event attrs-field before : Role \u00b6 The role before this event attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild RoleDelete ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a guild role is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class RoleDelete ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild role is deleted\"\"\" role_id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the deleted role\"\"\" attrs-field role_id : Snowflake_Type \u00b6 The ID of the deleted role attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild GuildMembersChunk ( BaseEvent , GuildEvent ) attrs \u00b6 Sent in response to Guild Request Members. You can use the chunk_index and chunk_count to calculate how many chunks are left for your request. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildMembersChunk ( BaseEvent , GuildEvent ): \"\"\"Sent in response to Guild Request Members. You can use the `chunk_index` and `chunk_count` to calculate how many chunks are left for your request.\"\"\" chunk_index : int = attr . ib () \"\"\"The chunk index in the expected chunks for this response (0 <= chunk_index < chunk_count)\"\"\" chunk_count : int = attr . ib () \"\"\"the total number of expected chunks for this response\"\"\" presences : List = attr . ib () \"\"\"if passing true to `REQUEST_GUILD_MEMBERS`, presences of the returned members will be here\"\"\" nonce : str = attr . ib () \"\"\"The nonce used in the request, if any\"\"\" members : List [ \"Member\" ] = attr . ib ( factory = list ) \"\"\"A list of members\"\"\" attrs-field chunk_count : int \u00b6 the total number of expected chunks for this response attrs-field chunk_index : int \u00b6 The chunk index in the expected chunks for this response (0 <= chunk_index < chunk_count) attrs-field members : List [ Member ] \u00b6 A list of members attrs-field nonce : str \u00b6 The nonce used in the request, if any attrs-field presences : List \u00b6 if passing true to REQUEST_GUILD_MEMBERS , presences of the returned members will be here attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild IntegrationCreate ( BaseEvent ) attrs \u00b6 Dispatched when a guild integration is created Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class IntegrationCreate ( BaseEvent ): \"\"\"Dispatched when a guild integration is created\"\"\" integration : \"GuildIntegration\" = attr . ib () IntegrationUpdate ( IntegrationCreate ) attrs \u00b6 Dispatched when a guild integration is updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class IntegrationUpdate ( IntegrationCreate ): \"\"\"Dispatched when a guild integration is updated\"\"\" IntegrationDelete ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a guild integration is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class IntegrationDelete ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild integration is deleted\"\"\" id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the integration\"\"\" application_id : \"Snowflake_Type\" = attr . ib ( default = None ) \"\"\"The ID of the bot/application for this integration\"\"\" attrs-field application_id : Snowflake_Type \u00b6 The ID of the bot/application for this integration attrs-field id : Snowflake_Type \u00b6 The ID of the integration attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild InviteCreate ( BaseEvent ) attrs \u00b6 Dispatched when a guild invite is created Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class InviteCreate ( BaseEvent ): \"\"\"Dispatched when a guild invite is created\"\"\" invite : Invite = attr . ib () InviteDelete ( InviteCreate ) attrs \u00b6 Dispatched when an invite is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class InviteDelete ( InviteCreate ): \"\"\"Dispatched when an invite is deleted\"\"\" MessageCreate ( BaseEvent ) attrs \u00b6 Dispatched when a message is created Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageCreate ( BaseEvent ): \"\"\"Dispatched when a message is created\"\"\" message : \"Message\" = attr . ib () MessageUpdate ( BaseEvent ) attrs \u00b6 Dispatched when a message is edited Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageUpdate ( BaseEvent ): \"\"\"Dispatched when a message is edited\"\"\" before : \"Message\" = attr . ib () \"\"\"The message before this event was created\"\"\" after : \"Message\" = attr . ib () \"\"\"The message after this event was created\"\"\" attrs-field after : Message \u00b6 The message after this event was created attrs-field before : Message \u00b6 The message before this event was created MessageDelete ( BaseEvent ) attrs \u00b6 Dispatched when a message is deleted. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageDelete ( BaseEvent ): \"\"\"Dispatched when a message is deleted.\"\"\" message : \"Message\" = attr . ib () MessageDeleteBulk ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when multiple messages are deleted at once. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageDeleteBulk ( BaseEvent , GuildEvent ): \"\"\"Dispatched when multiple messages are deleted at once.\"\"\" channel_id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the channel these were deleted in\"\"\" ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) \"\"\"A list of message snowflakes\"\"\" attrs-field channel_id : Snowflake_Type \u00b6 The ID of the channel these were deleted in attrs-field ids : List [ Snowflake_Type ] \u00b6 A list of message snowflakes attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild MessageReactionAdd ( BaseEvent ) attrs \u00b6 Dispatched when a reaction is added to a message. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageReactionAdd ( BaseEvent ): \"\"\"Dispatched when a reaction is added to a message.\"\"\" message : \"Message\" = attr . ib ( metadata = docs ( \"The message that was reacted to\" )) emoji : \"emoji\" = attr . ib ( metadata = docs ( \"The emoji that was added to the message\" )) author : Union [ \"Member\" , \"User\" ] = attr . ib ( metadata = docs ( \"The user who added the reaction\" )) attrs-field author : Union [ Member , User ] \u00b6 The user who added the reaction attrs-field emoji : emoji \u00b6 The emoji that was added to the message attrs-field message : Message \u00b6 The message that was reacted to MessageReactionRemove ( MessageReactionAdd ) attrs \u00b6 Dispatched when a reaction is removed Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageReactionRemove ( MessageReactionAdd ): \"\"\"Dispatched when a reaction is removed\"\"\" attrs-field inherited author : Union [ Member , User ] \u00b6 The user who added the reaction attrs-field inherited emoji : emoji \u00b6 The emoji that was added to the message attrs-field inherited message : Message \u00b6 The message that was reacted to MessageReactionRemoveAll ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when all reactions are removed from a message Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageReactionRemoveAll ( BaseEvent , GuildEvent ): \"\"\"Dispatched when all reactions are removed from a message\"\"\" message : \"Message\" = attr . ib () \"\"\"The message that was reacted to\"\"\" attrs-field message : Message \u00b6 The message that was reacted to attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild PresenceUpdate ( BaseEvent ) attrs \u00b6 A user's presence has changed Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class PresenceUpdate ( BaseEvent ): \"\"\"A user's presence has changed\"\"\" user : \"User\" = attr . ib () \"\"\"The user in question\"\"\" status : str = attr . ib () \"\"\"'Either `idle`, `dnd`, `online`, or `offline`'\"\"\" activities : List = attr . ib () \"\"\"The users current activities\"\"\" client_status : dict = attr . ib () \"\"\"What platform the user is reported as being on\"\"\" guild_id : \"Snowflake_Type\" = attr . ib () \"\"\"The guild this presence update was dispatched from\"\"\" attrs-field activities : List \u00b6 The users current activities attrs-field client_status : dict \u00b6 What platform the user is reported as being on attrs-field guild_id : Snowflake_Type \u00b6 The guild this presence update was dispatched from attrs-field status : str \u00b6 'Either idle , dnd , online , or offline ' attrs-field user : User \u00b6 The user in question StageInstanceCreate ( BaseEvent ) attrs \u00b6 Dispatched when a stage instance is created Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class StageInstanceCreate ( BaseEvent ): \"\"\"Dispatched when a stage instance is created\"\"\" stage_instance : StageInstance = attr . ib ( metadata = docs ( \"The stage instance\" )) attrs-field stage_instance : StageInstance \u00b6 The stage instance StageInstanceDelete ( StageInstanceCreate ) attrs \u00b6 Dispatched when a stage instance is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class StageInstanceDelete ( StageInstanceCreate ): \"\"\"Dispatched when a stage instance is deleted\"\"\" attrs-field inherited stage_instance : StageInstance \u00b6 The stage instance StageInstanceUpdate ( StageInstanceCreate ) attrs \u00b6 Dispatched when a stage instance is updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class StageInstanceUpdate ( StageInstanceCreate ): \"\"\"Dispatched when a stage instance is updated\"\"\" attrs-field inherited stage_instance : StageInstance \u00b6 The stage instance TypingStart ( BaseEvent ) attrs \u00b6 Dispatched when a user starts typing Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class TypingStart ( BaseEvent ): \"\"\"Dispatched when a user starts typing\"\"\" author : Union [ \"User\" , \"Member\" ] = attr . ib () \"\"\"The user who started typing\"\"\" channel : \"BaseChannel\" = attr . ib () \"\"\"The channel typing is in\"\"\" guild : \"Guild\" = attr . ib () \"\"\"The ID of the guild this typing is in\"\"\" timestamp : \"Timestamp\" = attr . ib () \"\"\"unix time (in seconds) of when the user started typing\"\"\" attrs-field author : Union [ User , Member ] \u00b6 The user who started typing attrs-field channel : BaseChannel \u00b6 The channel typing is in attrs-field guild : Guild \u00b6 The ID of the guild this typing is in attrs-field timestamp : Timestamp \u00b6 unix time (in seconds) of when the user started typing WebhooksUpdate ( BaseEvent , GuildEvent ) attrs \u00b6 Dispatched when a guild channel webhook is created, updated, or deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class WebhooksUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild channel webhook is created, updated, or deleted\"\"\" # Discord doesnt sent the webhook object for this event, for some reason channel_id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the webhook was updated\"\"\" attrs-field channel_id : Snowflake_Type \u00b6 The ID of the webhook was updated attrs-field inherited guild_id : Snowflake_Type \u00b6 The ID of the guild InteractionCreate ( BaseEvent ) attrs \u00b6 Dispatched when a user uses an Application Command Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class InteractionCreate ( BaseEvent ): \"\"\"Dispatched when a user uses an Application Command\"\"\" interaction : dict = attr . ib ()","title":"Discord"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.RawGatewayEvent","text":"An event dispatched from the gateway. Holds the raw dict that the gateway dispatches Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class RawGatewayEvent ( BaseEvent ): \"\"\"An event dispatched from the gateway. Holds the raw dict that the gateway dispatches\"\"\" data : dict = attr . ib ( factory = dict ) \"\"\"Raw Data from the gateway\"\"\"","title":"RawGatewayEvent"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ChannelCreate","text":"Dispatched when a channel is created. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ChannelCreate ( BaseEvent ): \"\"\"Dispatched when a channel is created.\"\"\" channel : \"BaseChannel\" = attr . ib ( metadata = docs ( \"The channel this event is dispatched from\" ))","title":"ChannelCreate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ChannelUpdate","text":"Dispatched when a channel is updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ChannelUpdate ( ChannelCreate ): \"\"\"Dispatched when a channel is updated\"\"\"","title":"ChannelUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ChannelDelete","text":"Dispatched when a channel is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ChannelDelete ( ChannelCreate ): \"\"\"Dispatched when a channel is deleted\"\"\"","title":"ChannelDelete"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ChannelPinsUpdate","text":"Dispatched when a channel's pins are updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ChannelPinsUpdate ( ChannelCreate ): \"\"\"Dispatched when a channel's pins are updated\"\"\" last_pin_timestamp : \"Timestamp\" = attr . ib () \"\"\"The time at which the most recent pinned message was pinned\"\"\"","title":"ChannelPinsUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ThreadCreate","text":"Dispatched when a thread is created. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadCreate ( BaseEvent ): \"\"\"Dispatched when a thread is created.\"\"\" thread : \"TYPE_THREAD_CHANNEL\" = attr . ib ( metadata = docs ( \"The thread this event is dispatched from\" ))","title":"ThreadCreate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ThreadUpdate","text":"Dispatched when a thread is updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadUpdate ( ThreadCreate ): \"\"\"Dispatched when a thread is updated\"\"\"","title":"ThreadUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ThreadDelete","text":"Dispatched when a thread is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadDelete ( ThreadCreate ): \"\"\"Dispatched when a thread is deleted\"\"\"","title":"ThreadDelete"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ThreadListSync","text":"Dispatched when gaining access to a channel, contains all active threads in that channel Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadListSync ( BaseEvent ): \"\"\"Dispatched when gaining access to a channel, contains all active threads in that channel\"\"\" channel_ids : List [ \"Snowflake_Type\" ] = attr . ib () \"\"\"The parent channel ids whose threads are being synced. If omitted, then threads were synced for the entire guild. This array may contain channel_ids that have no active threads as well, so you know to clear that data.\"\"\" threads : List [ \"BaseChannel\" ] = attr . ib () \"\"\"all active threads in the given channels that the current user can access\"\"\" members : List [ \"Member\" ] = attr . ib () \"\"\"all thread member objects from the synced threads for the current user, indicating which threads the current user has been added to\"\"\"","title":"ThreadListSync"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ThreadMemberUpdate","text":"Dispatched when the thread member object for the current user is updated. Note from Discord This event is documented for completeness, but unlikely to be used by most bots. For bots, this event largely is just a signal that you are a member of the thread Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadMemberUpdate ( ThreadCreate ): \"\"\"Dispatched when the thread member object for the current user is updated. ??? info \"Note from Discord\" This event is documented for completeness, but unlikely to be used by most bots. For bots, this event largely is just a signal that you are a member of the thread \"\"\" member : \"Member\" = attr . ib () \"\"\"The member who was added\"\"\"","title":"ThreadMemberUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.ThreadMembersUpdate","text":"Dispatched when anyone is added or removed from a thread. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class ThreadMembersUpdate ( BaseEvent ): \"\"\"Dispatched when anyone is added or removed from a thread.\"\"\" id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the thread\"\"\" member_count : int = attr . ib ( default = 50 ) \"\"\"the approximate number of members in the thread, capped at 50\"\"\" added_members : List [ \"Member\" ] = attr . ib ( factory = list ) \"\"\"Users added to the thread\"\"\" removed_member_ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) \"\"\"Users removed from the thread\"\"\"","title":"ThreadMembersUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.GuildJoin","text":"Dispatched when a guild is joined, created, or becomes available. Note This is called multiple times during startup, check the bot is ready before responding to this. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildJoin ( BaseEvent ): \"\"\"Dispatched when a guild is joined, created, or becomes available. !!! note This is called multiple times during startup, check the bot is ready before responding to this. \"\"\" guild : \"Guild\" = attr . ib () \"\"\"The guild that was created\"\"\"","title":"GuildJoin"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.GuildUpdate","text":"Dispatched when a guild is updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildUpdate ( BaseEvent ): \"\"\"Dispatched when a guild is updated.\"\"\" before : \"Guild\" = attr . ib () \"\"\"Guild before this event\"\"\" after : \"Guild\" = attr . ib () \"\"\"Guild after this event\"\"\"","title":"GuildUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.GuildLeft","text":"Dispatched when a guild is left Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildLeft ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild is left\"\"\" guild : Optional [ \"Guild\" ] = attr . ib ( default = MISSING ) \"\"\"The guild, if it was cached\"\"\"","title":"GuildLeft"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.GuildUnavailable","text":"Dispatched when a guild is not available. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildUnavailable ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild is not available.\"\"\" guild : Optional [ \"Guild\" ] = attr . ib ( default = MISSING ) \"\"\"The guild, if it was cached\"\"\"","title":"GuildUnavailable"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.BanCreate","text":"Dispatched when someone was banned from a guild Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class BanCreate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when someone was banned from a guild\"\"\" user : \"BaseUser\" = attr . ib ( metadata = docs ( \"The user\" ))","title":"BanCreate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.BanRemove","text":"Dispatched when a users ban is removed Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class BanRemove ( BanCreate ): \"\"\"Dispatched when a users ban is removed\"\"\"","title":"BanRemove"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.GuildEmojisUpdate","text":"Dispatched when a guild's emojis are updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildEmojisUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild's emojis are updated.\"\"\" before : List [ \"Emoji\" ] = attr . ib ( factory = list ) \"\"\"List of emoji before this event\"\"\" after : List [ \"Emoji\" ] = attr . ib ( factory = list ) \"\"\"List of emoji after this event\"\"\"","title":"GuildEmojisUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.GuildStickersUpdate","text":"Dispatched when a guild's stickers are updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildStickersUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild's stickers are updated.\"\"\" before : List [ \"Sticker\" ] = attr . ib ( factory = list ) \"\"\"List of stickers from before this event\"\"\" after : List [ \"Sticker\" ] = attr . ib ( factory = list ) \"\"\"List of stickers from after this event\"\"\"","title":"GuildStickersUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MemberAdd","text":"Dispatched when a member is added to a guild. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MemberAdd ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a member is added to a guild.\"\"\" member : \"Member\" = attr . ib ( metadata = docs ( \"The member who was added\" ))","title":"MemberAdd"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MemberRemove","text":"Dispatched when a member is removed from a guild. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MemberRemove ( MemberAdd ): \"\"\"Dispatched when a member is removed from a guild.\"\"\" member : Union [ \"Member\" , \"User\" ] = attr . ib ( metadata = docs ( \"The member who was added, can be user if the member is not cached\" ) )","title":"MemberRemove"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MemberUpdate","text":"Dispatched when a member is updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MemberUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a member is updated.\"\"\" before : \"Member\" = attr . ib () \"\"\"The state of the member before this event\"\"\" after : \"Member\" = attr . ib () \"\"\"The state of the member after this event\"\"\"","title":"MemberUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.RoleCreate","text":"Dispatched when a role is created. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class RoleCreate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a role is created.\"\"\" role : \"Role\" = attr . ib () \"\"\"The created role\"\"\"","title":"RoleCreate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.RoleUpdate","text":"Dispatched when a role is updated. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class RoleUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a role is updated.\"\"\" before : \"Role\" = attr . ib () \"\"\"The role before this event\"\"\" after : \"Role\" = attr . ib () \"\"\"The role after this event\"\"\"","title":"RoleUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.RoleDelete","text":"Dispatched when a guild role is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class RoleDelete ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild role is deleted\"\"\" role_id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the deleted role\"\"\"","title":"RoleDelete"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.GuildMembersChunk","text":"Sent in response to Guild Request Members. You can use the chunk_index and chunk_count to calculate how many chunks are left for your request. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class GuildMembersChunk ( BaseEvent , GuildEvent ): \"\"\"Sent in response to Guild Request Members. You can use the `chunk_index` and `chunk_count` to calculate how many chunks are left for your request.\"\"\" chunk_index : int = attr . ib () \"\"\"The chunk index in the expected chunks for this response (0 <= chunk_index < chunk_count)\"\"\" chunk_count : int = attr . ib () \"\"\"the total number of expected chunks for this response\"\"\" presences : List = attr . ib () \"\"\"if passing true to `REQUEST_GUILD_MEMBERS`, presences of the returned members will be here\"\"\" nonce : str = attr . ib () \"\"\"The nonce used in the request, if any\"\"\" members : List [ \"Member\" ] = attr . ib ( factory = list ) \"\"\"A list of members\"\"\"","title":"GuildMembersChunk"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.IntegrationCreate","text":"Dispatched when a guild integration is created Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class IntegrationCreate ( BaseEvent ): \"\"\"Dispatched when a guild integration is created\"\"\" integration : \"GuildIntegration\" = attr . ib ()","title":"IntegrationCreate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.IntegrationUpdate","text":"Dispatched when a guild integration is updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class IntegrationUpdate ( IntegrationCreate ): \"\"\"Dispatched when a guild integration is updated\"\"\"","title":"IntegrationUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.IntegrationDelete","text":"Dispatched when a guild integration is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class IntegrationDelete ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild integration is deleted\"\"\" id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the integration\"\"\" application_id : \"Snowflake_Type\" = attr . ib ( default = None ) \"\"\"The ID of the bot/application for this integration\"\"\"","title":"IntegrationDelete"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.InviteCreate","text":"Dispatched when a guild invite is created Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class InviteCreate ( BaseEvent ): \"\"\"Dispatched when a guild invite is created\"\"\" invite : Invite = attr . ib ()","title":"InviteCreate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.InviteDelete","text":"Dispatched when an invite is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class InviteDelete ( InviteCreate ): \"\"\"Dispatched when an invite is deleted\"\"\"","title":"InviteDelete"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MessageCreate","text":"Dispatched when a message is created Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageCreate ( BaseEvent ): \"\"\"Dispatched when a message is created\"\"\" message : \"Message\" = attr . ib ()","title":"MessageCreate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MessageUpdate","text":"Dispatched when a message is edited Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageUpdate ( BaseEvent ): \"\"\"Dispatched when a message is edited\"\"\" before : \"Message\" = attr . ib () \"\"\"The message before this event was created\"\"\" after : \"Message\" = attr . ib () \"\"\"The message after this event was created\"\"\"","title":"MessageUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MessageDelete","text":"Dispatched when a message is deleted. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageDelete ( BaseEvent ): \"\"\"Dispatched when a message is deleted.\"\"\" message : \"Message\" = attr . ib ()","title":"MessageDelete"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MessageDeleteBulk","text":"Dispatched when multiple messages are deleted at once. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageDeleteBulk ( BaseEvent , GuildEvent ): \"\"\"Dispatched when multiple messages are deleted at once.\"\"\" channel_id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the channel these were deleted in\"\"\" ids : List [ \"Snowflake_Type\" ] = attr . ib ( factory = list ) \"\"\"A list of message snowflakes\"\"\"","title":"MessageDeleteBulk"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MessageReactionAdd","text":"Dispatched when a reaction is added to a message. Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageReactionAdd ( BaseEvent ): \"\"\"Dispatched when a reaction is added to a message.\"\"\" message : \"Message\" = attr . ib ( metadata = docs ( \"The message that was reacted to\" )) emoji : \"emoji\" = attr . ib ( metadata = docs ( \"The emoji that was added to the message\" )) author : Union [ \"Member\" , \"User\" ] = attr . ib ( metadata = docs ( \"The user who added the reaction\" ))","title":"MessageReactionAdd"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MessageReactionRemove","text":"Dispatched when a reaction is removed Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageReactionRemove ( MessageReactionAdd ): \"\"\"Dispatched when a reaction is removed\"\"\"","title":"MessageReactionRemove"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.MessageReactionRemoveAll","text":"Dispatched when all reactions are removed from a message Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class MessageReactionRemoveAll ( BaseEvent , GuildEvent ): \"\"\"Dispatched when all reactions are removed from a message\"\"\" message : \"Message\" = attr . ib () \"\"\"The message that was reacted to\"\"\"","title":"MessageReactionRemoveAll"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.PresenceUpdate","text":"A user's presence has changed Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class PresenceUpdate ( BaseEvent ): \"\"\"A user's presence has changed\"\"\" user : \"User\" = attr . ib () \"\"\"The user in question\"\"\" status : str = attr . ib () \"\"\"'Either `idle`, `dnd`, `online`, or `offline`'\"\"\" activities : List = attr . ib () \"\"\"The users current activities\"\"\" client_status : dict = attr . ib () \"\"\"What platform the user is reported as being on\"\"\" guild_id : \"Snowflake_Type\" = attr . ib () \"\"\"The guild this presence update was dispatched from\"\"\"","title":"PresenceUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.StageInstanceCreate","text":"Dispatched when a stage instance is created Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class StageInstanceCreate ( BaseEvent ): \"\"\"Dispatched when a stage instance is created\"\"\" stage_instance : StageInstance = attr . ib ( metadata = docs ( \"The stage instance\" ))","title":"StageInstanceCreate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.StageInstanceDelete","text":"Dispatched when a stage instance is deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class StageInstanceDelete ( StageInstanceCreate ): \"\"\"Dispatched when a stage instance is deleted\"\"\"","title":"StageInstanceDelete"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.StageInstanceUpdate","text":"Dispatched when a stage instance is updated Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class StageInstanceUpdate ( StageInstanceCreate ): \"\"\"Dispatched when a stage instance is updated\"\"\"","title":"StageInstanceUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.TypingStart","text":"Dispatched when a user starts typing Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class TypingStart ( BaseEvent ): \"\"\"Dispatched when a user starts typing\"\"\" author : Union [ \"User\" , \"Member\" ] = attr . ib () \"\"\"The user who started typing\"\"\" channel : \"BaseChannel\" = attr . ib () \"\"\"The channel typing is in\"\"\" guild : \"Guild\" = attr . ib () \"\"\"The ID of the guild this typing is in\"\"\" timestamp : \"Timestamp\" = attr . ib () \"\"\"unix time (in seconds) of when the user started typing\"\"\"","title":"TypingStart"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.WebhooksUpdate","text":"Dispatched when a guild channel webhook is created, updated, or deleted Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class WebhooksUpdate ( BaseEvent , GuildEvent ): \"\"\"Dispatched when a guild channel webhook is created, updated, or deleted\"\"\" # Discord doesnt sent the webhook object for this event, for some reason channel_id : \"Snowflake_Type\" = attr . ib () \"\"\"The ID of the webhook was updated\"\"\"","title":"WebhooksUpdate"},{"location":"API%20Reference/models/events/discord/#dis_snek.models.events.discord.InteractionCreate","text":"Dispatched when a user uses an Application Command Source code in dis_snek/models/events/discord.py @attr . s ( slots = True ) class InteractionCreate ( BaseEvent ): \"\"\"Dispatched when a user uses an Application Command\"\"\" interaction : dict = attr . ib ()","title":"InteractionCreate"},{"location":"API%20Reference/models/events/internal/","text":"These are events dispatched by the client. This is intended as a reference so you know what data to expect for each event Example Usage: The event classes outlined here are in CamelCase to comply with Class naming convention, however the event names are actually in lower_case_with_underscores so your listeners should be named as following: 1 2 3 4 5 6 7 8 9 @listen () def on_ready (): # ready events pass no data, so dont have params print ( \"Im ready!\" ) @listen () def on_guild_join ( event ): # guild_create events pass a guild object, expect a single param print ( f \" { event . guild . name } created\" ) Warning While all of these events are documented, not all of them are used, currently. BaseEvent attrs \u00b6 A base event that all other events inherit from Source code in dis_snek/models/events/internal.py @attr . s () class BaseEvent : \"\"\"A base event that all other events inherit from\"\"\" override_name : str = attr . ib ( kw_only = True , default = None ) @property def resolved_name ( self ): name = self . override_name or self . __class__ . __name__ return _event_reg . sub ( \"_\" , name ) . lower () GuildEvent attrs \u00b6 A base event that adds guild_id Source code in dis_snek/models/events/internal.py @attr . s () class GuildEvent : \"\"\"A base event that adds guild_id\"\"\" guild_id : \"Snowflake_Type\" = attr . ib ( metadata = docs ( \"The ID of the guild\" ), converter = to_snowflake ) attrs-field guild_id : Snowflake_Type \u00b6 The ID of the guild Login ( BaseEvent ) attrs \u00b6 The bot has just logged in Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Login ( BaseEvent ): \"\"\"The bot has just logged in\"\"\" Connect ( BaseEvent ) attrs \u00b6 The bot is now connected to the discord Gateway. Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Connect ( BaseEvent ): \"\"\"The bot is now connected to the discord Gateway.\"\"\" Resume ( BaseEvent ) attrs \u00b6 The bot has resumed its connection to the discord Gateway Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Resume ( BaseEvent ): \"\"\"The bot has resumed its connection to the discord Gateway\"\"\" Disconnect ( BaseEvent ) attrs \u00b6 The bot has just disconnected. Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Disconnect ( BaseEvent ): \"\"\"The bot has just disconnected.\"\"\" Ready ( BaseEvent ) attrs \u00b6 The client is now ready. Note Don't use this event for things that must only happen once, on startup, as this event may be called multiple times. Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Ready ( BaseEvent ): \"\"\"The client is now ready. Note: Don't use this event for things that must only happen once, on startup, as this event may be called multiple times. \"\"\" WebsocketReady ( BaseEvent ) attrs \u00b6 The gateway has reported that it is ready Source code in dis_snek/models/events/internal.py class WebsocketReady ( BaseEvent ): \"\"\"The gateway has reported that it is ready\"\"\" Component ( BaseEvent ) attrs \u00b6 Dispatched when a user uses a Component Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Component ( BaseEvent ): \"\"\"Dispatched when a user uses a Component\"\"\" context : \"ComponentContext\" = attr . ib ( metadata = docs ( \"The context of the interaction\" )) attrs-field context : ComponentContext \u00b6 The context of the interaction Button ( Component ) attrs \u00b6 Dispatched when a user uses a Button Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Button ( Component ): \"\"\"Dispatched when a user uses a Button\"\"\" attrs-field inherited context : ComponentContext \u00b6 The context of the interaction Select ( Component ) attrs \u00b6 Dispatched when a user uses a Select Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Select ( Component ): \"\"\"Dispatched when a user uses a Select\"\"\" attrs-field inherited context : ComponentContext \u00b6 The context of the interaction","title":"Internal"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.BaseEvent","text":"A base event that all other events inherit from Source code in dis_snek/models/events/internal.py @attr . s () class BaseEvent : \"\"\"A base event that all other events inherit from\"\"\" override_name : str = attr . ib ( kw_only = True , default = None ) @property def resolved_name ( self ): name = self . override_name or self . __class__ . __name__ return _event_reg . sub ( \"_\" , name ) . lower ()","title":"BaseEvent"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.GuildEvent","text":"A base event that adds guild_id Source code in dis_snek/models/events/internal.py @attr . s () class GuildEvent : \"\"\"A base event that adds guild_id\"\"\" guild_id : \"Snowflake_Type\" = attr . ib ( metadata = docs ( \"The ID of the guild\" ), converter = to_snowflake )","title":"GuildEvent"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.Login","text":"The bot has just logged in Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Login ( BaseEvent ): \"\"\"The bot has just logged in\"\"\"","title":"Login"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.Connect","text":"The bot is now connected to the discord Gateway. Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Connect ( BaseEvent ): \"\"\"The bot is now connected to the discord Gateway.\"\"\"","title":"Connect"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.Resume","text":"The bot has resumed its connection to the discord Gateway Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Resume ( BaseEvent ): \"\"\"The bot has resumed its connection to the discord Gateway\"\"\"","title":"Resume"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.Disconnect","text":"The bot has just disconnected. Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Disconnect ( BaseEvent ): \"\"\"The bot has just disconnected.\"\"\"","title":"Disconnect"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.Ready","text":"The client is now ready. Note Don't use this event for things that must only happen once, on startup, as this event may be called multiple times. Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Ready ( BaseEvent ): \"\"\"The client is now ready. Note: Don't use this event for things that must only happen once, on startup, as this event may be called multiple times. \"\"\"","title":"Ready"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.WebsocketReady","text":"The gateway has reported that it is ready Source code in dis_snek/models/events/internal.py class WebsocketReady ( BaseEvent ): \"\"\"The gateway has reported that it is ready\"\"\"","title":"WebsocketReady"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.Component","text":"Dispatched when a user uses a Component Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Component ( BaseEvent ): \"\"\"Dispatched when a user uses a Component\"\"\" context : \"ComponentContext\" = attr . ib ( metadata = docs ( \"The context of the interaction\" ))","title":"Component"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.Button","text":"Dispatched when a user uses a Button Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Button ( Component ): \"\"\"Dispatched when a user uses a Button\"\"\"","title":"Button"},{"location":"API%20Reference/models/events/internal/#dis_snek.models.events.internal.Select","text":"Dispatched when a user uses a Select Source code in dis_snek/models/events/internal.py @attr . s ( slots = True ) class Select ( Component ): \"\"\"Dispatched when a user uses a Select\"\"\"","title":"Select"},{"location":"API%20Reference/utils/attr/","text":"docs ( doc_string ) \u00b6 Makes it easier to quickly type attr documentation Source code in dis_snek/utils/attr_utils.py def docs ( doc_string : str ) -> Dict [ str , str ]: \"\"\"Makes it easier to quickly type attr documentation\"\"\" return { \"docs\" : doc_string }","title":"Attr"},{"location":"API%20Reference/utils/attr/#dis_snek.utils.attr_utils.docs","text":"Makes it easier to quickly type attr documentation Source code in dis_snek/utils/attr_utils.py def docs ( doc_string : str ) -> Dict [ str , str ]: \"\"\"Makes it easier to quickly type attr documentation\"\"\" return { \"docs\" : doc_string }","title":"docs()"},{"location":"API%20Reference/utils/cache/","text":"TTLCache ( OrderedDict ) \u00b6 Source code in dis_snek/utils/cache.py class TTLCache ( OrderedDict ): def __init__ ( self , ttl = 600 , soft_limit = 50 , hard_limit = 250 , on_expire = None ): super () . __init__ () self . ttl = ttl self . hard_limit = hard_limit self . soft_limit = min ( soft_limit , hard_limit ) self . on_expire = on_expire def __setitem__ ( self , key , value ): expire = time . monotonic () + self . ttl item = TTLItem ( value , expire ) super () . __setitem__ ( key , item ) self . move_to_end ( key ) self . expire () def __getitem__ ( self , key ): # Will not (should not) reset expiration! item = super () . __getitem__ ( key ) # self._reset_expiration(key, item) return item . value def pop ( self , key , default = attr . NOTHING ): if key in self : item = self [ key ] del self [ key ] return item . value if default is attr . NOTHING : raise KeyError ( key ) return default def get ( self , key , default = None , reset_expiration = True ): item = super () . get ( key , default ) if item is not default : if reset_expiration : self . _reset_expiration ( key , item ) return item . value return default def values ( self ): return _CacheValuesView ( self ) def items ( self ): return _CacheItemsView ( self ) def _reset_expiration ( self , key : Any , item : TTLItem ): self . move_to_end ( key ) item . expire = time . monotonic () + self . ttl def _first_item ( self ): return next ( super () . items () . __iter__ ()) def expire ( self ): \"\"\"Removes expired elements from the cache\"\"\" if self . soft_limit and len ( self ) <= self . soft_limit : return if self . hard_limit : while len ( self ) > self . hard_limit : self . _expire_first () timestamp = time . monotonic () while True : key , item = self . _first_item () if item . is_expired ( timestamp ): self . _expire_first () else : break def _expire_first ( self ): key , value = self . popitem ( last = False ) if self . on_expire : self . on_expire ( key , value ) pop ( self , key , default = NOTHING ) \u00b6 od.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Source code in dis_snek/utils/cache.py def pop ( self , key , default = attr . NOTHING ): if key in self : item = self [ key ] del self [ key ] return item . value if default is attr . NOTHING : raise KeyError ( key ) return default get ( self , key , default = None , reset_expiration = True ) \u00b6 Return the value for key if key is in the dictionary, else default. Source code in dis_snek/utils/cache.py def get ( self , key , default = None , reset_expiration = True ): item = super () . get ( key , default ) if item is not default : if reset_expiration : self . _reset_expiration ( key , item ) return item . value return default values ( self ) \u00b6 D.values() -> an object providing a view on D's values Source code in dis_snek/utils/cache.py def values ( self ): return _CacheValuesView ( self ) items ( self ) \u00b6 D.items() -> a set-like object providing a view on D's items Source code in dis_snek/utils/cache.py def items ( self ): return _CacheItemsView ( self ) expire ( self ) \u00b6 Removes expired elements from the cache Source code in dis_snek/utils/cache.py def expire ( self ): \"\"\"Removes expired elements from the cache\"\"\" if self . soft_limit and len ( self ) <= self . soft_limit : return if self . hard_limit : while len ( self ) > self . hard_limit : self . _expire_first () timestamp = time . monotonic () while True : key , item = self . _first_item () if item . is_expired ( timestamp ): self . _expire_first () else : break","title":"Cache"},{"location":"API%20Reference/utils/cache/#dis_snek.utils.cache.TTLCache","text":"Source code in dis_snek/utils/cache.py class TTLCache ( OrderedDict ): def __init__ ( self , ttl = 600 , soft_limit = 50 , hard_limit = 250 , on_expire = None ): super () . __init__ () self . ttl = ttl self . hard_limit = hard_limit self . soft_limit = min ( soft_limit , hard_limit ) self . on_expire = on_expire def __setitem__ ( self , key , value ): expire = time . monotonic () + self . ttl item = TTLItem ( value , expire ) super () . __setitem__ ( key , item ) self . move_to_end ( key ) self . expire () def __getitem__ ( self , key ): # Will not (should not) reset expiration! item = super () . __getitem__ ( key ) # self._reset_expiration(key, item) return item . value def pop ( self , key , default = attr . NOTHING ): if key in self : item = self [ key ] del self [ key ] return item . value if default is attr . NOTHING : raise KeyError ( key ) return default def get ( self , key , default = None , reset_expiration = True ): item = super () . get ( key , default ) if item is not default : if reset_expiration : self . _reset_expiration ( key , item ) return item . value return default def values ( self ): return _CacheValuesView ( self ) def items ( self ): return _CacheItemsView ( self ) def _reset_expiration ( self , key : Any , item : TTLItem ): self . move_to_end ( key ) item . expire = time . monotonic () + self . ttl def _first_item ( self ): return next ( super () . items () . __iter__ ()) def expire ( self ): \"\"\"Removes expired elements from the cache\"\"\" if self . soft_limit and len ( self ) <= self . soft_limit : return if self . hard_limit : while len ( self ) > self . hard_limit : self . _expire_first () timestamp = time . monotonic () while True : key , item = self . _first_item () if item . is_expired ( timestamp ): self . _expire_first () else : break def _expire_first ( self ): key , value = self . popitem ( last = False ) if self . on_expire : self . on_expire ( key , value )","title":"TTLCache"},{"location":"API%20Reference/utils/converters/","text":"","title":"Converters"},{"location":"API%20Reference/utils/input_utils/","text":"async response_decode ( response ) \u00b6 Return the response text in its correct format, be it dict, or string. Parameters: Name Type Description Default response ClientResponse the aiohttp response required Returns: Type Description Union[Dict[str, Any], str] the response text field in its correct type Source code in dis_snek/utils/input_utils.py async def response_decode ( response : aiohttp . ClientResponse ) -> Union [ Dict [ str , Any ], str ]: \"\"\" Return the response text in its correct format, be it dict, or string. Args: response: the aiohttp response Returns: the response text field in its correct type \"\"\" text = await response . text ( encoding = \"utf-8\" ) if response . headers . get ( \"content-type\" ) == \"application/json\" : return OverriddenJson . loads ( text ) return text get_args ( text ) \u00b6 Get arguments from an input text. Parameters: Name Type Description Default text str The text to process required Returns: Type Description A list of words Source code in dis_snek/utils/input_utils.py def get_args ( text : str ): \"\"\" Get arguments from an input text. Args: text: The text to process Returns: A list of words \"\"\" return arg_parse . findall ( text ) get_first_word ( text ) \u00b6 Get a the first word in a string, regardless of whitespace type. Parameters: Name Type Description Default text str The text to process required Returns: Type Description The requested word Source code in dis_snek/utils/input_utils.py def get_first_word ( text : str ): \"\"\" Get a the first word in a string, regardless of whitespace type. Args: text: The text to process Returns: The requested word \"\"\" found = initial_word . findall ( text ) if len ( found ) == 0 : return None return found [ 0 ]","title":"Input utils"},{"location":"API%20Reference/utils/input_utils/#dis_snek.utils.input_utils.response_decode","text":"Return the response text in its correct format, be it dict, or string. Parameters: Name Type Description Default response ClientResponse the aiohttp response required Returns: Type Description Union[Dict[str, Any], str] the response text field in its correct type Source code in dis_snek/utils/input_utils.py async def response_decode ( response : aiohttp . ClientResponse ) -> Union [ Dict [ str , Any ], str ]: \"\"\" Return the response text in its correct format, be it dict, or string. Args: response: the aiohttp response Returns: the response text field in its correct type \"\"\" text = await response . text ( encoding = \"utf-8\" ) if response . headers . get ( \"content-type\" ) == \"application/json\" : return OverriddenJson . loads ( text ) return text","title":"response_decode()"},{"location":"API%20Reference/utils/input_utils/#dis_snek.utils.input_utils.get_args","text":"Get arguments from an input text. Parameters: Name Type Description Default text str The text to process required Returns: Type Description A list of words Source code in dis_snek/utils/input_utils.py def get_args ( text : str ): \"\"\" Get arguments from an input text. Args: text: The text to process Returns: A list of words \"\"\" return arg_parse . findall ( text )","title":"get_args()"},{"location":"API%20Reference/utils/input_utils/#dis_snek.utils.input_utils.get_first_word","text":"Get a the first word in a string, regardless of whitespace type. Parameters: Name Type Description Default text str The text to process required Returns: Type Description The requested word Source code in dis_snek/utils/input_utils.py def get_first_word ( text : str ): \"\"\" Get a the first word in a string, regardless of whitespace type. Args: text: The text to process Returns: The requested word \"\"\" found = initial_word . findall ( text ) if len ( found ) == 0 : return None return found [ 0 ]","title":"get_first_word()"},{"location":"API%20Reference/utils/misc/","text":"escape_mentions ( content ) \u00b6 Escape mentions that could ping someone in a string Note This does not escape channel mentions as they do not ping anybody Parameters: Name Type Description Default content str The string to escape required Returns: Type Description str Processed string Source code in dis_snek/utils/misc_utils.py def escape_mentions ( content : str ) -> str : \"\"\" Escape mentions that could ping someone in a string note: This does not escape channel mentions as they do not ping anybody Args: content: The string to escape Returns: Processed string \"\"\" return mention_reg . sub ( \"@ \\u200b\\\\ 1\" , content ) find ( predicate , sequence ) \u00b6 Find the first element in a sequence that matches the predicate. Example Usage: 1 member = find ( lambda m : m . name == \"UserName\" , guild . members ) Parameters: Name Type Description Default predicate Callable A callable that returns a boolean value required sequence Iterable A sequence to be searched required Returns: Type Description Optional[Any] A match if found, otherwise None Source code in dis_snek/utils/misc_utils.py def find ( predicate : Callable , sequence : Iterable ) -> Optional [ Any ]: \"\"\" Find the first element in a sequence that matches the predicate. ??? Hint \"Example Usage:\" ```python member = find(lambda m: m.name == \"UserName\", guild.members) ``` Args: predicate: A callable that returns a boolean value sequence: A sequence to be searched Returns: A match if found, otherwise None \"\"\" for el in sequence : if predicate ( el ): return el return None wrap_partial ( obj , cls ) \u00b6 \ud83c\udf81 Wraps a commands callback objects into partials Note This is used internally, you shouldn't need to use this function Parameters: Name Type Description Default obj The command object to process required cls The class to use in partials required Returns: Type Description The original command object with its callback methods wrapped Source code in dis_snek/utils/misc_utils.py def wrap_partial ( obj , cls ): \"\"\" \ud83c\udf81 Wraps a commands callback objects into partials !!! note This is used internally, you shouldn't need to use this function Args: obj: The command object to process cls: The class to use in partials Returns: The original command object with its callback methods wrapped \"\"\" if isinstance ( obj . callback , functools . partial ): return obj if \"_no_wrap\" not in getattr ( obj . callback , \"__name__\" , \"\" ): obj . callback = functools . partial ( obj . callback , cls ) if getattr ( obj , \"error_callback\" , None ): obj . error_callback = functools . partial ( obj . error_callback , cls ) if getattr ( obj , \"pre_run_callback\" , None ): obj . pre_run_callback = functools . partial ( obj . pre_run_callback , cls ) if getattr ( obj , \"post_run_callback\" , None ): obj . post_run_callback = functools . partial ( obj . post_run_callback , cls ) if getattr ( obj , \"autocomplete_callbacks\" , None ): obj . autocomplete_callbacks = { k : functools . partial ( v , cls ) for k , v in obj . autocomplete_callbacks . items ()} if getattr ( obj , \"subcommands\" , None ): obj . subcommands = { k : wrap_partial ( v , cls ) for k , v in obj . subcommands . items ()} return obj","title":"Misc"},{"location":"API%20Reference/utils/misc/#dis_snek.utils.misc_utils.escape_mentions","text":"Escape mentions that could ping someone in a string Note This does not escape channel mentions as they do not ping anybody Parameters: Name Type Description Default content str The string to escape required Returns: Type Description str Processed string Source code in dis_snek/utils/misc_utils.py def escape_mentions ( content : str ) -> str : \"\"\" Escape mentions that could ping someone in a string note: This does not escape channel mentions as they do not ping anybody Args: content: The string to escape Returns: Processed string \"\"\" return mention_reg . sub ( \"@ \\u200b\\\\ 1\" , content )","title":"escape_mentions()"},{"location":"API%20Reference/utils/misc/#dis_snek.utils.misc_utils.find","text":"Find the first element in a sequence that matches the predicate. Example Usage: 1 member = find ( lambda m : m . name == \"UserName\" , guild . members ) Parameters: Name Type Description Default predicate Callable A callable that returns a boolean value required sequence Iterable A sequence to be searched required Returns: Type Description Optional[Any] A match if found, otherwise None Source code in dis_snek/utils/misc_utils.py def find ( predicate : Callable , sequence : Iterable ) -> Optional [ Any ]: \"\"\" Find the first element in a sequence that matches the predicate. ??? Hint \"Example Usage:\" ```python member = find(lambda m: m.name == \"UserName\", guild.members) ``` Args: predicate: A callable that returns a boolean value sequence: A sequence to be searched Returns: A match if found, otherwise None \"\"\" for el in sequence : if predicate ( el ): return el return None","title":"find()"},{"location":"API%20Reference/utils/misc/#dis_snek.utils.misc_utils.wrap_partial","text":"\ud83c\udf81 Wraps a commands callback objects into partials Note This is used internally, you shouldn't need to use this function Parameters: Name Type Description Default obj The command object to process required cls The class to use in partials required Returns: Type Description The original command object with its callback methods wrapped Source code in dis_snek/utils/misc_utils.py def wrap_partial ( obj , cls ): \"\"\" \ud83c\udf81 Wraps a commands callback objects into partials !!! note This is used internally, you shouldn't need to use this function Args: obj: The command object to process cls: The class to use in partials Returns: The original command object with its callback methods wrapped \"\"\" if isinstance ( obj . callback , functools . partial ): return obj if \"_no_wrap\" not in getattr ( obj . callback , \"__name__\" , \"\" ): obj . callback = functools . partial ( obj . callback , cls ) if getattr ( obj , \"error_callback\" , None ): obj . error_callback = functools . partial ( obj . error_callback , cls ) if getattr ( obj , \"pre_run_callback\" , None ): obj . pre_run_callback = functools . partial ( obj . pre_run_callback , cls ) if getattr ( obj , \"post_run_callback\" , None ): obj . post_run_callback = functools . partial ( obj . post_run_callback , cls ) if getattr ( obj , \"autocomplete_callbacks\" , None ): obj . autocomplete_callbacks = { k : functools . partial ( v , cls ) for k , v in obj . autocomplete_callbacks . items ()} if getattr ( obj , \"subcommands\" , None ): obj . subcommands = { k : wrap_partial ( v , cls ) for k , v in obj . subcommands . items ()} return obj","title":"wrap_partial()"},{"location":"API%20Reference/utils/serializer/","text":"","title":"Serializer"},{"location":"Guides/1%20Getting%20Started/","text":"Introduction \u00b6 Hi! So you want to make a bot powered by snakes. This guide aims to get you started as fast as possible, for more advanced use-cases check out the other guides. Requirements \u00b6 Python 3.9 or greater Know how to use pip A bot account An aversion to snakes Installation \u00b6 Virtual-Environments \u00b6 We strongly recommend that you make use of Virtual Environments when working on any project. This means that each project will have its own libraries of any version and does not affect anything else on your system. Don't worry, this isn't setting up a full-fledged virtual machine, just small python environment. Linux Windows 1 2 3 cd \"[your bots directory]\" python3 -m venv venv source venv/bin/activate 1 2 3 cd \"[your bots directory]\" py -3 -m venv venv venv/Scripts/activate It's that simple, now you're using a virtual environment. If you want to leave the environment just type deactivate . If you want to learn more about the virtual environments, check out this page Pip install \u00b6 Now let's get the library installed. Linux Windows 1 python3 -m pip install dis_snek --upgrade 1 py -3 -m install dis_snek --upgrade Basic bot \u00b6 Now let's get a basic bot going, for your code, you'll want something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from dis_snek.client import Snake from dis_snek.models.enums import Intents from dis_snek.models.listener import listen bot = Snake ( intents = Intents . DEFAULT ) # intents are what events we want to receive from discord, `DEFAULT` is usually fine @listen () # this decorator tells snek that it needs to listen for the corresponding event, and run this coroutine async def on_ready (): # This event is called when the bot is ready to respond to commands print ( \"Ready\" ) print ( f \"This bot is owned by { bot . owner } \" ) @listen () async def on_message_create ( event ): # This event is called when a message is sent in a channel the bot can see print ( f \"message received: { event . message . content } \" ) bot . start ( \"Put your token here\" ) Congratulations! You now have a basic understanding of this library. If you have any questions check out our other guides, or join the Discord Server For more examples, check out the examples page","title":"Introduction"},{"location":"Guides/1%20Getting%20Started/#introduction","text":"Hi! So you want to make a bot powered by snakes. This guide aims to get you started as fast as possible, for more advanced use-cases check out the other guides.","title":"Introduction"},{"location":"Guides/1%20Getting%20Started/#installation","text":"","title":"Installation"},{"location":"Guides/1%20Getting%20Started/#basic-bot","text":"Now let's get a basic bot going, for your code, you'll want something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from dis_snek.client import Snake from dis_snek.models.enums import Intents from dis_snek.models.listener import listen bot = Snake ( intents = Intents . DEFAULT ) # intents are what events we want to receive from discord, `DEFAULT` is usually fine @listen () # this decorator tells snek that it needs to listen for the corresponding event, and run this coroutine async def on_ready (): # This event is called when the bot is ready to respond to commands print ( \"Ready\" ) print ( f \"This bot is owned by { bot . owner } \" ) @listen () async def on_message_create ( event ): # This event is called when a message is sent in a channel the bot can see print ( f \"message received: { event . message . content } \" ) bot . start ( \"Put your token here\" ) Congratulations! You now have a basic understanding of this library. If you have any questions check out our other guides, or join the Discord Server For more examples, check out the examples page","title":"Basic bot"},{"location":"Guides/Creating%20Your%20Bot/","text":"Creating your bot! \u00b6 To make a bot on Discord, you must first create an application on Discord. Thankfully, discord has made this process very simple. You Login to the Discord website Navigate to the Developer Application page Press New Application Give your application a name, and press Create Note Don't worry if there isnt a team option, this only appears if you have a developer team. If you have a team and want to assign your bot to it, use this. In the Bot tab, press Add bot You now have a bot! Youre going to want to press Click to Reveal Token to get your bot's token, so you can start coding Warning: Do not share your token! Think of this token as your bots username and password in one. You should never share this with someone else. If someone has your token, they can do absolutely anything with your bot, from banning every member in every server to leaving every server your bot is in. If you think you have leaked your token, press Regenerate on the same page you copy your token on, this will revoke your token (logging out all exisitng sessions), and generate a new token for you. Github will automatically revoke your token if you accidently commit it, but dont rely on this as a crutch, keep your token safe. Inviting your bot! \u00b6 So you've created a bot, but it's not in a server yet. Lets fix that. On the Developer Application page from above, select your bot Navigate to the OAuth2 tab Scroll down to the Oauth2 URL Generator . This is where we're going to create our invite link Select the bot option, and if you want to use application commands, select applications.commands as well If your bot needs any special permissions, select those below Now you have an invite link! Simply use this to invite your bot. Note You need manage server permissions to add a bot to a server","title":"Creating Your Bot"},{"location":"Guides/Creating%20Your%20Bot/#creating-your-bot","text":"To make a bot on Discord, you must first create an application on Discord. Thankfully, discord has made this process very simple. You Login to the Discord website Navigate to the Developer Application page Press New Application Give your application a name, and press Create Note Don't worry if there isnt a team option, this only appears if you have a developer team. If you have a team and want to assign your bot to it, use this. In the Bot tab, press Add bot You now have a bot! Youre going to want to press Click to Reveal Token to get your bot's token, so you can start coding Warning: Do not share your token! Think of this token as your bots username and password in one. You should never share this with someone else. If someone has your token, they can do absolutely anything with your bot, from banning every member in every server to leaving every server your bot is in. If you think you have leaked your token, press Regenerate on the same page you copy your token on, this will revoke your token (logging out all exisitng sessions), and generate a new token for you. Github will automatically revoke your token if you accidently commit it, but dont rely on this as a crutch, keep your token safe.","title":"Creating your bot!"},{"location":"Guides/Creating%20Your%20Bot/#inviting-your-bot","text":"So you've created a bot, but it's not in a server yet. Lets fix that. On the Developer Application page from above, select your bot Navigate to the OAuth2 tab Scroll down to the Oauth2 URL Generator . This is where we're going to create our invite link Select the bot option, and if you want to use application commands, select applications.commands as well If your bot needs any special permissions, select those below Now you have an invite link! Simply use this to invite your bot. Note You need manage server permissions to add a bot to a server","title":"Inviting your bot!"},{"location":"Guides/Migration%20From%20D.py/","text":"Notice This page is a placeholder, and will be populated at a later date.","title":"Migration From D.py"},{"location":"Guides/example/","text":"main.py \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import logging import dis_snek.const from dis_snek.client import Snake from dis_snek.models.context import ComponentContext from dis_snek.models.enums import Intents from dis_snek.models.events import Component from dis_snek.models.listener import listen logging . basicConfig () cls_log = logging . getLogger ( dis_snek . const . logger_name ) cls_log . setLevel ( logging . DEBUG ) bot = Snake ( intents = Intents . DEFAULT , sync_interactions = True , asyncio_debug = True ) @listen () async def on_ready (): print ( \"Ready\" ) print ( f \"This bot is owned by { bot . owner } \" ) @listen () async def on_guild_create ( event ): print ( f \"guild created : { event . guild . name } \" ) @listen () async def on_message_create ( event ): print ( f \"message received: { event . message . content } \" ) @listen () async def on_component ( event : Component ): ctx = event . context await ctx . edit_origin ( \"test\" ) bot . load_extension ( \"test_components\" ) bot . load_extension ( \"test_application_commands\" ) bot . start ( \"Token\" ) test_components.py \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from dis_snek.models.command import message_command from dis_snek.models.discord_objects.components import Button , ActionRow from dis_snek.models.enums import ButtonStyles from dis_snek.models.scale import Scale class ButtonExampleSkin ( Scale ): @message_command () async def blurple_button ( self , ctx ): await ctx . send ( \"hello there\" , components = Button ( ButtonStyles . BLURPLE , \"A blurple button\" )) @message_command () async def multiple_buttons ( self , ctx ): await ctx . send ( \"2 buttons in a row\" , components = [ Button ( ButtonStyles . BLURPLE , \"A blurple button\" ), Button ( ButtonStyles . RED , \"A red button\" )], ) @message_command () async def action_rows ( self , ctx ): await ctx . send ( \"2 buttons in 2 rows, using nested lists\" , components = [[ Button ( ButtonStyles . BLURPLE , \"A blurple button\" )], [ Button ( ButtonStyles . RED , \"A red button\" )]], ) @message_command () async def action_rows_more ( self , ctx ): await ctx . send ( \"2 buttons in 2 rows, using explicit action_rows lists\" , components = [ ActionRow ( Button ( ButtonStyles . BLURPLE , \"A blurple button\" )), ActionRow ( Button ( ButtonStyles . RED , \"A red button\" )), ], ) def setup ( bot ): ButtonExampleSkin ( bot ) test_application_commands.py \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from dis_snek.models.application_commands import slash_command , slash_option , context_menu from dis_snek.models.discord_objects.components import Button , ActionRow from dis_snek.models.context import InteractionContext from dis_snek.models.enums import CommandTypes from dis_snek.models.scale import Scale class CommandsExampleSkin ( Scale ): @slash_command ( \"command\" , description = \"This is a test\" , scopes = 701347683591389185 ) @slash_option ( \"another\" , \"str option\" , 3 , required = True ) @slash_option ( \"option\" , \"int option\" , 4 , required = True ) async def command ( self , ctx : InteractionContext , ** kwargs ): await ctx . send ( str ( ctx . resolved )) await ctx . send ( f \"Test: { kwargs } \" , components = [ ActionRow ( Button ( 1 , \"Test\" ))]) print ( ctx . resolved ) @command . error async def command_error ( self , e , * args , ** kwargs ): print ( f \"Command hit error with { args =} , { kwargs =} \" ) @command . pre_run async def command_pre_run ( self , context , * args , ** kwargs ): print ( \"I ran before the command did!\" ) @context_menu ( name = \"user menu\" , context_type = CommandTypes . USER , scopes = 701347683591389185 ) async def user_context ( self , ctx ): await ctx . send ( \"Context menu:: user\" ) def setup ( bot ): CommandsExampleSkin ( bot )","title":"Example"},{"location":"Guides/example/#mainpy","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import logging import dis_snek.const from dis_snek.client import Snake from dis_snek.models.context import ComponentContext from dis_snek.models.enums import Intents from dis_snek.models.events import Component from dis_snek.models.listener import listen logging . basicConfig () cls_log = logging . getLogger ( dis_snek . const . logger_name ) cls_log . setLevel ( logging . DEBUG ) bot = Snake ( intents = Intents . DEFAULT , sync_interactions = True , asyncio_debug = True ) @listen () async def on_ready (): print ( \"Ready\" ) print ( f \"This bot is owned by { bot . owner } \" ) @listen () async def on_guild_create ( event ): print ( f \"guild created : { event . guild . name } \" ) @listen () async def on_message_create ( event ): print ( f \"message received: { event . message . content } \" ) @listen () async def on_component ( event : Component ): ctx = event . context await ctx . edit_origin ( \"test\" ) bot . load_extension ( \"test_components\" ) bot . load_extension ( \"test_application_commands\" ) bot . start ( \"Token\" )","title":"main.py"},{"location":"Guides/example/#test_componentspy","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from dis_snek.models.command import message_command from dis_snek.models.discord_objects.components import Button , ActionRow from dis_snek.models.enums import ButtonStyles from dis_snek.models.scale import Scale class ButtonExampleSkin ( Scale ): @message_command () async def blurple_button ( self , ctx ): await ctx . send ( \"hello there\" , components = Button ( ButtonStyles . BLURPLE , \"A blurple button\" )) @message_command () async def multiple_buttons ( self , ctx ): await ctx . send ( \"2 buttons in a row\" , components = [ Button ( ButtonStyles . BLURPLE , \"A blurple button\" ), Button ( ButtonStyles . RED , \"A red button\" )], ) @message_command () async def action_rows ( self , ctx ): await ctx . send ( \"2 buttons in 2 rows, using nested lists\" , components = [[ Button ( ButtonStyles . BLURPLE , \"A blurple button\" )], [ Button ( ButtonStyles . RED , \"A red button\" )]], ) @message_command () async def action_rows_more ( self , ctx ): await ctx . send ( \"2 buttons in 2 rows, using explicit action_rows lists\" , components = [ ActionRow ( Button ( ButtonStyles . BLURPLE , \"A blurple button\" )), ActionRow ( Button ( ButtonStyles . RED , \"A red button\" )), ], ) def setup ( bot ): ButtonExampleSkin ( bot )","title":"test_components.py"},{"location":"Guides/example/#test_application_commandspy","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from dis_snek.models.application_commands import slash_command , slash_option , context_menu from dis_snek.models.discord_objects.components import Button , ActionRow from dis_snek.models.context import InteractionContext from dis_snek.models.enums import CommandTypes from dis_snek.models.scale import Scale class CommandsExampleSkin ( Scale ): @slash_command ( \"command\" , description = \"This is a test\" , scopes = 701347683591389185 ) @slash_option ( \"another\" , \"str option\" , 3 , required = True ) @slash_option ( \"option\" , \"int option\" , 4 , required = True ) async def command ( self , ctx : InteractionContext , ** kwargs ): await ctx . send ( str ( ctx . resolved )) await ctx . send ( f \"Test: { kwargs } \" , components = [ ActionRow ( Button ( 1 , \"Test\" ))]) print ( ctx . resolved ) @command . error async def command_error ( self , e , * args , ** kwargs ): print ( f \"Command hit error with { args =} , { kwargs =} \" ) @command . pre_run async def command_pre_run ( self , context , * args , ** kwargs ): print ( \"I ran before the command did!\" ) @context_menu ( name = \"user menu\" , context_type = CommandTypes . USER , scopes = 701347683591389185 ) async def user_context ( self , ctx ): await ctx . send ( \"Context menu:: user\" ) def setup ( bot ): CommandsExampleSkin ( bot )","title":"test_application_commands.py"},{"location":"Guides/scales/","text":"Scales \u00b6 Damn, your code is getting pretty messy now, huh? Wouldn't it be nice if you could organise your commands and listeners into separate files? Well let me introduce you to Scales Scales allow you to split your commands and listeners into separate files to allow you to better organise your project, as well as that, they allow you to reload Scales without having to shut down your bot. Sounds pretty good right? Well lets go over how you can use them: Usage \u00b6 Below is an example of a bot, one with scales, one without. Example Usage: Without Scales With Scales 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 # File: `main.py` import logging import dis_snek.const from dis_snek.client import Snake from dis_snek.models.application_commands import slash_command , slash_option from dis_snek.models.command import message_command from dis_snek.models.context import InteractionContext from dis_snek.models.discord_objects.components import Button , ActionRow from dis_snek.models.enums import ButtonStyles from dis_snek.models.enums import Intents from dis_snek.models.events import Component from dis_snek.models.listener import listen logging . basicConfig () cls_log = logging . getLogger ( dis_snek . const . logger_name ) cls_log . setLevel ( logging . DEBUG ) bot = Snake ( intents = Intents . DEFAULT , sync_interactions = True , asyncio_debug = True ) @listen () async def on_ready (): print ( \"Ready\" ) print ( f \"This bot is owned by { bot . owner } \" ) @listen () async def on_guild_create ( event ): print ( f \"guild created : { event . guild . name } \" ) @listen () async def on_message_create ( event ): print ( f \"message received: { event . message . content } \" ) @listen () async def on_component ( event : Component ): ctx = event . context await ctx . edit_origin ( \"test\" ) @message_command () async def multiple_buttons ( ctx ): await ctx . send ( \"2 buttons in a row\" , components = [ Button ( ButtonStyles . BLURPLE , \"A blurple button\" ), Button ( ButtonStyles . RED , \"A red button\" )], ) @message_command () async def action_rows ( ctx ): await ctx . send ( \"2 buttons in 2 rows, using nested lists\" , components = [[ Button ( ButtonStyles . BLURPLE , \"A blurple button\" )], [ Button ( ButtonStyles . RED , \"A red button\" )]], ) @message_command () async def action_rows_more ( ctx ): await ctx . send ( \"2 buttons in 2 rows, using explicit action_rows lists\" , components = [ ActionRow ( Button ( ButtonStyles . BLURPLE , \"A blurple button\" )), ActionRow ( Button ( ButtonStyles . RED , \"A red button\" )), ], ) bot . start ( \"Token\" ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # File: `main.py` import logging import dis_snek.const from dis_snek.client import Snake from dis_snek.models.context import ComponentContext from dis_snek.models.enums import Intents from dis_snek.models.events import Component from dis_snek.models.listener import listen logging . basicConfig () cls_log = logging . getLogger ( dis_snek . const . logger_name ) cls_log . setLevel ( logging . DEBUG ) bot = Snake ( intents = Intents . DEFAULT , sync_interactions = True , asyncio_debug = True ) @listen () async def on_ready (): print ( \"Ready\" ) print ( f \"This bot is owned by { bot . owner } \" ) @listen () async def on_guild_create ( event ): print ( f \"guild created : { event . guild . name } \" ) @listen () async def on_message_create ( event ): print ( f \"message received: { event . message . content } \" ) @listen () async def on_component ( event : Component ): ctx = event . context await ctx . edit_origin ( \"test\" ) bot . grow_scale ( \"test_components\" ) bot . start ( \"Token\" ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # File: `test_components.py` from dis_snek.models.command import message_command from dis_snek.models.discord_objects.components import Button , ActionRow from dis_snek.models.enums import ButtonStyles from dis_snek.models.scale import Scale class ButtonExampleSkin ( Scale ): @message_command () async def blurple_button ( self , ctx ): await ctx . send ( \"hello there\" , components = Button ( ButtonStyles . BLURPLE , \"A blurple button\" )) @message_command () async def multiple_buttons ( self , ctx ): await ctx . send ( \"2 buttons in a row\" , components = [ Button ( ButtonStyles . BLURPLE , \"A blurple button\" ), Button ( ButtonStyles . RED , \"A red button\" )], ) @message_command () async def action_rows ( self , ctx ): await ctx . send ( \"2 buttons in 2 rows, using nested lists\" , components = [[ Button ( ButtonStyles . BLURPLE , \"A blurple button\" )], [ Button ( ButtonStyles . RED , \"A red button\" )]], ) @message_command () async def action_rows_more ( self , ctx ): await ctx . send ( \"2 buttons in 2 rows, using explicit action_rows lists\" , components = [ ActionRow ( Button ( ButtonStyles . BLURPLE , \"A blurple button\" )), ActionRow ( Button ( ButtonStyles . RED , \"A red button\" )), ], ) def setup ( bot ): ButtonExampleSkin ( bot ) Scales are effectively just another python file that contains a class that inherits from an object called Scale , inside this scale you can put whatever you would like. And upon loading, the contents are added to the bot. 1 2 3 4 5 6 7 8 from dis_snek.models.scale import Scale class SomeClass ( Scale ): ... def setup ( bot ): # This is called by dis-snek so it knows how to load the Scale SomeClass ( bot ) As you can see, theres one extra bit, a function called setup , this function acts as an entry point for dis-snek, so it knows how to load the scale properly. To load a scale, you simply add the following to your main script, just above bot.start : 1 2 3 4 5 ... bot . grow_scale ( \"Filename_here\" ) bot . start ( \"token\" ) Finally, for the cool bit of Scales, reloading. Scales allow you to edit your code, and reload it, without restarting the bot. To do this, simply run bot.regrow_scale(\"Filename_here\") and your new code will be used. Bare in mind any tasks your scale is doing will be abruptly stopped.","title":"Scales"},{"location":"Guides/scales/#scales","text":"Damn, your code is getting pretty messy now, huh? Wouldn't it be nice if you could organise your commands and listeners into separate files? Well let me introduce you to Scales Scales allow you to split your commands and listeners into separate files to allow you to better organise your project, as well as that, they allow you to reload Scales without having to shut down your bot. Sounds pretty good right? Well lets go over how you can use them:","title":"Scales"},{"location":"Guides/scales/#usage","text":"Below is an example of a bot, one with scales, one without. Example Usage: Without Scales With Scales 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 # File: `main.py` import logging import dis_snek.const from dis_snek.client import Snake from dis_snek.models.application_commands import slash_command , slash_option from dis_snek.models.command import message_command from dis_snek.models.context import InteractionContext from dis_snek.models.discord_objects.components import Button , ActionRow from dis_snek.models.enums import ButtonStyles from dis_snek.models.enums import Intents from dis_snek.models.events import Component from dis_snek.models.listener import listen logging . basicConfig () cls_log = logging . getLogger ( dis_snek . const . logger_name ) cls_log . setLevel ( logging . DEBUG ) bot = Snake ( intents = Intents . DEFAULT , sync_interactions = True , asyncio_debug = True ) @listen () async def on_ready (): print ( \"Ready\" ) print ( f \"This bot is owned by { bot . owner } \" ) @listen () async def on_guild_create ( event ): print ( f \"guild created : { event . guild . name } \" ) @listen () async def on_message_create ( event ): print ( f \"message received: { event . message . content } \" ) @listen () async def on_component ( event : Component ): ctx = event . context await ctx . edit_origin ( \"test\" ) @message_command () async def multiple_buttons ( ctx ): await ctx . send ( \"2 buttons in a row\" , components = [ Button ( ButtonStyles . BLURPLE , \"A blurple button\" ), Button ( ButtonStyles . RED , \"A red button\" )], ) @message_command () async def action_rows ( ctx ): await ctx . send ( \"2 buttons in 2 rows, using nested lists\" , components = [[ Button ( ButtonStyles . BLURPLE , \"A blurple button\" )], [ Button ( ButtonStyles . RED , \"A red button\" )]], ) @message_command () async def action_rows_more ( ctx ): await ctx . send ( \"2 buttons in 2 rows, using explicit action_rows lists\" , components = [ ActionRow ( Button ( ButtonStyles . BLURPLE , \"A blurple button\" )), ActionRow ( Button ( ButtonStyles . RED , \"A red button\" )), ], ) bot . start ( \"Token\" ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # File: `main.py` import logging import dis_snek.const from dis_snek.client import Snake from dis_snek.models.context import ComponentContext from dis_snek.models.enums import Intents from dis_snek.models.events import Component from dis_snek.models.listener import listen logging . basicConfig () cls_log = logging . getLogger ( dis_snek . const . logger_name ) cls_log . setLevel ( logging . DEBUG ) bot = Snake ( intents = Intents . DEFAULT , sync_interactions = True , asyncio_debug = True ) @listen () async def on_ready (): print ( \"Ready\" ) print ( f \"This bot is owned by { bot . owner } \" ) @listen () async def on_guild_create ( event ): print ( f \"guild created : { event . guild . name } \" ) @listen () async def on_message_create ( event ): print ( f \"message received: { event . message . content } \" ) @listen () async def on_component ( event : Component ): ctx = event . context await ctx . edit_origin ( \"test\" ) bot . grow_scale ( \"test_components\" ) bot . start ( \"Token\" ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # File: `test_components.py` from dis_snek.models.command import message_command from dis_snek.models.discord_objects.components import Button , ActionRow from dis_snek.models.enums import ButtonStyles from dis_snek.models.scale import Scale class ButtonExampleSkin ( Scale ): @message_command () async def blurple_button ( self , ctx ): await ctx . send ( \"hello there\" , components = Button ( ButtonStyles . BLURPLE , \"A blurple button\" )) @message_command () async def multiple_buttons ( self , ctx ): await ctx . send ( \"2 buttons in a row\" , components = [ Button ( ButtonStyles . BLURPLE , \"A blurple button\" ), Button ( ButtonStyles . RED , \"A red button\" )], ) @message_command () async def action_rows ( self , ctx ): await ctx . send ( \"2 buttons in 2 rows, using nested lists\" , components = [[ Button ( ButtonStyles . BLURPLE , \"A blurple button\" )], [ Button ( ButtonStyles . RED , \"A red button\" )]], ) @message_command () async def action_rows_more ( self , ctx ): await ctx . send ( \"2 buttons in 2 rows, using explicit action_rows lists\" , components = [ ActionRow ( Button ( ButtonStyles . BLURPLE , \"A blurple button\" )), ActionRow ( Button ( ButtonStyles . RED , \"A red button\" )), ], ) def setup ( bot ): ButtonExampleSkin ( bot ) Scales are effectively just another python file that contains a class that inherits from an object called Scale , inside this scale you can put whatever you would like. And upon loading, the contents are added to the bot. 1 2 3 4 5 6 7 8 from dis_snek.models.scale import Scale class SomeClass ( Scale ): ... def setup ( bot ): # This is called by dis-snek so it knows how to load the Scale SomeClass ( bot ) As you can see, theres one extra bit, a function called setup , this function acts as an entry point for dis-snek, so it knows how to load the scale properly. To load a scale, you simply add the following to your main script, just above bot.start : 1 2 3 4 5 ... bot . grow_scale ( \"Filename_here\" ) bot . start ( \"token\" ) Finally, for the cool bit of Scales, reloading. Scales allow you to edit your code, and reload it, without restarting the bot. To do this, simply run bot.regrow_scale(\"Filename_here\") and your new code will be used. Bare in mind any tasks your scale is doing will be abruptly stopped.","title":"Usage"},{"location":"snippets/discord_inv/","text":"Discord Server","title":"Discord inv"},{"location":"snippets/github_link/","text":"GitHub Repo","title":"Github link"}]}